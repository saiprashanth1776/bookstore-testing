{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Path_1 = require(\"./util/Path\");\n\nvar PriorityIndex_1 = require(\"./snap/indexes/PriorityIndex\");\n\nvar CountedSet_1 = require(\"./util/CountedSet\");\n/**\n * Helper class to store a sparse set of snapshots.\n *\n * @constructor\n */\n\n\nvar SparseSnapshotTree =\n/** @class */\nfunction () {\n  function SparseSnapshotTree() {\n    /**\n     * @private\n     * @type {Node}\n     */\n    this.value_ = null;\n    /**\n     * @private\n     * @type {CountedSet}\n     */\n\n    this.children_ = null;\n  }\n  /**\n   * Gets the node stored at the given path if one exists.\n   *\n   * @param {!Path} path Path to look up snapshot for.\n   * @return {?Node} The retrieved node, or null.\n   */\n\n\n  SparseSnapshotTree.prototype.find = function (path) {\n    if (this.value_ != null) {\n      return this.value_.getChild(path);\n    } else if (!path.isEmpty() && this.children_ != null) {\n      var childKey = path.getFront();\n      path = path.popFront();\n\n      if (this.children_.contains(childKey)) {\n        var childTree = this.children_.get(childKey);\n        return childTree.find(path);\n      } else {\n        return null;\n      }\n    } else {\n      return null;\n    }\n  };\n  /**\n   * Stores the given node at the specified path. If there is already a node\n   * at a shallower path, it merges the new data into that snapshot node.\n   *\n   * @param {!Path} path Path to look up snapshot for.\n   * @param {!Node} data The new data, or null.\n   */\n\n\n  SparseSnapshotTree.prototype.remember = function (path, data) {\n    if (path.isEmpty()) {\n      this.value_ = data;\n      this.children_ = null;\n    } else if (this.value_ !== null) {\n      this.value_ = this.value_.updateChild(path, data);\n    } else {\n      if (this.children_ == null) {\n        this.children_ = new CountedSet_1.CountedSet();\n      }\n\n      var childKey = path.getFront();\n\n      if (!this.children_.contains(childKey)) {\n        this.children_.add(childKey, new SparseSnapshotTree());\n      }\n\n      var child = this.children_.get(childKey);\n      path = path.popFront();\n      child.remember(path, data);\n    }\n  };\n  /**\n   * Purge the data at path from the cache.\n   *\n   * @param {!Path} path Path to look up snapshot for.\n   * @return {boolean} True if this node should now be removed.\n   */\n\n\n  SparseSnapshotTree.prototype.forget = function (path) {\n    if (path.isEmpty()) {\n      this.value_ = null;\n      this.children_ = null;\n      return true;\n    } else {\n      if (this.value_ !== null) {\n        if (this.value_.isLeafNode()) {\n          // We're trying to forget a node that doesn't exist\n          return false;\n        } else {\n          var value = this.value_;\n          this.value_ = null;\n          var self_1 = this;\n          value.forEachChild(PriorityIndex_1.PRIORITY_INDEX, function (key, tree) {\n            self_1.remember(new Path_1.Path(key), tree);\n          });\n          return this.forget(path);\n        }\n      } else if (this.children_ !== null) {\n        var childKey = path.getFront();\n        path = path.popFront();\n\n        if (this.children_.contains(childKey)) {\n          var safeToRemove = this.children_.get(childKey).forget(path);\n\n          if (safeToRemove) {\n            this.children_.remove(childKey);\n          }\n        }\n\n        if (this.children_.isEmpty()) {\n          this.children_ = null;\n          return true;\n        } else {\n          return false;\n        }\n      } else {\n        return true;\n      }\n    }\n  };\n  /**\n   * Recursively iterates through all of the stored tree and calls the\n   * callback on each one.\n   *\n   * @param {!Path} prefixPath Path to look up node for.\n   * @param {!Function} func The function to invoke for each tree.\n   */\n\n\n  SparseSnapshotTree.prototype.forEachTree = function (prefixPath, func) {\n    if (this.value_ !== null) {\n      func(prefixPath, this.value_);\n    } else {\n      this.forEachChild(function (key, tree) {\n        var path = new Path_1.Path(prefixPath.toString() + '/' + key);\n        tree.forEachTree(path, func);\n      });\n    }\n  };\n  /**\n   * Iterates through each immediate child and triggers the callback.\n   *\n   * @param {!Function} func The function to invoke for each child.\n   */\n\n\n  SparseSnapshotTree.prototype.forEachChild = function (func) {\n    if (this.children_ !== null) {\n      this.children_.each(function (key, tree) {\n        func(key, tree);\n      });\n    }\n  };\n\n  return SparseSnapshotTree;\n}();\n\nexports.SparseSnapshotTree = SparseSnapshotTree;","map":{"version":3,"sources":["../src/core/SparseSnapshotTree.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Path } from './util/Path';\nimport { PRIORITY_INDEX } from './snap/indexes/PriorityIndex';\nimport { CountedSet } from './util/CountedSet';\nimport { Node } from './snap/Node';\n\n/**\n * Helper class to store a sparse set of snapshots.\n *\n * @constructor\n */\nexport class SparseSnapshotTree {\n  /**\n   * @private\n   * @type {Node}\n   */\n  private value_: Node | null = null;\n\n  /**\n   * @private\n   * @type {CountedSet}\n   */\n  private children_: CountedSet<string, SparseSnapshotTree> | null = null;\n\n  /**\n   * Gets the node stored at the given path if one exists.\n   *\n   * @param {!Path} path Path to look up snapshot for.\n   * @return {?Node} The retrieved node, or null.\n   */\n  find(path: Path): Node | null {\n    if (this.value_ != null) {\n      return this.value_.getChild(path);\n    } else if (!path.isEmpty() && this.children_ != null) {\n      const childKey = path.getFront();\n      path = path.popFront();\n      if (this.children_.contains(childKey)) {\n        const childTree = this.children_.get(childKey) as SparseSnapshotTree;\n        return childTree.find(path);\n      } else {\n        return null;\n      }\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Stores the given node at the specified path. If there is already a node\n   * at a shallower path, it merges the new data into that snapshot node.\n   *\n   * @param {!Path} path Path to look up snapshot for.\n   * @param {!Node} data The new data, or null.\n   */\n  remember(path: Path, data: Node) {\n    if (path.isEmpty()) {\n      this.value_ = data;\n      this.children_ = null;\n    } else if (this.value_ !== null) {\n      this.value_ = this.value_.updateChild(path, data);\n    } else {\n      if (this.children_ == null) {\n        this.children_ = new CountedSet<string, SparseSnapshotTree>();\n      }\n\n      const childKey = path.getFront();\n      if (!this.children_.contains(childKey)) {\n        this.children_.add(childKey, new SparseSnapshotTree());\n      }\n\n      const child = this.children_.get(childKey) as SparseSnapshotTree;\n      path = path.popFront();\n      child.remember(path, data);\n    }\n  }\n\n  /**\n   * Purge the data at path from the cache.\n   *\n   * @param {!Path} path Path to look up snapshot for.\n   * @return {boolean} True if this node should now be removed.\n   */\n  forget(path: Path): boolean {\n    if (path.isEmpty()) {\n      this.value_ = null;\n      this.children_ = null;\n      return true;\n    } else {\n      if (this.value_ !== null) {\n        if (this.value_.isLeafNode()) {\n          // We're trying to forget a node that doesn't exist\n          return false;\n        } else {\n          const value = this.value_;\n          this.value_ = null;\n\n          const self = this;\n          value.forEachChild(PRIORITY_INDEX, function(key, tree) {\n            self.remember(new Path(key), tree);\n          });\n\n          return this.forget(path);\n        }\n      } else if (this.children_ !== null) {\n        const childKey = path.getFront();\n        path = path.popFront();\n        if (this.children_.contains(childKey)) {\n          const safeToRemove = (this.children_.get(\n            childKey\n          ) as SparseSnapshotTree).forget(path);\n          if (safeToRemove) {\n            this.children_.remove(childKey);\n          }\n        }\n\n        if (this.children_.isEmpty()) {\n          this.children_ = null;\n          return true;\n        } else {\n          return false;\n        }\n      } else {\n        return true;\n      }\n    }\n  }\n\n  /**\n   * Recursively iterates through all of the stored tree and calls the\n   * callback on each one.\n   *\n   * @param {!Path} prefixPath Path to look up node for.\n   * @param {!Function} func The function to invoke for each tree.\n   */\n  forEachTree(prefixPath: Path, func: (a: Path, b: Node) => any) {\n    if (this.value_ !== null) {\n      func(prefixPath, this.value_);\n    } else {\n      this.forEachChild((key, tree) => {\n        const path = new Path(prefixPath.toString() + '/' + key);\n        tree.forEachTree(path, func);\n      });\n    }\n  }\n\n  /**\n   * Iterates through each immediate child and triggers the callback.\n   *\n   * @param {!Function} func The function to invoke for each child.\n   */\n  forEachChild(func: (a: string, b: SparseSnapshotTree) => void) {\n    if (this.children_ !== null) {\n      this.children_.each((key, tree) => {\n        func(key, tree);\n      });\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}