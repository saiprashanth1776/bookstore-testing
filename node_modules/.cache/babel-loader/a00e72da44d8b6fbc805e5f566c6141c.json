{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar util_1 = require(\"../util/util\");\n/**\n * The event queue serves a few purposes:\n * 1. It ensures we maintain event order in the face of event callbacks doing operations that result in more\n *    events being queued.\n * 2. raiseQueuedEvents() handles being called reentrantly nicely.  That is, if in the course of raising events,\n *    raiseQueuedEvents() is called again, the \"inner\" call will pick up raising events where the \"outer\" call\n *    left off, ensuring that the events are still raised synchronously and in order.\n * 3. You can use raiseEventsAtPath and raiseEventsForChangedPath to ensure only relevant previously-queued\n *    events are raised synchronously.\n *\n * NOTE: This can all go away if/when we move to async events.\n *\n * @constructor\n */\n\n\nvar EventQueue =\n/** @class */\nfunction () {\n  function EventQueue() {\n    /**\n     * @private\n     * @type {!Array.<EventList>}\n     */\n    this.eventLists_ = [];\n    /**\n     * Tracks recursion depth of raiseQueuedEvents_, for debugging purposes.\n     * @private\n     * @type {!number}\n     */\n\n    this.recursionDepth_ = 0;\n  }\n  /**\n   * @param {!Array.<Event>} eventDataList The new events to queue.\n   */\n\n\n  EventQueue.prototype.queueEvents = function (eventDataList) {\n    // We group events by path, storing them in a single EventList, to make it easier to skip over them quickly.\n    var currList = null;\n\n    for (var i = 0; i < eventDataList.length; i++) {\n      var eventData = eventDataList[i];\n      var eventPath = eventData.getPath();\n\n      if (currList !== null && !eventPath.equals(currList.getPath())) {\n        this.eventLists_.push(currList);\n        currList = null;\n      }\n\n      if (currList === null) {\n        currList = new EventList(eventPath);\n      }\n\n      currList.add(eventData);\n    }\n\n    if (currList) {\n      this.eventLists_.push(currList);\n    }\n  };\n  /**\n   * Queues the specified events and synchronously raises all events (including previously queued ones)\n   * for the specified path.\n   *\n   * It is assumed that the new events are all for the specified path.\n   *\n   * @param {!Path} path The path to raise events for.\n   * @param {!Array.<Event>} eventDataList The new events to raise.\n   */\n\n\n  EventQueue.prototype.raiseEventsAtPath = function (path, eventDataList) {\n    this.queueEvents(eventDataList);\n    this.raiseQueuedEventsMatchingPredicate_(function (eventPath) {\n      return eventPath.equals(path);\n    });\n  };\n  /**\n   * Queues the specified events and synchronously raises all events (including previously queued ones) for\n   * locations related to the specified change path (i.e. all ancestors and descendants).\n   *\n   * It is assumed that the new events are all related (ancestor or descendant) to the specified path.\n   *\n   * @param {!Path} changedPath The path to raise events for.\n   * @param {!Array.<!Event>} eventDataList The events to raise\n   */\n\n\n  EventQueue.prototype.raiseEventsForChangedPath = function (changedPath, eventDataList) {\n    this.queueEvents(eventDataList);\n    this.raiseQueuedEventsMatchingPredicate_(function (eventPath) {\n      return eventPath.contains(changedPath) || changedPath.contains(eventPath);\n    });\n  };\n  /**\n   * @param {!function(!Path):boolean} predicate\n   * @private\n   */\n\n\n  EventQueue.prototype.raiseQueuedEventsMatchingPredicate_ = function (predicate) {\n    this.recursionDepth_++;\n    var sentAll = true;\n\n    for (var i = 0; i < this.eventLists_.length; i++) {\n      var eventList = this.eventLists_[i];\n\n      if (eventList) {\n        var eventPath = eventList.getPath();\n\n        if (predicate(eventPath)) {\n          this.eventLists_[i].raise();\n          this.eventLists_[i] = null;\n        } else {\n          sentAll = false;\n        }\n      }\n    }\n\n    if (sentAll) {\n      this.eventLists_ = [];\n    }\n\n    this.recursionDepth_--;\n  };\n\n  return EventQueue;\n}();\n\nexports.EventQueue = EventQueue;\n/**\n * @param {!Path} path\n * @constructor\n */\n\nvar EventList =\n/** @class */\nfunction () {\n  function EventList(path_) {\n    this.path_ = path_;\n    /**\n     * @type {!Array.<Event>}\n     * @private\n     */\n\n    this.events_ = [];\n  }\n  /**\n   * @param {!Event} eventData\n   */\n\n\n  EventList.prototype.add = function (eventData) {\n    this.events_.push(eventData);\n  };\n  /**\n   * Iterates through the list and raises each event\n   */\n\n\n  EventList.prototype.raise = function () {\n    for (var i = 0; i < this.events_.length; i++) {\n      var eventData = this.events_[i];\n\n      if (eventData !== null) {\n        this.events_[i] = null;\n        var eventFn = eventData.getEventRunner();\n\n        if (util_1.logger) {\n          util_1.log('event: ' + eventData.toString());\n        }\n\n        util_1.exceptionGuard(eventFn);\n      }\n    }\n  };\n  /**\n   * @return {!Path}\n   */\n\n\n  EventList.prototype.getPath = function () {\n    return this.path_;\n  };\n\n  return EventList;\n}();\n\nexports.EventList = EventList;","map":{"version":3,"sources":["../src/core/view/EventQueue.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Path } from '../util/Path';\nimport { log, logger, exceptionGuard } from '../util/util';\nimport { Event } from './Event';\n\n/**\n * The event queue serves a few purposes:\n * 1. It ensures we maintain event order in the face of event callbacks doing operations that result in more\n *    events being queued.\n * 2. raiseQueuedEvents() handles being called reentrantly nicely.  That is, if in the course of raising events,\n *    raiseQueuedEvents() is called again, the \"inner\" call will pick up raising events where the \"outer\" call\n *    left off, ensuring that the events are still raised synchronously and in order.\n * 3. You can use raiseEventsAtPath and raiseEventsForChangedPath to ensure only relevant previously-queued\n *    events are raised synchronously.\n *\n * NOTE: This can all go away if/when we move to async events.\n *\n * @constructor\n */\nexport class EventQueue {\n  /**\n   * @private\n   * @type {!Array.<EventList>}\n   */\n  private eventLists_: EventList[] = [];\n\n  /**\n   * Tracks recursion depth of raiseQueuedEvents_, for debugging purposes.\n   * @private\n   * @type {!number}\n   */\n  private recursionDepth_ = 0;\n\n  /**\n   * @param {!Array.<Event>} eventDataList The new events to queue.\n   */\n  queueEvents(eventDataList: Event[]) {\n    // We group events by path, storing them in a single EventList, to make it easier to skip over them quickly.\n    let currList = null;\n    for (let i = 0; i < eventDataList.length; i++) {\n      const eventData = eventDataList[i];\n      const eventPath = eventData.getPath();\n      if (currList !== null && !eventPath.equals(currList.getPath())) {\n        this.eventLists_.push(currList);\n        currList = null;\n      }\n\n      if (currList === null) {\n        currList = new EventList(eventPath);\n      }\n\n      currList.add(eventData);\n    }\n    if (currList) {\n      this.eventLists_.push(currList);\n    }\n  }\n\n  /**\n   * Queues the specified events and synchronously raises all events (including previously queued ones)\n   * for the specified path.\n   *\n   * It is assumed that the new events are all for the specified path.\n   *\n   * @param {!Path} path The path to raise events for.\n   * @param {!Array.<Event>} eventDataList The new events to raise.\n   */\n  raiseEventsAtPath(path: Path, eventDataList: Event[]) {\n    this.queueEvents(eventDataList);\n    this.raiseQueuedEventsMatchingPredicate_((eventPath: Path) =>\n      eventPath.equals(path)\n    );\n  }\n\n  /**\n   * Queues the specified events and synchronously raises all events (including previously queued ones) for\n   * locations related to the specified change path (i.e. all ancestors and descendants).\n   *\n   * It is assumed that the new events are all related (ancestor or descendant) to the specified path.\n   *\n   * @param {!Path} changedPath The path to raise events for.\n   * @param {!Array.<!Event>} eventDataList The events to raise\n   */\n  raiseEventsForChangedPath(changedPath: Path, eventDataList: Event[]) {\n    this.queueEvents(eventDataList);\n\n    this.raiseQueuedEventsMatchingPredicate_((eventPath: Path) => {\n      return eventPath.contains(changedPath) || changedPath.contains(eventPath);\n    });\n  }\n\n  /**\n   * @param {!function(!Path):boolean} predicate\n   * @private\n   */\n  private raiseQueuedEventsMatchingPredicate_(\n    predicate: (path: Path) => boolean\n  ) {\n    this.recursionDepth_++;\n\n    let sentAll = true;\n    for (let i = 0; i < this.eventLists_.length; i++) {\n      const eventList = this.eventLists_[i];\n      if (eventList) {\n        const eventPath = eventList.getPath();\n        if (predicate(eventPath)) {\n          this.eventLists_[i].raise();\n          this.eventLists_[i] = null;\n        } else {\n          sentAll = false;\n        }\n      }\n    }\n\n    if (sentAll) {\n      this.eventLists_ = [];\n    }\n\n    this.recursionDepth_--;\n  }\n}\n\n/**\n * @param {!Path} path\n * @constructor\n */\nexport class EventList {\n  /**\n   * @type {!Array.<Event>}\n   * @private\n   */\n  private events_: Event[] = [];\n\n  constructor(private readonly path_: Path) {}\n\n  /**\n   * @param {!Event} eventData\n   */\n  add(eventData: Event) {\n    this.events_.push(eventData);\n  }\n\n  /**\n   * Iterates through the list and raises each event\n   */\n  raise() {\n    for (let i = 0; i < this.events_.length; i++) {\n      const eventData = this.events_[i];\n      if (eventData !== null) {\n        this.events_[i] = null;\n        const eventFn = eventData.getEventRunner();\n        if (logger) {\n          log('event: ' + eventData.toString());\n        }\n        exceptionGuard(eventFn);\n      }\n    }\n  }\n\n  /**\n   * @return {!Path}\n   */\n  getPath(): Path {\n    return this.path_;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}