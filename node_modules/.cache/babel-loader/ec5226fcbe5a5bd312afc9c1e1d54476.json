{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar RepoInfo_1 = require(\"../core/RepoInfo\");\n\nvar PersistentConnection_1 = require(\"../core/PersistentConnection\");\n\nvar RepoManager_1 = require(\"../core/RepoManager\");\n\nvar Connection_1 = require(\"../realtime/Connection\");\n\nexports.DataConnection = PersistentConnection_1.PersistentConnection;\n/**\n * @param {!string} pathString\n * @param {function(*)} onComplete\n */\n\nPersistentConnection_1.PersistentConnection.prototype.simpleListen = function (pathString, onComplete) {\n  this.sendRequest('q', {\n    p: pathString\n  }, onComplete);\n};\n/**\n * @param {*} data\n * @param {function(*)} onEcho\n */\n\n\nPersistentConnection_1.PersistentConnection.prototype.echo = function (data, onEcho) {\n  this.sendRequest('echo', {\n    d: data\n  }, onEcho);\n}; // RealTimeConnection properties that we use in tests.\n\n\nexports.RealTimeConnection = Connection_1.Connection;\n/**\n * @param {function(): string} newHash\n * @return {function()}\n */\n\nexports.hijackHash = function (newHash) {\n  var oldPut = PersistentConnection_1.PersistentConnection.prototype.put;\n\n  PersistentConnection_1.PersistentConnection.prototype.put = function (pathString, data, opt_onComplete, opt_hash) {\n    if (opt_hash !== undefined) {\n      opt_hash = newHash();\n    }\n\n    oldPut.call(this, pathString, data, opt_onComplete, opt_hash);\n  };\n\n  return function () {\n    PersistentConnection_1.PersistentConnection.prototype.put = oldPut;\n  };\n};\n/**\n * @type {function(new:RepoInfo, !string, boolean, !string, boolean): undefined}\n */\n\n\nexports.ConnectionTarget = RepoInfo_1.RepoInfo;\n/**\n * @param {!Query} query\n * @return {!string}\n */\n\nexports.queryIdentifier = function (query) {\n  return query.queryIdentifier();\n};\n/**\n * @param {!Query} firebaseRef\n * @return {!Object}\n */\n\n\nexports.listens = function (firebaseRef) {\n  return firebaseRef.repo.persistentConnection_.listens_;\n};\n/**\n * Forces the RepoManager to create Repos that use ReadonlyRestClient instead of PersistentConnection.\n *\n * @param {boolean} forceRestClient\n */\n\n\nexports.forceRestClient = function (forceRestClient) {\n  RepoManager_1.RepoManager.getInstance().forceRestClient(forceRestClient);\n};","map":{"version":3,"sources":["../src/api/test_access.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;;;;;;AAgBA,IAAA,UAAA,GAAA,OAAA,CAAA,kBAAA,CAAA;;AACA,IAAA,sBAAA,GAAA,OAAA,CAAA,8BAAA,CAAA;;AACA,IAAA,aAAA,GAAA,OAAA,CAAA,qBAAA,CAAA;;AACA,IAAA,YAAA,GAAA,OAAA,CAAA,wBAAA,CAAA;;AAGa,OAAA,CAAA,cAAA,GAAiB,sBAAA,CAAA,oBAAjB;AAEb;;;;;AAIC,sBAAA,CAAA,oBAAA,CAAqB,SAArB,CAAuC,YAAvC,GAAsD,UACrD,UADqD,EAErD,UAFqD,EAEzB;AAE5B,OAAK,WAAL,CAAiB,GAAjB,EAAsB;AAAE,IAAA,CAAC,EAAE;AAAL,GAAtB,EAAyC,UAAzC;AACD,CALA;AAOD;;;;;;AAIC,sBAAA,CAAA,oBAAA,CAAqB,SAArB,CAAuC,IAAvC,GAA8C,UAC7C,IAD6C,EAE7C,MAF6C,EAErB;AAExB,OAAK,WAAL,CAAiB,MAAjB,EAAyB;AAAE,IAAA,CAAC,EAAE;AAAL,GAAzB,EAAsC,MAAtC;AACD,CALA,C,CAOD;;;AACa,OAAA,CAAA,kBAAA,GAAqB,YAAA,CAAA,UAArB;AAEb;;;;;AAIa,OAAA,CAAA,UAAA,GAAa,UAAS,OAAT,EAA8B;AACtD,MAAM,MAAM,GAAG,sBAAA,CAAA,oBAAA,CAAqB,SAArB,CAA+B,GAA9C;;AACA,EAAA,sBAAA,CAAA,oBAAA,CAAqB,SAArB,CAA+B,GAA/B,GAAqC,UACnC,UADmC,EAEnC,IAFmC,EAGnC,cAHmC,EAInC,QAJmC,EAI3B;AAER,QAAI,QAAQ,KAAK,SAAjB,EAA4B;AAC1B,MAAA,QAAQ,GAAG,OAAO,EAAlB;AACD;;AACD,IAAA,MAAM,CAAC,IAAP,CAAY,IAAZ,EAAkB,UAAlB,EAA8B,IAA9B,EAAoC,cAApC,EAAoD,QAApD;AACD,GAVD;;AAWA,SAAO,YAAA;AACL,IAAA,sBAAA,CAAA,oBAAA,CAAqB,SAArB,CAA+B,GAA/B,GAAqC,MAArC;AACD,GAFD;AAGD,CAhBY;AAkBb;;;;;AAGa,OAAA,CAAA,gBAAA,GAAmB,UAAA,CAAA,QAAnB;AAEb;;;;;AAIa,OAAA,CAAA,eAAA,GAAkB,UAAS,KAAT,EAAqB;AAClD,SAAO,KAAK,CAAC,eAAN,EAAP;AACD,CAFY;AAIb;;;;;;AAIa,OAAA,CAAA,OAAA,GAAU,UAAS,WAAT,EAA2B;AAChD,SAAQ,WAAW,CAAC,IAAZ,CAAiB,qBAAjB,CAA+C,QAAvD;AACD,CAFY;AAIb;;;;;;;AAKa,OAAA,CAAA,eAAA,GAAkB,UAAS,eAAT,EAAiC;AAC9D,EAAA,aAAA,CAAA,WAAA,CAAY,WAAZ,GAA0B,eAA1B,CAA0C,eAA1C;AACD,CAFY","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { RepoInfo } from '../core/RepoInfo';\nimport { PersistentConnection } from '../core/PersistentConnection';\nimport { RepoManager } from '../core/RepoManager';\nimport { Connection } from '../realtime/Connection';\nimport { Query } from './Query';\n\nexport const DataConnection = PersistentConnection;\n\n/**\n * @param {!string} pathString\n * @param {function(*)} onComplete\n */\n(PersistentConnection.prototype as any).simpleListen = function(\n  pathString: string,\n  onComplete: (a: any) => void\n) {\n  this.sendRequest('q', { p: pathString }, onComplete);\n};\n\n/**\n * @param {*} data\n * @param {function(*)} onEcho\n */\n(PersistentConnection.prototype as any).echo = function(\n  data: any,\n  onEcho: (a: any) => void\n) {\n  this.sendRequest('echo', { d: data }, onEcho);\n};\n\n// RealTimeConnection properties that we use in tests.\nexport const RealTimeConnection = Connection;\n\n/**\n * @param {function(): string} newHash\n * @return {function()}\n */\nexport const hijackHash = function(newHash: () => string) {\n  const oldPut = PersistentConnection.prototype.put;\n  PersistentConnection.prototype.put = function(\n    pathString,\n    data,\n    opt_onComplete,\n    opt_hash\n  ) {\n    if (opt_hash !== undefined) {\n      opt_hash = newHash();\n    }\n    oldPut.call(this, pathString, data, opt_onComplete, opt_hash);\n  };\n  return function() {\n    PersistentConnection.prototype.put = oldPut;\n  };\n};\n\n/**\n * @type {function(new:RepoInfo, !string, boolean, !string, boolean): undefined}\n */\nexport const ConnectionTarget = RepoInfo;\n\n/**\n * @param {!Query} query\n * @return {!string}\n */\nexport const queryIdentifier = function(query: Query) {\n  return query.queryIdentifier();\n};\n\n/**\n * @param {!Query} firebaseRef\n * @return {!Object}\n */\nexport const listens = function(firebaseRef: Query) {\n  return (firebaseRef.repo.persistentConnection_ as any).listens_;\n};\n\n/**\n * Forces the RepoManager to create Repos that use ReadonlyRestClient instead of PersistentConnection.\n *\n * @param {boolean} forceRestClient\n */\nexport const forceRestClient = function(forceRestClient: boolean) {\n  RepoManager.getInstance().forceRestClient(forceRestClient);\n};\n"]},"metadata":{},"sourceType":"script"}