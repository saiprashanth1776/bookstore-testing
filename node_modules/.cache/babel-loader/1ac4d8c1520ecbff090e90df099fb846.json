{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\n\nimport * as tslib_1 from \"tslib\";\nimport { ErrorFactory } from '@firebase/util';\nimport Errors from '../models/errors';\nimport TokenDetailsModel from '../models/token-details-model';\nimport VapidDetailsModel from '../models/vapid-details-model';\nimport NOTIFICATION_PERMISSION from '../models/notification-permission';\nimport IIDModel from '../models/iid-model';\nimport arrayBufferToBase64 from '../helpers/array-buffer-to-base64';\nvar SENDER_ID_OPTION_NAME = 'messagingSenderId'; // Database cache should be invalidated once a week.\n\nexport var TOKEN_EXPIRATION_MILLIS = 7 * 24 * 60 * 60 * 1000; // 7 days\n\nvar ControllerInterface =\n/** @class */\nfunction () {\n  /**\n   * An interface of the Messaging Service API\n   * @param {!firebase.app.App} app\n   */\n  function ControllerInterface(app) {\n    var _this = this;\n\n    this.errorFactory_ = new ErrorFactory('messaging', 'Messaging', Errors.map);\n\n    if (!app.options[SENDER_ID_OPTION_NAME] || typeof app.options[SENDER_ID_OPTION_NAME] !== 'string') {\n      throw this.errorFactory_.create(Errors.codes.BAD_SENDER_ID);\n    }\n\n    this.messagingSenderId_ = app.options[SENDER_ID_OPTION_NAME];\n    this.tokenDetailsModel_ = new TokenDetailsModel();\n    this.vapidDetailsModel_ = new VapidDetailsModel();\n    this.iidModel_ = new IIDModel();\n    this.app = app;\n    this.INTERNAL = {};\n\n    this.INTERNAL.delete = function () {\n      return _this.delete();\n    };\n  }\n  /**\n   * @export\n   */\n\n\n  ControllerInterface.prototype.getToken = function () {\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var currentPermission, swReg, publicVapidKey, pushSubscription, tokenDetails;\n      return tslib_1.__generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            currentPermission = this.getNotificationPermission_();\n\n            if (currentPermission !== NOTIFICATION_PERMISSION.granted) {\n              if (currentPermission === NOTIFICATION_PERMISSION.denied) {\n                return [2\n                /*return*/\n                , Promise.reject(this.errorFactory_.create(Errors.codes.NOTIFICATIONS_BLOCKED))];\n              } // We must wait for permission to be granted\n\n\n              return [2\n              /*return*/\n              , Promise.resolve(null)];\n            }\n\n            return [4\n            /*yield*/\n            , this.getSWRegistration_()];\n\n          case 1:\n            swReg = _a.sent();\n            return [4\n            /*yield*/\n            , this.getPublicVapidKey_()];\n\n          case 2:\n            publicVapidKey = _a.sent();\n            return [4\n            /*yield*/\n            , this.getPushSubscription(swReg, publicVapidKey)];\n\n          case 3:\n            pushSubscription = _a.sent();\n            return [4\n            /*yield*/\n            , this.tokenDetailsModel_.getTokenDetailsFromSWScope(swReg.scope)];\n\n          case 4:\n            tokenDetails = _a.sent();\n\n            if (tokenDetails) {\n              return [2\n              /*return*/\n              , this.manageExistingToken(swReg, pushSubscription, publicVapidKey, tokenDetails)];\n            }\n\n            return [2\n            /*return*/\n            , this.getNewToken(swReg, pushSubscription, publicVapidKey)];\n        }\n      });\n    });\n  };\n  /**\n   * manageExistingToken is triggered if there's an existing FCM token in the\n   * database and it can take 3 different actions:\n   * 1) Retrieve the existing FCM token from the database.\n   * 2) If VAPID details have changed: Delete the existing token and create a\n   * new one with the new VAPID key.\n   * 3) If the database cache is invalidated: Send a request to FCM to update\n   * the token, and to check if the token is still valid on FCM-side.\n   */\n\n\n  ControllerInterface.prototype.manageExistingToken = function (swReg, pushSubscription, publicVapidKey, tokenDetails) {\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var isTokenValid, now;\n      return tslib_1.__generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            isTokenValid = this.isTokenStillValid(pushSubscription, publicVapidKey, tokenDetails);\n\n            if (isTokenValid) {\n              now = Date.now();\n\n              if (now < tokenDetails['createTime'] + TOKEN_EXPIRATION_MILLIS) {\n                return [2\n                /*return*/\n                , tokenDetails['fcmToken']];\n              } else {\n                return [2\n                /*return*/\n                , this.updateToken(swReg, pushSubscription, publicVapidKey, tokenDetails)];\n              }\n            } // If the token is no longer valid (for example if the VAPID details\n            // have changed), delete the existing token, and create a new one.\n\n\n            return [4\n            /*yield*/\n            , this.deleteToken(tokenDetails['fcmToken'])];\n\n          case 1:\n            // If the token is no longer valid (for example if the VAPID details\n            // have changed), delete the existing token, and create a new one.\n            _a.sent();\n\n            return [2\n            /*return*/\n            , this.getNewToken(swReg, pushSubscription, publicVapidKey)];\n        }\n      });\n    });\n  };\n  /*\n   * Checks if the tokenDetails match the details provided in the clients.\n   */\n\n\n  ControllerInterface.prototype.isTokenStillValid = function (pushSubscription, publicVapidKey, tokenDetails) {\n    if (arrayBufferToBase64(publicVapidKey) !== tokenDetails['vapidKey']) {\n      return false;\n    } // getKey() isn't defined in the PushSubscription externs file, hence\n    // subscription['getKey']('<key name>').\n\n\n    return pushSubscription.endpoint === tokenDetails['endpoint'] && arrayBufferToBase64(pushSubscription['getKey']('auth')) === tokenDetails['auth'] && arrayBufferToBase64(pushSubscription['getKey']('p256dh')) === tokenDetails['p256dh'];\n  };\n\n  ControllerInterface.prototype.updateToken = function (swReg, pushSubscription, publicVapidKey, tokenDetails) {\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var updatedToken, allDetails, e_1;\n      return tslib_1.__generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 4,, 6]);\n\n            return [4\n            /*yield*/\n            , this.iidModel_.updateToken(this.messagingSenderId_, tokenDetails['fcmToken'], tokenDetails['fcmPushSet'], pushSubscription, publicVapidKey)];\n\n          case 1:\n            updatedToken = _a.sent();\n            allDetails = {\n              swScope: swReg.scope,\n              vapidKey: publicVapidKey,\n              subscription: pushSubscription,\n              fcmSenderId: this.messagingSenderId_,\n              fcmToken: updatedToken,\n              fcmPushSet: tokenDetails['fcmPushSet']\n            };\n            return [4\n            /*yield*/\n            , this.tokenDetailsModel_.saveTokenDetails(allDetails)];\n\n          case 2:\n            _a.sent();\n\n            return [4\n            /*yield*/\n            , this.vapidDetailsModel_.saveVapidDetails(swReg.scope, publicVapidKey)];\n\n          case 3:\n            _a.sent();\n\n            return [2\n            /*return*/\n            , updatedToken];\n\n          case 4:\n            e_1 = _a.sent();\n            return [4\n            /*yield*/\n            , this.deleteToken(tokenDetails['fcmToken'])];\n\n          case 5:\n            _a.sent();\n\n            throw e_1;\n\n          case 6:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  ControllerInterface.prototype.getNewToken = function (swReg, pushSubscription, publicVapidKey) {\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var tokenDetails, allDetails;\n      return tslib_1.__generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.iidModel_.getToken(this.messagingSenderId_, pushSubscription, publicVapidKey)];\n\n          case 1:\n            tokenDetails = _a.sent();\n            allDetails = {\n              swScope: swReg.scope,\n              vapidKey: publicVapidKey,\n              subscription: pushSubscription,\n              fcmSenderId: this.messagingSenderId_,\n              fcmToken: tokenDetails['token'],\n              fcmPushSet: tokenDetails['pushSet']\n            };\n            return [4\n            /*yield*/\n            , this.tokenDetailsModel_.saveTokenDetails(allDetails)];\n\n          case 2:\n            _a.sent();\n\n            return [4\n            /*yield*/\n            , this.vapidDetailsModel_.saveVapidDetails(swReg.scope, publicVapidKey)];\n\n          case 3:\n            _a.sent();\n\n            return [2\n            /*return*/\n            , tokenDetails['token']];\n        }\n      });\n    });\n  };\n  /**\n   * This method deletes tokens that the token manager looks after,\n   * unsubscribes the token from FCM  and then unregisters the push\n   * subscription if it exists. It returns a promise that indicates\n   * whether or not the unsubscribe request was processed successfully.\n   * @export\n   */\n\n\n  ControllerInterface.prototype.deleteToken = function (token) {\n    var _this = this;\n\n    return this.tokenDetailsModel_.deleteToken(token).then(function (details) {\n      return _this.iidModel_.deleteToken(details['fcmSenderId'], details['fcmToken'], details['fcmPushSet']);\n    }).then(function () {\n      return _this.getSWRegistration_().then(function (registration) {\n        if (registration) {\n          return registration.pushManager.getSubscription();\n        }\n      }).then(function (subscription) {\n        if (subscription) {\n          return subscription.unsubscribe();\n        }\n      });\n    });\n  };\n\n  ControllerInterface.prototype.getSWRegistration_ = function () {\n    throw this.errorFactory_.create(Errors.codes.SHOULD_BE_INHERITED);\n  };\n\n  ControllerInterface.prototype.getPublicVapidKey_ = function () {\n    throw this.errorFactory_.create(Errors.codes.SHOULD_BE_INHERITED);\n  }; //\n  // The following methods should only be available in the window.\n  //\n\n\n  ControllerInterface.prototype.requestPermission = function () {\n    throw this.errorFactory_.create(Errors.codes.AVAILABLE_IN_WINDOW);\n  };\n  /**\n   * Gets a PushSubscription for the current user.\n   */\n\n\n  ControllerInterface.prototype.getPushSubscription = function (swRegistration, publicVapidKey) {\n    return swRegistration.pushManager.getSubscription().then(function (subscription) {\n      if (subscription) {\n        return subscription;\n      }\n\n      return swRegistration.pushManager.subscribe({\n        userVisibleOnly: true,\n        applicationServerKey: publicVapidKey\n      });\n    });\n  };\n  /**\n   * @export\n   * @param {!ServiceWorkerRegistration} registration\n   */\n\n\n  ControllerInterface.prototype.useServiceWorker = function (registration) {\n    throw this.errorFactory_.create(Errors.codes.AVAILABLE_IN_WINDOW);\n  };\n  /**\n   * @export\n   * @param {!string} b64PublicKey\n   */\n\n\n  ControllerInterface.prototype.usePublicVapidKey = function (b64PublicKey) {\n    throw this.errorFactory_.create(Errors.codes.AVAILABLE_IN_WINDOW);\n  };\n  /**\n   * @export\n   * @param {!firebase.Observer|function(*)} nextOrObserver\n   * @param {function(!Error)=} optError\n   * @param {function()=} optCompleted\n   * @return {!function()}\n   */\n\n\n  ControllerInterface.prototype.onMessage = function (nextOrObserver, optError, optCompleted) {\n    throw this.errorFactory_.create(Errors.codes.AVAILABLE_IN_WINDOW);\n  };\n  /**\n   * @export\n   * @param {!firebase.Observer|function()} nextOrObserver An observer object\n   * or a function triggered on token refresh.\n   * @param {function(!Error)=} optError Optional A function\n   * triggered on token refresh error.\n   * @param {function()=} optCompleted Optional function triggered when the\n   * observer is removed.\n   * @return {!function()} The unsubscribe function for the observer.\n   */\n\n\n  ControllerInterface.prototype.onTokenRefresh = function (nextOrObserver, optError, optCompleted) {\n    throw this.errorFactory_.create(Errors.codes.AVAILABLE_IN_WINDOW);\n  }; //\n  // The following methods are used by the service worker only.\n  //\n\n  /**\n   * @export\n   * @param {function(Object)} callback\n   */\n\n\n  ControllerInterface.prototype.setBackgroundMessageHandler = function (callback) {\n    throw this.errorFactory_.create(Errors.codes.AVAILABLE_IN_SW);\n  }; //\n  // The following methods are used by the service themselves and not exposed\n  // publicly or not expected to be used by developers.\n  //\n\n  /**\n   * This method is required to adhere to the Firebase interface.\n   * It closes any currently open indexdb database connections.\n   */\n\n\n  ControllerInterface.prototype.delete = function () {\n    return Promise.all([this.tokenDetailsModel_.closeDatabase(), this.vapidDetailsModel_.closeDatabase()]);\n  };\n  /**\n   * Returns the current Notification Permission state.\n   * @private\n   * @return {string} The currenct permission state.\n   */\n\n\n  ControllerInterface.prototype.getNotificationPermission_ = function () {\n    return Notification.permission;\n  };\n\n  ControllerInterface.prototype.getTokenDetailsModel = function () {\n    return this.tokenDetailsModel_;\n  };\n\n  ControllerInterface.prototype.getVapidDetailsModel = function () {\n    return this.vapidDetailsModel_;\n  };\n  /**\n   * @protected\n   * @returns {IIDModel}\n   */\n\n\n  ControllerInterface.prototype.getIIDModel = function () {\n    return this.iidModel_;\n  };\n\n  return ControllerInterface;\n}();\n\nexport default ControllerInterface;","map":{"version":3,"sources":["../src/controllers/controller-interface.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\n\nimport { ErrorFactory } from '@firebase/util';\nimport Errors from '../models/errors';\nimport TokenDetailsModel from '../models/token-details-model';\nimport VapidDetailsModel from '../models/vapid-details-model';\nimport NOTIFICATION_PERMISSION from '../models/notification-permission';\nimport IIDModel from '../models/iid-model';\nimport arrayBufferToBase64 from '../helpers/array-buffer-to-base64';\n\nconst SENDER_ID_OPTION_NAME = 'messagingSenderId';\n// Database cache should be invalidated once a week.\nexport const TOKEN_EXPIRATION_MILLIS = 7 * 24 * 60 * 60 * 1000; // 7 days\n\nexport default class ControllerInterface {\n  public app;\n  public INTERNAL;\n  protected errorFactory_;\n  private messagingSenderId_: string;\n  private tokenDetailsModel_: TokenDetailsModel;\n  private vapidDetailsModel_: VapidDetailsModel;\n  private iidModel_: IIDModel;\n\n  /**\n   * An interface of the Messaging Service API\n   * @param {!firebase.app.App} app\n   */\n  constructor(app) {\n    this.errorFactory_ = new ErrorFactory('messaging', 'Messaging', Errors.map);\n\n    if (\n      !app.options[SENDER_ID_OPTION_NAME] ||\n      typeof app.options[SENDER_ID_OPTION_NAME] !== 'string'\n    ) {\n      throw this.errorFactory_.create(Errors.codes.BAD_SENDER_ID);\n    }\n\n    this.messagingSenderId_ = app.options[SENDER_ID_OPTION_NAME];\n\n    this.tokenDetailsModel_ = new TokenDetailsModel();\n    this.vapidDetailsModel_ = new VapidDetailsModel();\n    this.iidModel_ = new IIDModel();\n\n    this.app = app;\n    this.INTERNAL = {};\n    this.INTERNAL.delete = () => this.delete();\n  }\n\n  /**\n   * @export\n   */\n  async getToken(): Promise<string | null> {\n    // Check with permissions\n    const currentPermission = this.getNotificationPermission_();\n    if (currentPermission !== NOTIFICATION_PERMISSION.granted) {\n      if (currentPermission === NOTIFICATION_PERMISSION.denied) {\n        return Promise.reject(\n          this.errorFactory_.create(Errors.codes.NOTIFICATIONS_BLOCKED)\n        );\n      }\n\n      // We must wait for permission to be granted\n      return Promise.resolve(null);\n    }\n\n    const swReg = await this.getSWRegistration_();\n    const publicVapidKey = await this.getPublicVapidKey_();\n    const pushSubscription = await this.getPushSubscription(\n      swReg,\n      publicVapidKey\n    );\n    const tokenDetails = await this.tokenDetailsModel_.getTokenDetailsFromSWScope(\n      swReg.scope\n    );\n\n    if (tokenDetails) {\n      return this.manageExistingToken(\n        swReg,\n        pushSubscription,\n        publicVapidKey,\n        tokenDetails\n      );\n    }\n    return this.getNewToken(swReg, pushSubscription, publicVapidKey);\n  }\n\n  /**\n   * manageExistingToken is triggered if there's an existing FCM token in the\n   * database and it can take 3 different actions:\n   * 1) Retrieve the existing FCM token from the database.\n   * 2) If VAPID details have changed: Delete the existing token and create a\n   * new one with the new VAPID key.\n   * 3) If the database cache is invalidated: Send a request to FCM to update\n   * the token, and to check if the token is still valid on FCM-side.\n   */\n  private async manageExistingToken(\n    swReg: ServiceWorkerRegistration,\n    pushSubscription: PushSubscription,\n    publicVapidKey: Uint8Array,\n    tokenDetails: Object\n  ): Promise<string> {\n    const isTokenValid = this.isTokenStillValid(\n      pushSubscription,\n      publicVapidKey,\n      tokenDetails\n    );\n    if (isTokenValid) {\n      const now = Date.now();\n      if (now < tokenDetails['createTime'] + TOKEN_EXPIRATION_MILLIS) {\n        return tokenDetails['fcmToken'];\n      } else {\n        return this.updateToken(\n          swReg,\n          pushSubscription,\n          publicVapidKey,\n          tokenDetails\n        );\n      }\n    }\n\n    // If the token is no longer valid (for example if the VAPID details\n    // have changed), delete the existing token, and create a new one.\n    await this.deleteToken(tokenDetails['fcmToken']);\n    return this.getNewToken(swReg, pushSubscription, publicVapidKey);\n  }\n\n  /*\n   * Checks if the tokenDetails match the details provided in the clients.\n   */\n  private isTokenStillValid(\n    pushSubscription: PushSubscription,\n    publicVapidKey: Uint8Array,\n    tokenDetails: Object\n  ): Boolean {\n    if (arrayBufferToBase64(publicVapidKey) !== tokenDetails['vapidKey']) {\n      return false;\n    }\n\n    // getKey() isn't defined in the PushSubscription externs file, hence\n    // subscription['getKey']('<key name>').\n    return (\n      pushSubscription.endpoint === tokenDetails['endpoint'] &&\n      arrayBufferToBase64(pushSubscription['getKey']('auth')) ===\n        tokenDetails['auth'] &&\n      arrayBufferToBase64(pushSubscription['getKey']('p256dh')) ===\n        tokenDetails['p256dh']\n    );\n  }\n\n  private async updateToken(\n    swReg: ServiceWorkerRegistration,\n    pushSubscription: PushSubscription,\n    publicVapidKey: Uint8Array,\n    tokenDetails: Object\n  ): Promise<string> {\n    try {\n      const updatedToken = await this.iidModel_.updateToken(\n        this.messagingSenderId_,\n        tokenDetails['fcmToken'],\n        tokenDetails['fcmPushSet'],\n        pushSubscription,\n        publicVapidKey\n      );\n\n      const allDetails = {\n        swScope: swReg.scope,\n        vapidKey: publicVapidKey,\n        subscription: pushSubscription,\n        fcmSenderId: this.messagingSenderId_,\n        fcmToken: updatedToken,\n        fcmPushSet: tokenDetails['fcmPushSet']\n      };\n\n      await this.tokenDetailsModel_.saveTokenDetails(allDetails);\n      await this.vapidDetailsModel_.saveVapidDetails(\n        swReg.scope,\n        publicVapidKey\n      );\n      return updatedToken;\n    } catch (e) {\n      await this.deleteToken(tokenDetails['fcmToken']);\n      throw e;\n    }\n  }\n\n  private async getNewToken(\n    swReg: ServiceWorkerRegistration,\n    pushSubscription: PushSubscription,\n    publicVapidKey: Uint8Array\n  ): Promise<string> {\n    const tokenDetails = await this.iidModel_.getToken(\n      this.messagingSenderId_,\n      pushSubscription,\n      publicVapidKey\n    );\n    const allDetails = {\n      swScope: swReg.scope,\n      vapidKey: publicVapidKey,\n      subscription: pushSubscription,\n      fcmSenderId: this.messagingSenderId_,\n      fcmToken: tokenDetails['token'],\n      fcmPushSet: tokenDetails['pushSet']\n    };\n    await this.tokenDetailsModel_.saveTokenDetails(allDetails);\n    await this.vapidDetailsModel_.saveVapidDetails(swReg.scope, publicVapidKey);\n    return tokenDetails['token'];\n  }\n\n  /**\n   * This method deletes tokens that the token manager looks after,\n   * unsubscribes the token from FCM  and then unregisters the push\n   * subscription if it exists. It returns a promise that indicates\n   * whether or not the unsubscribe request was processed successfully.\n   * @export\n   */\n  deleteToken(token: string): Promise<Boolean> {\n    return this.tokenDetailsModel_\n      .deleteToken(token)\n      .then(details => {\n        return this.iidModel_.deleteToken(\n          details['fcmSenderId'],\n          details['fcmToken'],\n          details['fcmPushSet']\n        );\n      })\n      .then(() => {\n        return this.getSWRegistration_()\n          .then(registration => {\n            if (registration) {\n              return registration.pushManager.getSubscription();\n            }\n          })\n          .then(subscription => {\n            if (subscription) {\n              return subscription.unsubscribe();\n            }\n          });\n      });\n  }\n\n  getSWRegistration_(): Promise<ServiceWorkerRegistration> {\n    throw this.errorFactory_.create(Errors.codes.SHOULD_BE_INHERITED);\n  }\n\n  getPublicVapidKey_(): Promise<Uint8Array> {\n    throw this.errorFactory_.create(Errors.codes.SHOULD_BE_INHERITED);\n  }\n\n  //\n  // The following methods should only be available in the window.\n  //\n\n  requestPermission() {\n    throw this.errorFactory_.create(Errors.codes.AVAILABLE_IN_WINDOW);\n  }\n\n  /**\n   * Gets a PushSubscription for the current user.\n   */\n  getPushSubscription(\n    swRegistration: ServiceWorkerRegistration,\n    publicVapidKey: Uint8Array\n  ): Promise<PushSubscription> {\n    return swRegistration.pushManager.getSubscription().then(subscription => {\n      if (subscription) {\n        return subscription;\n      }\n\n      return swRegistration.pushManager.subscribe({\n        userVisibleOnly: true,\n        applicationServerKey: publicVapidKey\n      });\n    });\n  }\n\n  /**\n   * @export\n   * @param {!ServiceWorkerRegistration} registration\n   */\n  useServiceWorker(registration) {\n    throw this.errorFactory_.create(Errors.codes.AVAILABLE_IN_WINDOW);\n  }\n\n  /**\n   * @export\n   * @param {!string} b64PublicKey\n   */\n  usePublicVapidKey(b64PublicKey) {\n    throw this.errorFactory_.create(Errors.codes.AVAILABLE_IN_WINDOW);\n  }\n\n  /**\n   * @export\n   * @param {!firebase.Observer|function(*)} nextOrObserver\n   * @param {function(!Error)=} optError\n   * @param {function()=} optCompleted\n   * @return {!function()}\n   */\n  onMessage(nextOrObserver, optError, optCompleted) {\n    throw this.errorFactory_.create(Errors.codes.AVAILABLE_IN_WINDOW);\n  }\n\n  /**\n   * @export\n   * @param {!firebase.Observer|function()} nextOrObserver An observer object\n   * or a function triggered on token refresh.\n   * @param {function(!Error)=} optError Optional A function\n   * triggered on token refresh error.\n   * @param {function()=} optCompleted Optional function triggered when the\n   * observer is removed.\n   * @return {!function()} The unsubscribe function for the observer.\n   */\n  onTokenRefresh(nextOrObserver, optError, optCompleted) {\n    throw this.errorFactory_.create(Errors.codes.AVAILABLE_IN_WINDOW);\n  }\n\n  //\n  // The following methods are used by the service worker only.\n  //\n\n  /**\n   * @export\n   * @param {function(Object)} callback\n   */\n  setBackgroundMessageHandler(callback) {\n    throw this.errorFactory_.create(Errors.codes.AVAILABLE_IN_SW);\n  }\n\n  //\n  // The following methods are used by the service themselves and not exposed\n  // publicly or not expected to be used by developers.\n  //\n\n  /**\n   * This method is required to adhere to the Firebase interface.\n   * It closes any currently open indexdb database connections.\n   */\n  delete() {\n    return Promise.all([\n      this.tokenDetailsModel_.closeDatabase(),\n      this.vapidDetailsModel_.closeDatabase()\n    ]);\n  }\n\n  /**\n   * Returns the current Notification Permission state.\n   * @private\n   * @return {string} The currenct permission state.\n   */\n  getNotificationPermission_() {\n    return (Notification as any).permission;\n  }\n\n  getTokenDetailsModel(): TokenDetailsModel {\n    return this.tokenDetailsModel_;\n  }\n\n  getVapidDetailsModel(): VapidDetailsModel {\n    return this.vapidDetailsModel_;\n  }\n\n  /**\n   * @protected\n   * @returns {IIDModel}\n   */\n  getIIDModel() {\n    return this.iidModel_;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}