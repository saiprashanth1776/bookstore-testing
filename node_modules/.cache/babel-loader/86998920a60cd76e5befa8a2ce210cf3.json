{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar util_1 = require(\"@firebase/util\");\n\nvar util_2 = require(\"@firebase/util\");\n\nvar Path_1 = require(\"./util/Path\");\n\nvar CompoundWrite_1 = require(\"./CompoundWrite\");\n\nvar PriorityIndex_1 = require(\"./snap/indexes/PriorityIndex\");\n\nvar ChildrenNode_1 = require(\"./snap/ChildrenNode\");\n/**\n * WriteTree tracks all pending user-initiated writes and has methods to calculate the result of merging them\n * with underlying server data (to create \"event cache\" data).  Pending writes are added with addOverwrite()\n * and addMerge(), and removed with removeWrite().\n *\n * @constructor\n */\n\n\nvar WriteTree =\n/** @class */\nfunction () {\n  function WriteTree() {\n    /**\n     * A tree tracking the result of applying all visible writes.  This does not include transactions with\n     * applyLocally=false or writes that are completely shadowed by other writes.\n     *\n     * @type {!CompoundWrite}\n     * @private\n     */\n    this.visibleWrites_ = CompoundWrite_1.CompoundWrite.Empty;\n    /**\n     * A list of all pending writes, regardless of visibility and shadowed-ness.  Used to calculate arbitrary\n     * sets of the changed data, such as hidden writes (from transactions) or changes with certain writes excluded (also\n     * used by transactions).\n     *\n     * @type {!Array.<!WriteRecord>}\n     * @private\n     */\n\n    this.allWrites_ = [];\n    this.lastWriteId_ = -1;\n  }\n  /**\n   * Create a new WriteTreeRef for the given path. For use with a new sync point at the given path.\n   *\n   * @param {!Path} path\n   * @return {!WriteTreeRef}\n   */\n\n\n  WriteTree.prototype.childWrites = function (path) {\n    return new WriteTreeRef(path, this);\n  };\n  /**\n   * Record a new overwrite from user code.\n   *\n   * @param {!Path} path\n   * @param {!Node} snap\n   * @param {!number} writeId\n   * @param {boolean=} visible This is set to false by some transactions. It should be excluded from event caches\n   */\n\n\n  WriteTree.prototype.addOverwrite = function (path, snap, writeId, visible) {\n    util_2.assert(writeId > this.lastWriteId_, 'Stacking an older write on top of newer ones');\n\n    if (visible === undefined) {\n      visible = true;\n    }\n\n    this.allWrites_.push({\n      path: path,\n      snap: snap,\n      writeId: writeId,\n      visible: visible\n    });\n\n    if (visible) {\n      this.visibleWrites_ = this.visibleWrites_.addWrite(path, snap);\n    }\n\n    this.lastWriteId_ = writeId;\n  };\n  /**\n   * Record a new merge from user code.\n   *\n   * @param {!Path} path\n   * @param {!Object.<string, !Node>} changedChildren\n   * @param {!number} writeId\n   */\n\n\n  WriteTree.prototype.addMerge = function (path, changedChildren, writeId) {\n    util_2.assert(writeId > this.lastWriteId_, 'Stacking an older merge on top of newer ones');\n    this.allWrites_.push({\n      path: path,\n      children: changedChildren,\n      writeId: writeId,\n      visible: true\n    });\n    this.visibleWrites_ = this.visibleWrites_.addWrites(path, changedChildren);\n    this.lastWriteId_ = writeId;\n  };\n  /**\n   * @param {!number} writeId\n   * @return {?WriteRecord}\n   */\n\n\n  WriteTree.prototype.getWrite = function (writeId) {\n    for (var i = 0; i < this.allWrites_.length; i++) {\n      var record = this.allWrites_[i];\n\n      if (record.writeId === writeId) {\n        return record;\n      }\n    }\n\n    return null;\n  };\n  /**\n   * Remove a write (either an overwrite or merge) that has been successfully acknowledge by the server. Recalculates\n   * the tree if necessary.  We return true if it may have been visible, meaning views need to reevaluate.\n   *\n   * @param {!number} writeId\n   * @return {boolean} true if the write may have been visible (meaning we'll need to reevaluate / raise\n   * events as a result).\n   */\n\n\n  WriteTree.prototype.removeWrite = function (writeId) {\n    // Note: disabling this check. It could be a transaction that preempted another transaction, and thus was applied\n    // out of order.\n    //const validClear = revert || this.allWrites_.length === 0 || writeId <= this.allWrites_[0].writeId;\n    //assert(validClear, \"Either we don't have this write, or it's the first one in the queue\");\n    var _this = this;\n\n    var idx = this.allWrites_.findIndex(function (s) {\n      return s.writeId === writeId;\n    });\n    util_2.assert(idx >= 0, 'removeWrite called with nonexistent writeId.');\n    var writeToRemove = this.allWrites_[idx];\n    this.allWrites_.splice(idx, 1);\n    var removedWriteWasVisible = writeToRemove.visible;\n    var removedWriteOverlapsWithOtherWrites = false;\n    var i = this.allWrites_.length - 1;\n\n    while (removedWriteWasVisible && i >= 0) {\n      var currentWrite = this.allWrites_[i];\n\n      if (currentWrite.visible) {\n        if (i >= idx && this.recordContainsPath_(currentWrite, writeToRemove.path)) {\n          // The removed write was completely shadowed by a subsequent write.\n          removedWriteWasVisible = false;\n        } else if (writeToRemove.path.contains(currentWrite.path)) {\n          // Either we're covering some writes or they're covering part of us (depending on which came first).\n          removedWriteOverlapsWithOtherWrites = true;\n        }\n      }\n\n      i--;\n    }\n\n    if (!removedWriteWasVisible) {\n      return false;\n    } else if (removedWriteOverlapsWithOtherWrites) {\n      // There's some shadowing going on. Just rebuild the visible writes from scratch.\n      this.resetTree_();\n      return true;\n    } else {\n      // There's no shadowing.  We can safely just remove the write(s) from visibleWrites.\n      if (writeToRemove.snap) {\n        this.visibleWrites_ = this.visibleWrites_.removeWrite(writeToRemove.path);\n      } else {\n        var children = writeToRemove.children;\n        util_1.forEach(children, function (childName) {\n          _this.visibleWrites_ = _this.visibleWrites_.removeWrite(writeToRemove.path.child(childName));\n        });\n      }\n\n      return true;\n    }\n  };\n  /**\n   * Return a complete snapshot for the given path if there's visible write data at that path, else null.\n   * No server data is considered.\n   *\n   * @param {!Path} path\n   * @return {?Node}\n   */\n\n\n  WriteTree.prototype.getCompleteWriteData = function (path) {\n    return this.visibleWrites_.getCompleteNode(path);\n  };\n  /**\n   * Given optional, underlying server data, and an optional set of constraints (exclude some sets, include hidden\n   * writes), attempt to calculate a complete snapshot for the given path\n   *\n   * @param {!Path} treePath\n   * @param {?Node} completeServerCache\n   * @param {Array.<number>=} writeIdsToExclude An optional set to be excluded\n   * @param {boolean=} includeHiddenWrites Defaults to false, whether or not to layer on writes with visible set to false\n   * @return {?Node}\n   */\n\n\n  WriteTree.prototype.calcCompleteEventCache = function (treePath, completeServerCache, writeIdsToExclude, includeHiddenWrites) {\n    if (!writeIdsToExclude && !includeHiddenWrites) {\n      var shadowingNode = this.visibleWrites_.getCompleteNode(treePath);\n\n      if (shadowingNode != null) {\n        return shadowingNode;\n      } else {\n        var subMerge = this.visibleWrites_.childCompoundWrite(treePath);\n\n        if (subMerge.isEmpty()) {\n          return completeServerCache;\n        } else if (completeServerCache == null && !subMerge.hasCompleteWrite(Path_1.Path.Empty)) {\n          // We wouldn't have a complete snapshot, since there's no underlying data and no complete shadow\n          return null;\n        } else {\n          var layeredCache = completeServerCache || ChildrenNode_1.ChildrenNode.EMPTY_NODE;\n          return subMerge.apply(layeredCache);\n        }\n      }\n    } else {\n      var merge = this.visibleWrites_.childCompoundWrite(treePath);\n\n      if (!includeHiddenWrites && merge.isEmpty()) {\n        return completeServerCache;\n      } else {\n        // If the server cache is null, and we don't have a complete cache, we need to return null\n        if (!includeHiddenWrites && completeServerCache == null && !merge.hasCompleteWrite(Path_1.Path.Empty)) {\n          return null;\n        } else {\n          var filter = function (write) {\n            return (write.visible || includeHiddenWrites) && (!writeIdsToExclude || !~writeIdsToExclude.indexOf(write.writeId)) && (write.path.contains(treePath) || treePath.contains(write.path));\n          };\n\n          var mergeAtPath = WriteTree.layerTree_(this.allWrites_, filter, treePath);\n          var layeredCache = completeServerCache || ChildrenNode_1.ChildrenNode.EMPTY_NODE;\n          return mergeAtPath.apply(layeredCache);\n        }\n      }\n    }\n  };\n  /**\n   * With optional, underlying server data, attempt to return a children node of children that we have complete data for.\n   * Used when creating new views, to pre-fill their complete event children snapshot.\n   *\n   * @param {!Path} treePath\n   * @param {?ChildrenNode} completeServerChildren\n   * @return {!ChildrenNode}\n   */\n\n\n  WriteTree.prototype.calcCompleteEventChildren = function (treePath, completeServerChildren) {\n    var completeChildren = ChildrenNode_1.ChildrenNode.EMPTY_NODE;\n    var topLevelSet = this.visibleWrites_.getCompleteNode(treePath);\n\n    if (topLevelSet) {\n      if (!topLevelSet.isLeafNode()) {\n        // we're shadowing everything. Return the children.\n        topLevelSet.forEachChild(PriorityIndex_1.PRIORITY_INDEX, function (childName, childSnap) {\n          completeChildren = completeChildren.updateImmediateChild(childName, childSnap);\n        });\n      }\n\n      return completeChildren;\n    } else if (completeServerChildren) {\n      // Layer any children we have on top of this\n      // We know we don't have a top-level set, so just enumerate existing children\n      var merge_1 = this.visibleWrites_.childCompoundWrite(treePath);\n      completeServerChildren.forEachChild(PriorityIndex_1.PRIORITY_INDEX, function (childName, childNode) {\n        var node = merge_1.childCompoundWrite(new Path_1.Path(childName)).apply(childNode);\n        completeChildren = completeChildren.updateImmediateChild(childName, node);\n      }); // Add any complete children we have from the set\n\n      merge_1.getCompleteChildren().forEach(function (namedNode) {\n        completeChildren = completeChildren.updateImmediateChild(namedNode.name, namedNode.node);\n      });\n      return completeChildren;\n    } else {\n      // We don't have anything to layer on top of. Layer on any children we have\n      // Note that we can return an empty snap if we have a defined delete\n      var merge = this.visibleWrites_.childCompoundWrite(treePath);\n      merge.getCompleteChildren().forEach(function (namedNode) {\n        completeChildren = completeChildren.updateImmediateChild(namedNode.name, namedNode.node);\n      });\n      return completeChildren;\n    }\n  };\n  /**\n   * Given that the underlying server data has updated, determine what, if anything, needs to be\n   * applied to the event cache.\n   *\n   * Possibilities:\n   *\n   * 1. No writes are shadowing. Events should be raised, the snap to be applied comes from the server data\n   *\n   * 2. Some write is completely shadowing. No events to be raised\n   *\n   * 3. Is partially shadowed. Events\n   *\n   * Either existingEventSnap or existingServerSnap must exist\n   *\n   * @param {!Path} treePath\n   * @param {!Path} childPath\n   * @param {?Node} existingEventSnap\n   * @param {?Node} existingServerSnap\n   * @return {?Node}\n   */\n\n\n  WriteTree.prototype.calcEventCacheAfterServerOverwrite = function (treePath, childPath, existingEventSnap, existingServerSnap) {\n    util_2.assert(existingEventSnap || existingServerSnap, 'Either existingEventSnap or existingServerSnap must exist');\n    var path = treePath.child(childPath);\n\n    if (this.visibleWrites_.hasCompleteWrite(path)) {\n      // At this point we can probably guarantee that we're in case 2, meaning no events\n      // May need to check visibility while doing the findRootMostValueAndPath call\n      return null;\n    } else {\n      // No complete shadowing. We're either partially shadowing or not shadowing at all.\n      var childMerge = this.visibleWrites_.childCompoundWrite(path);\n\n      if (childMerge.isEmpty()) {\n        // We're not shadowing at all. Case 1\n        return existingServerSnap.getChild(childPath);\n      } else {\n        // This could be more efficient if the serverNode + updates doesn't change the eventSnap\n        // However this is tricky to find out, since user updates don't necessary change the server\n        // snap, e.g. priority updates on empty nodes, or deep deletes. Another special case is if the server\n        // adds nodes, but doesn't change any existing writes. It is therefore not enough to\n        // only check if the updates change the serverNode.\n        // Maybe check if the merge tree contains these special cases and only do a full overwrite in that case?\n        return childMerge.apply(existingServerSnap.getChild(childPath));\n      }\n    }\n  };\n  /**\n   * Returns a complete child for a given server snap after applying all user writes or null if there is no\n   * complete child for this ChildKey.\n   *\n   * @param {!Path} treePath\n   * @param {!string} childKey\n   * @param {!CacheNode} existingServerSnap\n   * @return {?Node}\n   */\n\n\n  WriteTree.prototype.calcCompleteChild = function (treePath, childKey, existingServerSnap) {\n    var path = treePath.child(childKey);\n    var shadowingNode = this.visibleWrites_.getCompleteNode(path);\n\n    if (shadowingNode != null) {\n      return shadowingNode;\n    } else {\n      if (existingServerSnap.isCompleteForChild(childKey)) {\n        var childMerge = this.visibleWrites_.childCompoundWrite(path);\n        return childMerge.apply(existingServerSnap.getNode().getImmediateChild(childKey));\n      } else {\n        return null;\n      }\n    }\n  };\n  /**\n   * Returns a node if there is a complete overwrite for this path. More specifically, if there is a write at\n   * a higher path, this will return the child of that write relative to the write and this path.\n   * Returns null if there is no write at this path.\n   *\n   * @param {!Path} path\n   * @return {?Node}\n   */\n\n\n  WriteTree.prototype.shadowingWrite = function (path) {\n    return this.visibleWrites_.getCompleteNode(path);\n  };\n  /**\n   * This method is used when processing child remove events on a query. If we can, we pull in children that were outside\n   * the window, but may now be in the window.\n   *\n   * @param {!Path} treePath\n   * @param {?Node} completeServerData\n   * @param {!NamedNode} startPost\n   * @param {!number} count\n   * @param {boolean} reverse\n   * @param {!Index} index\n   * @return {!Array.<!NamedNode>}\n   */\n\n\n  WriteTree.prototype.calcIndexedSlice = function (treePath, completeServerData, startPost, count, reverse, index) {\n    var toIterate;\n    var merge = this.visibleWrites_.childCompoundWrite(treePath);\n    var shadowingNode = merge.getCompleteNode(Path_1.Path.Empty);\n\n    if (shadowingNode != null) {\n      toIterate = shadowingNode;\n    } else if (completeServerData != null) {\n      toIterate = merge.apply(completeServerData);\n    } else {\n      // no children to iterate on\n      return [];\n    }\n\n    toIterate = toIterate.withIndex(index);\n\n    if (!toIterate.isEmpty() && !toIterate.isLeafNode()) {\n      var nodes = [];\n      var cmp = index.getCompare();\n      var iter = reverse ? toIterate.getReverseIteratorFrom(startPost, index) : toIterate.getIteratorFrom(startPost, index);\n      var next = iter.getNext();\n\n      while (next && nodes.length < count) {\n        if (cmp(next, startPost) !== 0) {\n          nodes.push(next);\n        }\n\n        next = iter.getNext();\n      }\n\n      return nodes;\n    } else {\n      return [];\n    }\n  };\n  /**\n   * @param {!WriteRecord} writeRecord\n   * @param {!Path} path\n   * @return {boolean}\n   * @private\n   */\n\n\n  WriteTree.prototype.recordContainsPath_ = function (writeRecord, path) {\n    if (writeRecord.snap) {\n      return writeRecord.path.contains(path);\n    } else {\n      // findKey can return undefined, so use !! to coerce to boolean\n      return !!util_1.findKey(writeRecord.children, function (childSnap, childName) {\n        return writeRecord.path.child(childName).contains(path);\n      });\n    }\n  };\n  /**\n   * Re-layer the writes and merges into a tree so we can efficiently calculate event snapshots\n   * @private\n   */\n\n\n  WriteTree.prototype.resetTree_ = function () {\n    this.visibleWrites_ = WriteTree.layerTree_(this.allWrites_, WriteTree.DefaultFilter_, Path_1.Path.Empty);\n\n    if (this.allWrites_.length > 0) {\n      this.lastWriteId_ = this.allWrites_[this.allWrites_.length - 1].writeId;\n    } else {\n      this.lastWriteId_ = -1;\n    }\n  };\n  /**\n   * The default filter used when constructing the tree. Keep everything that's visible.\n   *\n   * @param {!WriteRecord} write\n   * @return {boolean}\n   * @private\n   */\n\n\n  WriteTree.DefaultFilter_ = function (write) {\n    return write.visible;\n  };\n  /**\n   * Static method. Given an array of WriteRecords, a filter for which ones to include, and a path, construct the tree of\n   * event data at that path.\n   *\n   * @param {!Array.<!WriteRecord>} writes\n   * @param {!function(!WriteRecord):boolean} filter\n   * @param {!Path} treeRoot\n   * @return {!CompoundWrite}\n   * @private\n   */\n\n\n  WriteTree.layerTree_ = function (writes, filter, treeRoot) {\n    var compoundWrite = CompoundWrite_1.CompoundWrite.Empty;\n\n    for (var i = 0; i < writes.length; ++i) {\n      var write = writes[i]; // Theory, a later set will either:\n      // a) abort a relevant transaction, so no need to worry about excluding it from calculating that transaction\n      // b) not be relevant to a transaction (separate branch), so again will not affect the data for that transaction\n\n      if (filter(write)) {\n        var writePath = write.path;\n        var relativePath = void 0;\n\n        if (write.snap) {\n          if (treeRoot.contains(writePath)) {\n            relativePath = Path_1.Path.relativePath(treeRoot, writePath);\n            compoundWrite = compoundWrite.addWrite(relativePath, write.snap);\n          } else if (writePath.contains(treeRoot)) {\n            relativePath = Path_1.Path.relativePath(writePath, treeRoot);\n            compoundWrite = compoundWrite.addWrite(Path_1.Path.Empty, write.snap.getChild(relativePath));\n          } else {// There is no overlap between root path and write path, ignore write\n          }\n        } else if (write.children) {\n          if (treeRoot.contains(writePath)) {\n            relativePath = Path_1.Path.relativePath(treeRoot, writePath);\n            compoundWrite = compoundWrite.addWrites(relativePath, write.children);\n          } else if (writePath.contains(treeRoot)) {\n            relativePath = Path_1.Path.relativePath(writePath, treeRoot);\n\n            if (relativePath.isEmpty()) {\n              compoundWrite = compoundWrite.addWrites(Path_1.Path.Empty, write.children);\n            } else {\n              var child = util_1.safeGet(write.children, relativePath.getFront());\n\n              if (child) {\n                // There exists a child in this node that matches the root path\n                var deepNode = child.getChild(relativePath.popFront());\n                compoundWrite = compoundWrite.addWrite(Path_1.Path.Empty, deepNode);\n              }\n            }\n          } else {// There is no overlap between root path and write path, ignore write\n          }\n        } else {\n          throw util_2.assertionError('WriteRecord should have .snap or .children');\n        }\n      }\n    }\n\n    return compoundWrite;\n  };\n\n  return WriteTree;\n}();\n\nexports.WriteTree = WriteTree;\n/**\n * A WriteTreeRef wraps a WriteTree and a path, for convenient access to a particular subtree.  All of the methods\n * just proxy to the underlying WriteTree.\n *\n * @constructor\n */\n\nvar WriteTreeRef =\n/** @class */\nfunction () {\n  /**\n   * @param {!Path} path\n   * @param {!WriteTree} writeTree\n   */\n  function WriteTreeRef(path, writeTree) {\n    this.treePath_ = path;\n    this.writeTree_ = writeTree;\n  }\n  /**\n   * If possible, returns a complete event cache, using the underlying server data if possible. In addition, can be used\n   * to get a cache that includes hidden writes, and excludes arbitrary writes. Note that customizing the returned node\n   * can lead to a more expensive calculation.\n   *\n   * @param {?Node} completeServerCache\n   * @param {Array.<number>=} writeIdsToExclude Optional writes to exclude.\n   * @param {boolean=} includeHiddenWrites Defaults to false, whether or not to layer on writes with visible set to false\n   * @return {?Node}\n   */\n\n\n  WriteTreeRef.prototype.calcCompleteEventCache = function (completeServerCache, writeIdsToExclude, includeHiddenWrites) {\n    return this.writeTree_.calcCompleteEventCache(this.treePath_, completeServerCache, writeIdsToExclude, includeHiddenWrites);\n  };\n  /**\n   * If possible, returns a children node containing all of the complete children we have data for. The returned data is a\n   * mix of the given server data and write data.\n   *\n   * @param {?ChildrenNode} completeServerChildren\n   * @return {!ChildrenNode}\n   */\n\n\n  WriteTreeRef.prototype.calcCompleteEventChildren = function (completeServerChildren) {\n    return this.writeTree_.calcCompleteEventChildren(this.treePath_, completeServerChildren);\n  };\n  /**\n   * Given that either the underlying server data has updated or the outstanding writes have updated, determine what,\n   * if anything, needs to be applied to the event cache.\n   *\n   * Possibilities:\n   *\n   * 1. No writes are shadowing. Events should be raised, the snap to be applied comes from the server data\n   *\n   * 2. Some write is completely shadowing. No events to be raised\n   *\n   * 3. Is partially shadowed. Events should be raised\n   *\n   * Either existingEventSnap or existingServerSnap must exist, this is validated via an assert\n   *\n   * @param {!Path} path\n   * @param {?Node} existingEventSnap\n   * @param {?Node} existingServerSnap\n   * @return {?Node}\n   */\n\n\n  WriteTreeRef.prototype.calcEventCacheAfterServerOverwrite = function (path, existingEventSnap, existingServerSnap) {\n    return this.writeTree_.calcEventCacheAfterServerOverwrite(this.treePath_, path, existingEventSnap, existingServerSnap);\n  };\n  /**\n   * Returns a node if there is a complete overwrite for this path. More specifically, if there is a write at\n   * a higher path, this will return the child of that write relative to the write and this path.\n   * Returns null if there is no write at this path.\n   *\n   * @param {!Path} path\n   * @return {?Node}\n   */\n\n\n  WriteTreeRef.prototype.shadowingWrite = function (path) {\n    return this.writeTree_.shadowingWrite(this.treePath_.child(path));\n  };\n  /**\n   * This method is used when processing child remove events on a query. If we can, we pull in children that were outside\n   * the window, but may now be in the window\n   *\n   * @param {?Node} completeServerData\n   * @param {!NamedNode} startPost\n   * @param {!number} count\n   * @param {boolean} reverse\n   * @param {!Index} index\n   * @return {!Array.<!NamedNode>}\n   */\n\n\n  WriteTreeRef.prototype.calcIndexedSlice = function (completeServerData, startPost, count, reverse, index) {\n    return this.writeTree_.calcIndexedSlice(this.treePath_, completeServerData, startPost, count, reverse, index);\n  };\n  /**\n   * Returns a complete child for a given server snap after applying all user writes or null if there is no\n   * complete child for this ChildKey.\n   *\n   * @param {!string} childKey\n   * @param {!CacheNode} existingServerCache\n   * @return {?Node}\n   */\n\n\n  WriteTreeRef.prototype.calcCompleteChild = function (childKey, existingServerCache) {\n    return this.writeTree_.calcCompleteChild(this.treePath_, childKey, existingServerCache);\n  };\n  /**\n   * Return a WriteTreeRef for a child.\n   *\n   * @param {string} childName\n   * @return {!WriteTreeRef}\n   */\n\n\n  WriteTreeRef.prototype.child = function (childName) {\n    return new WriteTreeRef(this.treePath_.child(childName), this.writeTree_);\n  };\n\n  return WriteTreeRef;\n}();\n\nexports.WriteTreeRef = WriteTreeRef;","map":{"version":3,"sources":["../src/core/WriteTree.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { findKey, forEach, safeGet } from '@firebase/util';\nimport { assert, assertionError } from '@firebase/util';\nimport { Path } from './util/Path';\nimport { CompoundWrite } from './CompoundWrite';\nimport { PRIORITY_INDEX } from './snap/indexes/PriorityIndex';\nimport { ChildrenNode } from './snap/ChildrenNode';\nimport { NamedNode, Node } from './snap/Node';\nimport { CacheNode } from './view/CacheNode';\nimport { Index } from './snap/indexes/Index';\n\n/**\n * Defines a single user-initiated write operation. May be the result of a set(), transaction(), or update() call. In\n * the case of a set() or transaction, snap wil be non-null.  In the case of an update(), children will be non-null.\n */\nexport interface WriteRecord {\n  writeId: number;\n  path: Path;\n  snap?: Node | null;\n  children?: { [k: string]: Node } | null;\n  visible: boolean;\n}\n\n/**\n * WriteTree tracks all pending user-initiated writes and has methods to calculate the result of merging them\n * with underlying server data (to create \"event cache\" data).  Pending writes are added with addOverwrite()\n * and addMerge(), and removed with removeWrite().\n *\n * @constructor\n */\nexport class WriteTree {\n  /**\n   * A tree tracking the result of applying all visible writes.  This does not include transactions with\n   * applyLocally=false or writes that are completely shadowed by other writes.\n   *\n   * @type {!CompoundWrite}\n   * @private\n   */\n  private visibleWrites_: CompoundWrite = CompoundWrite.Empty;\n\n  /**\n   * A list of all pending writes, regardless of visibility and shadowed-ness.  Used to calculate arbitrary\n   * sets of the changed data, such as hidden writes (from transactions) or changes with certain writes excluded (also\n   * used by transactions).\n   *\n   * @type {!Array.<!WriteRecord>}\n   * @private\n   */\n  private allWrites_: WriteRecord[] = [];\n\n  private lastWriteId_ = -1;\n\n  /**\n   * Create a new WriteTreeRef for the given path. For use with a new sync point at the given path.\n   *\n   * @param {!Path} path\n   * @return {!WriteTreeRef}\n   */\n  childWrites(path: Path): WriteTreeRef {\n    return new WriteTreeRef(path, this);\n  }\n\n  /**\n   * Record a new overwrite from user code.\n   *\n   * @param {!Path} path\n   * @param {!Node} snap\n   * @param {!number} writeId\n   * @param {boolean=} visible This is set to false by some transactions. It should be excluded from event caches\n   */\n  addOverwrite(path: Path, snap: Node, writeId: number, visible?: boolean) {\n    assert(\n      writeId > this.lastWriteId_,\n      'Stacking an older write on top of newer ones'\n    );\n    if (visible === undefined) {\n      visible = true;\n    }\n    this.allWrites_.push({\n      path: path,\n      snap: snap,\n      writeId: writeId,\n      visible: visible\n    });\n\n    if (visible) {\n      this.visibleWrites_ = this.visibleWrites_.addWrite(path, snap);\n    }\n    this.lastWriteId_ = writeId;\n  }\n\n  /**\n   * Record a new merge from user code.\n   *\n   * @param {!Path} path\n   * @param {!Object.<string, !Node>} changedChildren\n   * @param {!number} writeId\n   */\n  addMerge(\n    path: Path,\n    changedChildren: { [k: string]: Node },\n    writeId: number\n  ) {\n    assert(\n      writeId > this.lastWriteId_,\n      'Stacking an older merge on top of newer ones'\n    );\n    this.allWrites_.push({\n      path: path,\n      children: changedChildren,\n      writeId: writeId,\n      visible: true\n    });\n\n    this.visibleWrites_ = this.visibleWrites_.addWrites(path, changedChildren);\n    this.lastWriteId_ = writeId;\n  }\n\n  /**\n   * @param {!number} writeId\n   * @return {?WriteRecord}\n   */\n  getWrite(writeId: number): WriteRecord | null {\n    for (let i = 0; i < this.allWrites_.length; i++) {\n      const record = this.allWrites_[i];\n      if (record.writeId === writeId) {\n        return record;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Remove a write (either an overwrite or merge) that has been successfully acknowledge by the server. Recalculates\n   * the tree if necessary.  We return true if it may have been visible, meaning views need to reevaluate.\n   *\n   * @param {!number} writeId\n   * @return {boolean} true if the write may have been visible (meaning we'll need to reevaluate / raise\n   * events as a result).\n   */\n  removeWrite(writeId: number): boolean {\n    // Note: disabling this check. It could be a transaction that preempted another transaction, and thus was applied\n    // out of order.\n    //const validClear = revert || this.allWrites_.length === 0 || writeId <= this.allWrites_[0].writeId;\n    //assert(validClear, \"Either we don't have this write, or it's the first one in the queue\");\n\n    const idx = this.allWrites_.findIndex(function(s) {\n      return s.writeId === writeId;\n    });\n    assert(idx >= 0, 'removeWrite called with nonexistent writeId.');\n    const writeToRemove = this.allWrites_[idx];\n    this.allWrites_.splice(idx, 1);\n\n    let removedWriteWasVisible = writeToRemove.visible;\n    let removedWriteOverlapsWithOtherWrites = false;\n\n    let i = this.allWrites_.length - 1;\n\n    while (removedWriteWasVisible && i >= 0) {\n      const currentWrite = this.allWrites_[i];\n      if (currentWrite.visible) {\n        if (\n          i >= idx &&\n          this.recordContainsPath_(currentWrite, writeToRemove.path)\n        ) {\n          // The removed write was completely shadowed by a subsequent write.\n          removedWriteWasVisible = false;\n        } else if (writeToRemove.path.contains(currentWrite.path)) {\n          // Either we're covering some writes or they're covering part of us (depending on which came first).\n          removedWriteOverlapsWithOtherWrites = true;\n        }\n      }\n      i--;\n    }\n\n    if (!removedWriteWasVisible) {\n      return false;\n    } else if (removedWriteOverlapsWithOtherWrites) {\n      // There's some shadowing going on. Just rebuild the visible writes from scratch.\n      this.resetTree_();\n      return true;\n    } else {\n      // There's no shadowing.  We can safely just remove the write(s) from visibleWrites.\n      if (writeToRemove.snap) {\n        this.visibleWrites_ = this.visibleWrites_.removeWrite(\n          writeToRemove.path\n        );\n      } else {\n        const children = writeToRemove.children;\n        forEach(children, (childName: string) => {\n          this.visibleWrites_ = this.visibleWrites_.removeWrite(\n            writeToRemove.path.child(childName)\n          );\n        });\n      }\n      return true;\n    }\n  }\n\n  /**\n   * Return a complete snapshot for the given path if there's visible write data at that path, else null.\n   * No server data is considered.\n   *\n   * @param {!Path} path\n   * @return {?Node}\n   */\n  getCompleteWriteData(path: Path): Node | null {\n    return this.visibleWrites_.getCompleteNode(path);\n  }\n\n  /**\n   * Given optional, underlying server data, and an optional set of constraints (exclude some sets, include hidden\n   * writes), attempt to calculate a complete snapshot for the given path\n   *\n   * @param {!Path} treePath\n   * @param {?Node} completeServerCache\n   * @param {Array.<number>=} writeIdsToExclude An optional set to be excluded\n   * @param {boolean=} includeHiddenWrites Defaults to false, whether or not to layer on writes with visible set to false\n   * @return {?Node}\n   */\n  calcCompleteEventCache(\n    treePath: Path,\n    completeServerCache: Node | null,\n    writeIdsToExclude?: number[],\n    includeHiddenWrites?: boolean\n  ): Node | null {\n    if (!writeIdsToExclude && !includeHiddenWrites) {\n      const shadowingNode = this.visibleWrites_.getCompleteNode(treePath);\n      if (shadowingNode != null) {\n        return shadowingNode;\n      } else {\n        const subMerge = this.visibleWrites_.childCompoundWrite(treePath);\n        if (subMerge.isEmpty()) {\n          return completeServerCache;\n        } else if (\n          completeServerCache == null &&\n          !subMerge.hasCompleteWrite(Path.Empty)\n        ) {\n          // We wouldn't have a complete snapshot, since there's no underlying data and no complete shadow\n          return null;\n        } else {\n          const layeredCache = completeServerCache || ChildrenNode.EMPTY_NODE;\n          return subMerge.apply(layeredCache);\n        }\n      }\n    } else {\n      const merge = this.visibleWrites_.childCompoundWrite(treePath);\n      if (!includeHiddenWrites && merge.isEmpty()) {\n        return completeServerCache;\n      } else {\n        // If the server cache is null, and we don't have a complete cache, we need to return null\n        if (\n          !includeHiddenWrites &&\n          completeServerCache == null &&\n          !merge.hasCompleteWrite(Path.Empty)\n        ) {\n          return null;\n        } else {\n          const filter = function(write: WriteRecord) {\n            return (\n              (write.visible || includeHiddenWrites) &&\n              (!writeIdsToExclude ||\n                !~writeIdsToExclude.indexOf(write.writeId)) &&\n              (write.path.contains(treePath) || treePath.contains(write.path))\n            );\n          };\n          const mergeAtPath = WriteTree.layerTree_(\n            this.allWrites_,\n            filter,\n            treePath\n          );\n          const layeredCache = completeServerCache || ChildrenNode.EMPTY_NODE;\n          return mergeAtPath.apply(layeredCache);\n        }\n      }\n    }\n  }\n\n  /**\n   * With optional, underlying server data, attempt to return a children node of children that we have complete data for.\n   * Used when creating new views, to pre-fill their complete event children snapshot.\n   *\n   * @param {!Path} treePath\n   * @param {?ChildrenNode} completeServerChildren\n   * @return {!ChildrenNode}\n   */\n  calcCompleteEventChildren(\n    treePath: Path,\n    completeServerChildren: ChildrenNode | null\n  ) {\n    let completeChildren = ChildrenNode.EMPTY_NODE as Node;\n    const topLevelSet = this.visibleWrites_.getCompleteNode(treePath);\n    if (topLevelSet) {\n      if (!topLevelSet.isLeafNode()) {\n        // we're shadowing everything. Return the children.\n        topLevelSet.forEachChild(PRIORITY_INDEX, function(\n          childName,\n          childSnap\n        ) {\n          completeChildren = completeChildren.updateImmediateChild(\n            childName,\n            childSnap\n          );\n        });\n      }\n      return completeChildren;\n    } else if (completeServerChildren) {\n      // Layer any children we have on top of this\n      // We know we don't have a top-level set, so just enumerate existing children\n      const merge = this.visibleWrites_.childCompoundWrite(treePath);\n      completeServerChildren.forEachChild(PRIORITY_INDEX, function(\n        childName,\n        childNode\n      ) {\n        const node = merge\n          .childCompoundWrite(new Path(childName))\n          .apply(childNode);\n        completeChildren = completeChildren.updateImmediateChild(\n          childName,\n          node\n        );\n      });\n      // Add any complete children we have from the set\n      merge.getCompleteChildren().forEach(function(namedNode) {\n        completeChildren = completeChildren.updateImmediateChild(\n          namedNode.name,\n          namedNode.node\n        );\n      });\n      return completeChildren;\n    } else {\n      // We don't have anything to layer on top of. Layer on any children we have\n      // Note that we can return an empty snap if we have a defined delete\n      const merge = this.visibleWrites_.childCompoundWrite(treePath);\n      merge.getCompleteChildren().forEach(function(namedNode) {\n        completeChildren = completeChildren.updateImmediateChild(\n          namedNode.name,\n          namedNode.node\n        );\n      });\n      return completeChildren;\n    }\n  }\n\n  /**\n   * Given that the underlying server data has updated, determine what, if anything, needs to be\n   * applied to the event cache.\n   *\n   * Possibilities:\n   *\n   * 1. No writes are shadowing. Events should be raised, the snap to be applied comes from the server data\n   *\n   * 2. Some write is completely shadowing. No events to be raised\n   *\n   * 3. Is partially shadowed. Events\n   *\n   * Either existingEventSnap or existingServerSnap must exist\n   *\n   * @param {!Path} treePath\n   * @param {!Path} childPath\n   * @param {?Node} existingEventSnap\n   * @param {?Node} existingServerSnap\n   * @return {?Node}\n   */\n  calcEventCacheAfterServerOverwrite(\n    treePath: Path,\n    childPath: Path,\n    existingEventSnap: Node | null,\n    existingServerSnap: Node | null\n  ): Node | null {\n    assert(\n      existingEventSnap || existingServerSnap,\n      'Either existingEventSnap or existingServerSnap must exist'\n    );\n    const path = treePath.child(childPath);\n    if (this.visibleWrites_.hasCompleteWrite(path)) {\n      // At this point we can probably guarantee that we're in case 2, meaning no events\n      // May need to check visibility while doing the findRootMostValueAndPath call\n      return null;\n    } else {\n      // No complete shadowing. We're either partially shadowing or not shadowing at all.\n      const childMerge = this.visibleWrites_.childCompoundWrite(path);\n      if (childMerge.isEmpty()) {\n        // We're not shadowing at all. Case 1\n        return existingServerSnap.getChild(childPath);\n      } else {\n        // This could be more efficient if the serverNode + updates doesn't change the eventSnap\n        // However this is tricky to find out, since user updates don't necessary change the server\n        // snap, e.g. priority updates on empty nodes, or deep deletes. Another special case is if the server\n        // adds nodes, but doesn't change any existing writes. It is therefore not enough to\n        // only check if the updates change the serverNode.\n        // Maybe check if the merge tree contains these special cases and only do a full overwrite in that case?\n        return childMerge.apply(existingServerSnap.getChild(childPath));\n      }\n    }\n  }\n\n  /**\n   * Returns a complete child for a given server snap after applying all user writes or null if there is no\n   * complete child for this ChildKey.\n   *\n   * @param {!Path} treePath\n   * @param {!string} childKey\n   * @param {!CacheNode} existingServerSnap\n   * @return {?Node}\n   */\n  calcCompleteChild(\n    treePath: Path,\n    childKey: string,\n    existingServerSnap: CacheNode\n  ): Node | null {\n    const path = treePath.child(childKey);\n    const shadowingNode = this.visibleWrites_.getCompleteNode(path);\n    if (shadowingNode != null) {\n      return shadowingNode;\n    } else {\n      if (existingServerSnap.isCompleteForChild(childKey)) {\n        const childMerge = this.visibleWrites_.childCompoundWrite(path);\n        return childMerge.apply(\n          existingServerSnap.getNode().getImmediateChild(childKey)\n        );\n      } else {\n        return null;\n      }\n    }\n  }\n\n  /**\n   * Returns a node if there is a complete overwrite for this path. More specifically, if there is a write at\n   * a higher path, this will return the child of that write relative to the write and this path.\n   * Returns null if there is no write at this path.\n   *\n   * @param {!Path} path\n   * @return {?Node}\n   */\n  shadowingWrite(path: Path): Node | null {\n    return this.visibleWrites_.getCompleteNode(path);\n  }\n\n  /**\n   * This method is used when processing child remove events on a query. If we can, we pull in children that were outside\n   * the window, but may now be in the window.\n   *\n   * @param {!Path} treePath\n   * @param {?Node} completeServerData\n   * @param {!NamedNode} startPost\n   * @param {!number} count\n   * @param {boolean} reverse\n   * @param {!Index} index\n   * @return {!Array.<!NamedNode>}\n   */\n  calcIndexedSlice(\n    treePath: Path,\n    completeServerData: Node | null,\n    startPost: NamedNode,\n    count: number,\n    reverse: boolean,\n    index: Index\n  ): NamedNode[] {\n    let toIterate: Node;\n    const merge = this.visibleWrites_.childCompoundWrite(treePath);\n    const shadowingNode = merge.getCompleteNode(Path.Empty);\n    if (shadowingNode != null) {\n      toIterate = shadowingNode;\n    } else if (completeServerData != null) {\n      toIterate = merge.apply(completeServerData);\n    } else {\n      // no children to iterate on\n      return [];\n    }\n    toIterate = toIterate.withIndex(index);\n    if (!toIterate.isEmpty() && !toIterate.isLeafNode()) {\n      const nodes = [];\n      const cmp = index.getCompare();\n      const iter = reverse\n        ? (toIterate as ChildrenNode).getReverseIteratorFrom(startPost, index)\n        : (toIterate as ChildrenNode).getIteratorFrom(startPost, index);\n      let next = iter.getNext();\n      while (next && nodes.length < count) {\n        if (cmp(next, startPost) !== 0) {\n          nodes.push(next);\n        }\n        next = iter.getNext();\n      }\n      return nodes;\n    } else {\n      return [];\n    }\n  }\n\n  /**\n   * @param {!WriteRecord} writeRecord\n   * @param {!Path} path\n   * @return {boolean}\n   * @private\n   */\n  private recordContainsPath_(writeRecord: WriteRecord, path: Path): boolean {\n    if (writeRecord.snap) {\n      return writeRecord.path.contains(path);\n    } else {\n      // findKey can return undefined, so use !! to coerce to boolean\n      return !!findKey(writeRecord.children, function(\n        childSnap: Node,\n        childName: string\n      ) {\n        return writeRecord.path.child(childName).contains(path);\n      });\n    }\n  }\n\n  /**\n   * Re-layer the writes and merges into a tree so we can efficiently calculate event snapshots\n   * @private\n   */\n  private resetTree_() {\n    this.visibleWrites_ = WriteTree.layerTree_(\n      this.allWrites_,\n      WriteTree.DefaultFilter_,\n      Path.Empty\n    );\n    if (this.allWrites_.length > 0) {\n      this.lastWriteId_ = this.allWrites_[this.allWrites_.length - 1].writeId;\n    } else {\n      this.lastWriteId_ = -1;\n    }\n  }\n\n  /**\n   * The default filter used when constructing the tree. Keep everything that's visible.\n   *\n   * @param {!WriteRecord} write\n   * @return {boolean}\n   * @private\n   */\n  private static DefaultFilter_(write: WriteRecord) {\n    return write.visible;\n  }\n\n  /**\n   * Static method. Given an array of WriteRecords, a filter for which ones to include, and a path, construct the tree of\n   * event data at that path.\n   *\n   * @param {!Array.<!WriteRecord>} writes\n   * @param {!function(!WriteRecord):boolean} filter\n   * @param {!Path} treeRoot\n   * @return {!CompoundWrite}\n   * @private\n   */\n  private static layerTree_(\n    writes: WriteRecord[],\n    filter: (w: WriteRecord) => boolean,\n    treeRoot: Path\n  ): CompoundWrite {\n    let compoundWrite = CompoundWrite.Empty;\n    for (let i = 0; i < writes.length; ++i) {\n      const write = writes[i];\n      // Theory, a later set will either:\n      // a) abort a relevant transaction, so no need to worry about excluding it from calculating that transaction\n      // b) not be relevant to a transaction (separate branch), so again will not affect the data for that transaction\n      if (filter(write)) {\n        const writePath = write.path;\n        let relativePath;\n        if (write.snap) {\n          if (treeRoot.contains(writePath)) {\n            relativePath = Path.relativePath(treeRoot, writePath);\n            compoundWrite = compoundWrite.addWrite(relativePath, write.snap);\n          } else if (writePath.contains(treeRoot)) {\n            relativePath = Path.relativePath(writePath, treeRoot);\n            compoundWrite = compoundWrite.addWrite(\n              Path.Empty,\n              write.snap.getChild(relativePath)\n            );\n          } else {\n            // There is no overlap between root path and write path, ignore write\n          }\n        } else if (write.children) {\n          if (treeRoot.contains(writePath)) {\n            relativePath = Path.relativePath(treeRoot, writePath);\n            compoundWrite = compoundWrite.addWrites(\n              relativePath,\n              write.children\n            );\n          } else if (writePath.contains(treeRoot)) {\n            relativePath = Path.relativePath(writePath, treeRoot);\n            if (relativePath.isEmpty()) {\n              compoundWrite = compoundWrite.addWrites(\n                Path.Empty,\n                write.children\n              );\n            } else {\n              const child = safeGet(write.children, relativePath.getFront());\n              if (child) {\n                // There exists a child in this node that matches the root path\n                const deepNode = child.getChild(relativePath.popFront());\n                compoundWrite = compoundWrite.addWrite(Path.Empty, deepNode);\n              }\n            }\n          } else {\n            // There is no overlap between root path and write path, ignore write\n          }\n        } else {\n          throw assertionError('WriteRecord should have .snap or .children');\n        }\n      }\n    }\n    return compoundWrite;\n  }\n}\n\n/**\n * A WriteTreeRef wraps a WriteTree and a path, for convenient access to a particular subtree.  All of the methods\n * just proxy to the underlying WriteTree.\n *\n * @constructor\n */\nexport class WriteTreeRef {\n  /**\n   * The path to this particular write tree ref. Used for calling methods on writeTree_ while exposing a simpler\n   * interface to callers.\n   *\n   * @type {!Path}\n   * @private\n   * @const\n   */\n  private readonly treePath_: Path;\n\n  /**\n   * * A reference to the actual tree of write data. All methods are pass-through to the tree, but with the appropriate\n   * path prefixed.\n   *\n   * This lets us make cheap references to points in the tree for sync points without having to copy and maintain all of\n   * the data.\n   *\n   * @type {!WriteTree}\n   * @private\n   * @const\n   */\n  private readonly writeTree_: WriteTree;\n\n  /**\n   * @param {!Path} path\n   * @param {!WriteTree} writeTree\n   */\n  constructor(path: Path, writeTree: WriteTree) {\n    this.treePath_ = path;\n    this.writeTree_ = writeTree;\n  }\n\n  /**\n   * If possible, returns a complete event cache, using the underlying server data if possible. In addition, can be used\n   * to get a cache that includes hidden writes, and excludes arbitrary writes. Note that customizing the returned node\n   * can lead to a more expensive calculation.\n   *\n   * @param {?Node} completeServerCache\n   * @param {Array.<number>=} writeIdsToExclude Optional writes to exclude.\n   * @param {boolean=} includeHiddenWrites Defaults to false, whether or not to layer on writes with visible set to false\n   * @return {?Node}\n   */\n  calcCompleteEventCache(\n    completeServerCache: Node | null,\n    writeIdsToExclude?: number[],\n    includeHiddenWrites?: boolean\n  ): Node | null {\n    return this.writeTree_.calcCompleteEventCache(\n      this.treePath_,\n      completeServerCache,\n      writeIdsToExclude,\n      includeHiddenWrites\n    );\n  }\n\n  /**\n   * If possible, returns a children node containing all of the complete children we have data for. The returned data is a\n   * mix of the given server data and write data.\n   *\n   * @param {?ChildrenNode} completeServerChildren\n   * @return {!ChildrenNode}\n   */\n  calcCompleteEventChildren(\n    completeServerChildren: ChildrenNode | null\n  ): ChildrenNode {\n    return this.writeTree_.calcCompleteEventChildren(\n      this.treePath_,\n      completeServerChildren\n    ) as ChildrenNode;\n  }\n\n  /**\n   * Given that either the underlying server data has updated or the outstanding writes have updated, determine what,\n   * if anything, needs to be applied to the event cache.\n   *\n   * Possibilities:\n   *\n   * 1. No writes are shadowing. Events should be raised, the snap to be applied comes from the server data\n   *\n   * 2. Some write is completely shadowing. No events to be raised\n   *\n   * 3. Is partially shadowed. Events should be raised\n   *\n   * Either existingEventSnap or existingServerSnap must exist, this is validated via an assert\n   *\n   * @param {!Path} path\n   * @param {?Node} existingEventSnap\n   * @param {?Node} existingServerSnap\n   * @return {?Node}\n   */\n  calcEventCacheAfterServerOverwrite(\n    path: Path,\n    existingEventSnap: Node | null,\n    existingServerSnap: Node | null\n  ): Node | null {\n    return this.writeTree_.calcEventCacheAfterServerOverwrite(\n      this.treePath_,\n      path,\n      existingEventSnap,\n      existingServerSnap\n    );\n  }\n\n  /**\n   * Returns a node if there is a complete overwrite for this path. More specifically, if there is a write at\n   * a higher path, this will return the child of that write relative to the write and this path.\n   * Returns null if there is no write at this path.\n   *\n   * @param {!Path} path\n   * @return {?Node}\n   */\n  shadowingWrite(path: Path): Node | null {\n    return this.writeTree_.shadowingWrite(this.treePath_.child(path));\n  }\n\n  /**\n   * This method is used when processing child remove events on a query. If we can, we pull in children that were outside\n   * the window, but may now be in the window\n   *\n   * @param {?Node} completeServerData\n   * @param {!NamedNode} startPost\n   * @param {!number} count\n   * @param {boolean} reverse\n   * @param {!Index} index\n   * @return {!Array.<!NamedNode>}\n   */\n  calcIndexedSlice(\n    completeServerData: Node | null,\n    startPost: NamedNode,\n    count: number,\n    reverse: boolean,\n    index: Index\n  ): NamedNode[] {\n    return this.writeTree_.calcIndexedSlice(\n      this.treePath_,\n      completeServerData,\n      startPost,\n      count,\n      reverse,\n      index\n    );\n  }\n\n  /**\n   * Returns a complete child for a given server snap after applying all user writes or null if there is no\n   * complete child for this ChildKey.\n   *\n   * @param {!string} childKey\n   * @param {!CacheNode} existingServerCache\n   * @return {?Node}\n   */\n  calcCompleteChild(\n    childKey: string,\n    existingServerCache: CacheNode\n  ): Node | null {\n    return this.writeTree_.calcCompleteChild(\n      this.treePath_,\n      childKey,\n      existingServerCache\n    );\n  }\n\n  /**\n   * Return a WriteTreeRef for a child.\n   *\n   * @param {string} childName\n   * @return {!WriteTreeRef}\n   */\n  child(childName: string): WriteTreeRef {\n    return new WriteTreeRef(this.treePath_.child(childName), this.writeTree_);\n  }\n}\n"]},"metadata":{},"sourceType":"script"}