{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Path_1 = require(\"../Path\");\n\nvar RepoInfo_1 = require(\"../../RepoInfo\");\n\nvar util_1 = require(\"../util\");\n/**\n * @param {!string} pathString\n * @return {string}\n */\n\n\nfunction decodePath(pathString) {\n  var pathStringDecoded = '';\n  var pieces = pathString.split('/');\n\n  for (var i = 0; i < pieces.length; i++) {\n    if (pieces[i].length > 0) {\n      var piece = pieces[i];\n\n      try {\n        piece = decodeURIComponent(piece.replace(/\\+/g, ' '));\n      } catch (e) {}\n\n      pathStringDecoded += '/' + piece;\n    }\n  }\n\n  return pathStringDecoded;\n}\n/**\n * @param {!string} queryString\n * @return {!{[key:string]:string}} key value hash\n */\n\n\nfunction decodeQuery(queryString) {\n  var results = {};\n\n  if (queryString.startsWith('?')) {\n    queryString = queryString.substring(1);\n  }\n\n  for (var _i = 0, _a = queryString.split('&'); _i < _a.length; _i++) {\n    var segment = _a[_i];\n\n    if (segment.length === 0) {\n      continue;\n    }\n\n    var kv = segment.split('=');\n\n    if (kv.length === 2) {\n      results[decodeURIComponent(kv[0])] = decodeURIComponent(kv[1]);\n    } else {\n      util_1.warn(\"Invalid query segment '\" + segment + \"' in query '\" + queryString + \"'\");\n    }\n  }\n\n  return results;\n}\n/**\n *\n * @param {!string} dataURL\n * @return {{repoInfo: !RepoInfo, path: !Path}}\n */\n\n\nexports.parseRepoInfo = function (dataURL) {\n  var parsedUrl = exports.parseURL(dataURL),\n      namespace = parsedUrl.subdomain;\n\n  if (parsedUrl.domain === 'firebase') {\n    util_1.fatal(parsedUrl.host + ' is no longer supported. ' + 'Please use <YOUR FIREBASE>.firebaseio.com instead');\n  } // Catch common error of uninitialized namespace value.\n\n\n  if ((!namespace || namespace == 'undefined') && parsedUrl.domain !== 'localhost') {\n    util_1.fatal('Cannot parse Firebase url. Please use https://<YOUR FIREBASE>.firebaseio.com');\n  }\n\n  if (!parsedUrl.secure) {\n    util_1.warnIfPageIsSecure();\n  }\n\n  var webSocketOnly = parsedUrl.scheme === 'ws' || parsedUrl.scheme === 'wss';\n  return {\n    repoInfo: new RepoInfo_1.RepoInfo(parsedUrl.host, parsedUrl.secure, namespace, webSocketOnly),\n    path: new Path_1.Path(parsedUrl.pathString)\n  };\n};\n/**\n *\n * @param {!string} dataURL\n * @return {{host: string, port: number, domain: string, subdomain: string, secure: boolean, scheme: string, pathString: string}}\n */\n\n\nexports.parseURL = function (dataURL) {\n  // Default to empty strings in the event of a malformed string.\n  var host = '',\n      domain = '',\n      subdomain = '',\n      pathString = ''; // Always default to SSL, unless otherwise specified.\n\n  var secure = true,\n      scheme = 'https',\n      port = 443; // Don't do any validation here. The caller is responsible for validating the result of parsing.\n\n  if (typeof dataURL === 'string') {\n    // Parse scheme.\n    var colonInd = dataURL.indexOf('//');\n\n    if (colonInd >= 0) {\n      scheme = dataURL.substring(0, colonInd - 1);\n      dataURL = dataURL.substring(colonInd + 2);\n    } // Parse host, path, and query string.\n\n\n    var slashInd = dataURL.indexOf('/');\n\n    if (slashInd === -1) {\n      slashInd = dataURL.length;\n    }\n\n    var questionMarkInd = dataURL.indexOf('?');\n\n    if (questionMarkInd === -1) {\n      questionMarkInd = dataURL.length;\n    }\n\n    host = dataURL.substring(0, Math.min(slashInd, questionMarkInd));\n\n    if (slashInd < questionMarkInd) {\n      // For pathString, questionMarkInd will always come after slashInd\n      pathString = decodePath(dataURL.substring(slashInd, questionMarkInd));\n    }\n\n    var queryParams = decodeQuery(dataURL.substring(Math.min(dataURL.length, questionMarkInd))); // If we have a port, use scheme for determining if it's secure.\n\n    colonInd = host.indexOf(':');\n\n    if (colonInd >= 0) {\n      secure = scheme === 'https' || scheme === 'wss';\n      port = parseInt(host.substring(colonInd + 1), 10);\n    } else {\n      colonInd = dataURL.length;\n    }\n\n    var parts = host.split('.');\n\n    if (parts.length === 3) {\n      // Normalize namespaces to lowercase to share storage / connection.\n      domain = parts[1];\n      subdomain = parts[0].toLowerCase();\n    } else if (parts.length === 2) {\n      domain = parts[0];\n    } else if (parts[0].slice(0, colonInd).toLowerCase() === 'localhost') {\n      domain = 'localhost';\n    } // Support `ns` query param if subdomain not already set\n\n\n    if (subdomain === '' && 'ns' in queryParams) {\n      subdomain = queryParams['ns'];\n    }\n  }\n\n  return {\n    host: host,\n    port: port,\n    domain: domain,\n    subdomain: subdomain,\n    secure: secure,\n    scheme: scheme,\n    pathString: pathString\n  };\n};","map":{"version":3,"sources":["../src/core/util/libs/parser.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;;;;;;AAgBA,IAAA,MAAA,GAAA,OAAA,CAAA,SAAA,CAAA;;AACA,IAAA,UAAA,GAAA,OAAA,CAAA,gBAAA,CAAA;;AACA,IAAA,MAAA,GAAA,OAAA,CAAA,SAAA,CAAA;AAEA;;;;;;AAIA,SAAA,UAAA,CAAoB,UAApB,EAAsC;AACpC,MAAI,iBAAiB,GAAG,EAAxB;AACA,MAAM,MAAM,GAAG,UAAU,CAAC,KAAX,CAAiB,GAAjB,CAAf;;AACA,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,MAAM,CAAC,MAA3B,EAAmC,CAAC,EAApC,EAAwC;AACtC,QAAI,MAAM,CAAC,CAAD,CAAN,CAAU,MAAV,GAAmB,CAAvB,EAA0B;AACxB,UAAI,KAAK,GAAG,MAAM,CAAC,CAAD,CAAlB;;AACA,UAAI;AACF,QAAA,KAAK,GAAG,kBAAkB,CAAC,KAAK,CAAC,OAAN,CAAc,KAAd,EAAqB,GAArB,CAAD,CAA1B;AACD,OAFD,CAEE,OAAO,CAAP,EAAU,CAAE;;AACd,MAAA,iBAAiB,IAAI,MAAM,KAA3B;AACD;AACF;;AACD,SAAO,iBAAP;AACD;AAED;;;;;;AAIA,SAAA,WAAA,CAAqB,WAArB,EAAwC;AACtC,MAAI,OAAO,GAAG,EAAd;;AACA,MAAI,WAAW,CAAC,UAAZ,CAAuB,GAAvB,CAAJ,EAAiC;AAC/B,IAAA,WAAW,GAAG,WAAW,CAAC,SAAZ,CAAsB,CAAtB,CAAd;AACD;;AACD,OAAsB,IAAA,EAAA,GAAA,CAAA,EAAA,EAAA,GAAA,WAAW,CAAC,KAAZ,CAAkB,GAAlB,CAAtB,EAAsB,EAAA,GAAA,EAAA,CAAA,MAAtB,EAAsB,EAAA,EAAtB,EAA4C;AAAvC,QAAM,OAAO,GAAA,EAAA,CAAA,EAAA,CAAb;;AACH,QAAI,OAAO,CAAC,MAAR,KAAmB,CAAvB,EAA0B;AACxB;AACD;;AACD,QAAM,EAAE,GAAG,OAAO,CAAC,KAAR,CAAc,GAAd,CAAX;;AACA,QAAI,EAAE,CAAC,MAAH,KAAc,CAAlB,EAAqB;AACnB,MAAA,OAAO,CAAC,kBAAkB,CAAC,EAAE,CAAC,CAAD,CAAH,CAAnB,CAAP,GAAqC,kBAAkB,CAAC,EAAE,CAAC,CAAD,CAAH,CAAvD;AACD,KAFD,MAEO;AACL,MAAA,MAAA,CAAA,IAAA,CAAK,4BAA0B,OAA1B,GAAiC,cAAjC,GAAgD,WAAhD,GAA2D,GAAhE;AACD;AACF;;AACD,SAAO,OAAP;AACD;AAED;;;;;;;AAKa,OAAA,CAAA,aAAA,GAAgB,UAC3B,OAD2B,EACZ;AAEf,MAAM,SAAS,GAAG,OAAA,CAAA,QAAA,CAAS,OAAT,CAAlB;AAAA,MACE,SAAS,GAAG,SAAS,CAAC,SADxB;;AAGA,MAAI,SAAS,CAAC,MAAV,KAAqB,UAAzB,EAAqC;AACnC,IAAA,MAAA,CAAA,KAAA,CACE,SAAS,CAAC,IAAV,GACE,2BADF,GAEE,mDAHJ;AAKD,GAXc,CAaf;;;AACA,MACE,CAAC,CAAC,SAAD,IAAc,SAAS,IAAI,WAA5B,KACA,SAAS,CAAC,MAAV,KAAqB,WAFvB,EAGE;AACA,IAAA,MAAA,CAAA,KAAA,CACE,8EADF;AAGD;;AAED,MAAI,CAAC,SAAS,CAAC,MAAf,EAAuB;AACrB,IAAA,MAAA,CAAA,kBAAA;AACD;;AAED,MAAM,aAAa,GAAG,SAAS,CAAC,MAAV,KAAqB,IAArB,IAA6B,SAAS,CAAC,MAAV,KAAqB,KAAxE;AAEA,SAAO;AACL,IAAA,QAAQ,EAAE,IAAI,UAAA,CAAA,QAAJ,CACR,SAAS,CAAC,IADF,EAER,SAAS,CAAC,MAFF,EAGR,SAHQ,EAIR,aAJQ,CADL;AAOL,IAAA,IAAI,EAAE,IAAI,MAAA,CAAA,IAAJ,CAAS,SAAS,CAAC,UAAnB;AAPD,GAAP;AASD,CAvCY;AAyCb;;;;;;;AAKa,OAAA,CAAA,QAAA,GAAW,UACtB,OADsB,EACP;AAUf;AACA,MAAI,IAAI,GAAG,EAAX;AAAA,MACE,MAAM,GAAG,EADX;AAAA,MAEE,SAAS,GAAG,EAFd;AAAA,MAGE,UAAU,GAAG,EAHf,CAXe,CAgBf;;AACA,MAAI,MAAM,GAAG,IAAb;AAAA,MACE,MAAM,GAAG,OADX;AAAA,MAEE,IAAI,GAAG,GAFT,CAjBe,CAqBf;;AACA,MAAI,OAAO,OAAP,KAAmB,QAAvB,EAAiC;AAC/B;AACA,QAAI,QAAQ,GAAG,OAAO,CAAC,OAAR,CAAgB,IAAhB,CAAf;;AACA,QAAI,QAAQ,IAAI,CAAhB,EAAmB;AACjB,MAAA,MAAM,GAAG,OAAO,CAAC,SAAR,CAAkB,CAAlB,EAAqB,QAAQ,GAAG,CAAhC,CAAT;AACA,MAAA,OAAO,GAAG,OAAO,CAAC,SAAR,CAAkB,QAAQ,GAAG,CAA7B,CAAV;AACD,KAN8B,CAQ/B;;;AACA,QAAI,QAAQ,GAAG,OAAO,CAAC,OAAR,CAAgB,GAAhB,CAAf;;AACA,QAAI,QAAQ,KAAK,CAAC,CAAlB,EAAqB;AACnB,MAAA,QAAQ,GAAG,OAAO,CAAC,MAAnB;AACD;;AACD,QAAI,eAAe,GAAG,OAAO,CAAC,OAAR,CAAgB,GAAhB,CAAtB;;AACA,QAAI,eAAe,KAAK,CAAC,CAAzB,EAA4B;AAC1B,MAAA,eAAe,GAAG,OAAO,CAAC,MAA1B;AACD;;AACD,IAAA,IAAI,GAAG,OAAO,CAAC,SAAR,CAAkB,CAAlB,EAAqB,IAAI,CAAC,GAAL,CAAS,QAAT,EAAmB,eAAnB,CAArB,CAAP;;AACA,QAAI,QAAQ,GAAG,eAAf,EAAgC;AAC9B;AACA,MAAA,UAAU,GAAG,UAAU,CAAC,OAAO,CAAC,SAAR,CAAkB,QAAlB,EAA4B,eAA5B,CAAD,CAAvB;AACD;;AACD,QAAI,WAAW,GAAG,WAAW,CAC3B,OAAO,CAAC,SAAR,CAAkB,IAAI,CAAC,GAAL,CAAS,OAAO,CAAC,MAAjB,EAAyB,eAAzB,CAAlB,CAD2B,CAA7B,CAtB+B,CA0B/B;;AACA,IAAA,QAAQ,GAAG,IAAI,CAAC,OAAL,CAAa,GAAb,CAAX;;AACA,QAAI,QAAQ,IAAI,CAAhB,EAAmB;AACjB,MAAA,MAAM,GAAG,MAAM,KAAK,OAAX,IAAsB,MAAM,KAAK,KAA1C;AACA,MAAA,IAAI,GAAG,QAAQ,CAAC,IAAI,CAAC,SAAL,CAAe,QAAQ,GAAG,CAA1B,CAAD,EAA+B,EAA/B,CAAf;AACD,KAHD,MAGO;AACL,MAAA,QAAQ,GAAG,OAAO,CAAC,MAAnB;AACD;;AAED,QAAM,KAAK,GAAG,IAAI,CAAC,KAAL,CAAW,GAAX,CAAd;;AACA,QAAI,KAAK,CAAC,MAAN,KAAiB,CAArB,EAAwB;AACtB;AACA,MAAA,MAAM,GAAG,KAAK,CAAC,CAAD,CAAd;AACA,MAAA,SAAS,GAAG,KAAK,CAAC,CAAD,CAAL,CAAS,WAAT,EAAZ;AACD,KAJD,MAIO,IAAI,KAAK,CAAC,MAAN,KAAiB,CAArB,EAAwB;AAC7B,MAAA,MAAM,GAAG,KAAK,CAAC,CAAD,CAAd;AACD,KAFM,MAEA,IAAI,KAAK,CAAC,CAAD,CAAL,CAAS,KAAT,CAAe,CAAf,EAAkB,QAAlB,EAA4B,WAA5B,OAA8C,WAAlD,EAA+D;AACpE,MAAA,MAAM,GAAG,WAAT;AACD,KA5C8B,CA6C/B;;;AACA,QAAI,SAAS,KAAK,EAAd,IAAoB,QAAQ,WAAhC,EAA6C;AAC3C,MAAA,SAAS,GAAG,WAAW,CAAC,IAAD,CAAvB;AACD;AACF;;AAED,SAAO;AACL,IAAA,IAAI,EAAA,IADC;AAEL,IAAA,IAAI,EAAA,IAFC;AAGL,IAAA,MAAM,EAAA,MAHD;AAIL,IAAA,SAAS,EAAA,SAJJ;AAKL,IAAA,MAAM,EAAA,MALD;AAML,IAAA,MAAM,EAAA,MAND;AAOL,IAAA,UAAU,EAAA;AAPL,GAAP;AASD,CAnFY","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Path } from '../Path';\nimport { RepoInfo } from '../../RepoInfo';\nimport { warnIfPageIsSecure, warn, fatal } from '../util';\n\n/**\n * @param {!string} pathString\n * @return {string}\n */\nfunction decodePath(pathString: string): string {\n  let pathStringDecoded = '';\n  const pieces = pathString.split('/');\n  for (let i = 0; i < pieces.length; i++) {\n    if (pieces[i].length > 0) {\n      let piece = pieces[i];\n      try {\n        piece = decodeURIComponent(piece.replace(/\\+/g, ' '));\n      } catch (e) {}\n      pathStringDecoded += '/' + piece;\n    }\n  }\n  return pathStringDecoded;\n}\n\n/**\n * @param {!string} queryString\n * @return {!{[key:string]:string}} key value hash\n */\nfunction decodeQuery(queryString: string): { [key: string]: string } {\n  let results = {};\n  if (queryString.startsWith('?')) {\n    queryString = queryString.substring(1);\n  }\n  for (const segment of queryString.split('&')) {\n    if (segment.length === 0) {\n      continue;\n    }\n    const kv = segment.split('=');\n    if (kv.length === 2) {\n      results[decodeURIComponent(kv[0])] = decodeURIComponent(kv[1]);\n    } else {\n      warn(`Invalid query segment '${segment}' in query '${queryString}'`);\n    }\n  }\n  return results;\n}\n\n/**\n *\n * @param {!string} dataURL\n * @return {{repoInfo: !RepoInfo, path: !Path}}\n */\nexport const parseRepoInfo = function(\n  dataURL: string\n): { repoInfo: RepoInfo; path: Path } {\n  const parsedUrl = parseURL(dataURL),\n    namespace = parsedUrl.subdomain;\n\n  if (parsedUrl.domain === 'firebase') {\n    fatal(\n      parsedUrl.host +\n        ' is no longer supported. ' +\n        'Please use <YOUR FIREBASE>.firebaseio.com instead'\n    );\n  }\n\n  // Catch common error of uninitialized namespace value.\n  if (\n    (!namespace || namespace == 'undefined') &&\n    parsedUrl.domain !== 'localhost'\n  ) {\n    fatal(\n      'Cannot parse Firebase url. Please use https://<YOUR FIREBASE>.firebaseio.com'\n    );\n  }\n\n  if (!parsedUrl.secure) {\n    warnIfPageIsSecure();\n  }\n\n  const webSocketOnly = parsedUrl.scheme === 'ws' || parsedUrl.scheme === 'wss';\n\n  return {\n    repoInfo: new RepoInfo(\n      parsedUrl.host,\n      parsedUrl.secure,\n      namespace,\n      webSocketOnly\n    ),\n    path: new Path(parsedUrl.pathString)\n  };\n};\n\n/**\n *\n * @param {!string} dataURL\n * @return {{host: string, port: number, domain: string, subdomain: string, secure: boolean, scheme: string, pathString: string}}\n */\nexport const parseURL = function(\n  dataURL: string\n): {\n  host: string;\n  port: number;\n  domain: string;\n  subdomain: string;\n  secure: boolean;\n  scheme: string;\n  pathString: string;\n} {\n  // Default to empty strings in the event of a malformed string.\n  let host = '',\n    domain = '',\n    subdomain = '',\n    pathString = '';\n\n  // Always default to SSL, unless otherwise specified.\n  let secure = true,\n    scheme = 'https',\n    port = 443;\n\n  // Don't do any validation here. The caller is responsible for validating the result of parsing.\n  if (typeof dataURL === 'string') {\n    // Parse scheme.\n    let colonInd = dataURL.indexOf('//');\n    if (colonInd >= 0) {\n      scheme = dataURL.substring(0, colonInd - 1);\n      dataURL = dataURL.substring(colonInd + 2);\n    }\n\n    // Parse host, path, and query string.\n    let slashInd = dataURL.indexOf('/');\n    if (slashInd === -1) {\n      slashInd = dataURL.length;\n    }\n    let questionMarkInd = dataURL.indexOf('?');\n    if (questionMarkInd === -1) {\n      questionMarkInd = dataURL.length;\n    }\n    host = dataURL.substring(0, Math.min(slashInd, questionMarkInd));\n    if (slashInd < questionMarkInd) {\n      // For pathString, questionMarkInd will always come after slashInd\n      pathString = decodePath(dataURL.substring(slashInd, questionMarkInd));\n    }\n    let queryParams = decodeQuery(\n      dataURL.substring(Math.min(dataURL.length, questionMarkInd))\n    );\n\n    // If we have a port, use scheme for determining if it's secure.\n    colonInd = host.indexOf(':');\n    if (colonInd >= 0) {\n      secure = scheme === 'https' || scheme === 'wss';\n      port = parseInt(host.substring(colonInd + 1), 10);\n    } else {\n      colonInd = dataURL.length;\n    }\n\n    const parts = host.split('.');\n    if (parts.length === 3) {\n      // Normalize namespaces to lowercase to share storage / connection.\n      domain = parts[1];\n      subdomain = parts[0].toLowerCase();\n    } else if (parts.length === 2) {\n      domain = parts[0];\n    } else if (parts[0].slice(0, colonInd).toLowerCase() === 'localhost') {\n      domain = 'localhost';\n    }\n    // Support `ns` query param if subdomain not already set\n    if (subdomain === '' && 'ns' in queryParams) {\n      subdomain = queryParams['ns'];\n    }\n  }\n\n  return {\n    host,\n    port,\n    domain,\n    subdomain,\n    secure,\n    scheme,\n    pathString\n  };\n};\n"]},"metadata":{},"sourceType":"script"}