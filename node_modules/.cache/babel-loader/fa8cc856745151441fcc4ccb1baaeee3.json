{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar util_1 = require(\"@firebase/util\");\n\nvar Change_1 = require(\"../Change\");\n\nvar ChildrenNode_1 = require(\"../../snap/ChildrenNode\");\n\nvar PriorityIndex_1 = require(\"../../snap/indexes/PriorityIndex\");\n/**\n * Doesn't really filter nodes but applies an index to the node and keeps track of any changes\n *\n * @constructor\n * @implements {NodeFilter}\n * @param {!Index} index\n */\n\n\nvar IndexedFilter =\n/** @class */\nfunction () {\n  function IndexedFilter(index_) {\n    this.index_ = index_;\n  }\n\n  IndexedFilter.prototype.updateChild = function (snap, key, newChild, affectedPath, source, optChangeAccumulator) {\n    util_1.assert(snap.isIndexed(this.index_), 'A node must be indexed if only a child is updated');\n    var oldChild = snap.getImmediateChild(key); // Check if anything actually changed.\n\n    if (oldChild.getChild(affectedPath).equals(newChild.getChild(affectedPath))) {\n      // There's an edge case where a child can enter or leave the view because affectedPath was set to null.\n      // In this case, affectedPath will appear null in both the old and new snapshots.  So we need\n      // to avoid treating these cases as \"nothing changed.\"\n      if (oldChild.isEmpty() == newChild.isEmpty()) {\n        // Nothing changed.\n        // This assert should be valid, but it's expensive (can dominate perf testing) so don't actually do it.\n        //assert(oldChild.equals(newChild), 'Old and new snapshots should be equal.');\n        return snap;\n      }\n    }\n\n    if (optChangeAccumulator != null) {\n      if (newChild.isEmpty()) {\n        if (snap.hasChild(key)) {\n          optChangeAccumulator.trackChildChange(Change_1.Change.childRemovedChange(key, oldChild));\n        } else {\n          util_1.assert(snap.isLeafNode(), 'A child remove without an old child only makes sense on a leaf node');\n        }\n      } else if (oldChild.isEmpty()) {\n        optChangeAccumulator.trackChildChange(Change_1.Change.childAddedChange(key, newChild));\n      } else {\n        optChangeAccumulator.trackChildChange(Change_1.Change.childChangedChange(key, newChild, oldChild));\n      }\n    }\n\n    if (snap.isLeafNode() && newChild.isEmpty()) {\n      return snap;\n    } else {\n      // Make sure the node is indexed\n      return snap.updateImmediateChild(key, newChild).withIndex(this.index_);\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  IndexedFilter.prototype.updateFullNode = function (oldSnap, newSnap, optChangeAccumulator) {\n    if (optChangeAccumulator != null) {\n      if (!oldSnap.isLeafNode()) {\n        oldSnap.forEachChild(PriorityIndex_1.PRIORITY_INDEX, function (key, childNode) {\n          if (!newSnap.hasChild(key)) {\n            optChangeAccumulator.trackChildChange(Change_1.Change.childRemovedChange(key, childNode));\n          }\n        });\n      }\n\n      if (!newSnap.isLeafNode()) {\n        newSnap.forEachChild(PriorityIndex_1.PRIORITY_INDEX, function (key, childNode) {\n          if (oldSnap.hasChild(key)) {\n            var oldChild = oldSnap.getImmediateChild(key);\n\n            if (!oldChild.equals(childNode)) {\n              optChangeAccumulator.trackChildChange(Change_1.Change.childChangedChange(key, childNode, oldChild));\n            }\n          } else {\n            optChangeAccumulator.trackChildChange(Change_1.Change.childAddedChange(key, childNode));\n          }\n        });\n      }\n    }\n\n    return newSnap.withIndex(this.index_);\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  IndexedFilter.prototype.updatePriority = function (oldSnap, newPriority) {\n    if (oldSnap.isEmpty()) {\n      return ChildrenNode_1.ChildrenNode.EMPTY_NODE;\n    } else {\n      return oldSnap.updatePriority(newPriority);\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  IndexedFilter.prototype.filtersNodes = function () {\n    return false;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  IndexedFilter.prototype.getIndexedFilter = function () {\n    return this;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  IndexedFilter.prototype.getIndex = function () {\n    return this.index_;\n  };\n\n  return IndexedFilter;\n}();\n\nexports.IndexedFilter = IndexedFilter;","map":{"version":3,"sources":["../src/core/view/filter/IndexedFilter.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert } from '@firebase/util';\nimport { Change } from '../Change';\nimport { ChildrenNode } from '../../snap/ChildrenNode';\nimport { PRIORITY_INDEX } from '../../snap/indexes/PriorityIndex';\nimport { NodeFilter } from './NodeFilter';\nimport { Index } from '../../snap/indexes/Index';\nimport { Path } from '../../util/Path';\nimport { CompleteChildSource } from '../CompleteChildSource';\nimport { ChildChangeAccumulator } from '../ChildChangeAccumulator';\nimport { Node } from '../../snap/Node';\n\n/**\n * Doesn't really filter nodes but applies an index to the node and keeps track of any changes\n *\n * @constructor\n * @implements {NodeFilter}\n * @param {!Index} index\n */\nexport class IndexedFilter implements NodeFilter {\n  constructor(private readonly index_: Index) {}\n\n  updateChild(\n    snap: Node,\n    key: string,\n    newChild: Node,\n    affectedPath: Path,\n    source: CompleteChildSource,\n    optChangeAccumulator: ChildChangeAccumulator | null\n  ): Node {\n    assert(\n      snap.isIndexed(this.index_),\n      'A node must be indexed if only a child is updated'\n    );\n    const oldChild = snap.getImmediateChild(key);\n    // Check if anything actually changed.\n    if (\n      oldChild.getChild(affectedPath).equals(newChild.getChild(affectedPath))\n    ) {\n      // There's an edge case where a child can enter or leave the view because affectedPath was set to null.\n      // In this case, affectedPath will appear null in both the old and new snapshots.  So we need\n      // to avoid treating these cases as \"nothing changed.\"\n      if (oldChild.isEmpty() == newChild.isEmpty()) {\n        // Nothing changed.\n\n        // This assert should be valid, but it's expensive (can dominate perf testing) so don't actually do it.\n        //assert(oldChild.equals(newChild), 'Old and new snapshots should be equal.');\n        return snap;\n      }\n    }\n\n    if (optChangeAccumulator != null) {\n      if (newChild.isEmpty()) {\n        if (snap.hasChild(key)) {\n          optChangeAccumulator.trackChildChange(\n            Change.childRemovedChange(key, oldChild)\n          );\n        } else {\n          assert(\n            snap.isLeafNode(),\n            'A child remove without an old child only makes sense on a leaf node'\n          );\n        }\n      } else if (oldChild.isEmpty()) {\n        optChangeAccumulator.trackChildChange(\n          Change.childAddedChange(key, newChild)\n        );\n      } else {\n        optChangeAccumulator.trackChildChange(\n          Change.childChangedChange(key, newChild, oldChild)\n        );\n      }\n    }\n    if (snap.isLeafNode() && newChild.isEmpty()) {\n      return snap;\n    } else {\n      // Make sure the node is indexed\n      return snap.updateImmediateChild(key, newChild).withIndex(this.index_);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  updateFullNode(\n    oldSnap: Node,\n    newSnap: Node,\n    optChangeAccumulator: ChildChangeAccumulator | null\n  ): Node {\n    if (optChangeAccumulator != null) {\n      if (!oldSnap.isLeafNode()) {\n        oldSnap.forEachChild(PRIORITY_INDEX, function(key, childNode) {\n          if (!newSnap.hasChild(key)) {\n            optChangeAccumulator.trackChildChange(\n              Change.childRemovedChange(key, childNode)\n            );\n          }\n        });\n      }\n      if (!newSnap.isLeafNode()) {\n        newSnap.forEachChild(PRIORITY_INDEX, function(key, childNode) {\n          if (oldSnap.hasChild(key)) {\n            const oldChild = oldSnap.getImmediateChild(key);\n            if (!oldChild.equals(childNode)) {\n              optChangeAccumulator.trackChildChange(\n                Change.childChangedChange(key, childNode, oldChild)\n              );\n            }\n          } else {\n            optChangeAccumulator.trackChildChange(\n              Change.childAddedChange(key, childNode)\n            );\n          }\n        });\n      }\n    }\n    return newSnap.withIndex(this.index_);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  updatePriority(oldSnap: Node, newPriority: Node): Node {\n    if (oldSnap.isEmpty()) {\n      return ChildrenNode.EMPTY_NODE;\n    } else {\n      return oldSnap.updatePriority(newPriority);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  filtersNodes(): boolean {\n    return false;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getIndexedFilter(): IndexedFilter {\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getIndex(): Index {\n    return this.index_;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}