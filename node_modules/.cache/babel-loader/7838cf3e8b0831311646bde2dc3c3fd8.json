{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\n\nimport { ErrorFactory } from '@firebase/util';\nimport Errors from './errors';\nimport arrayBufferToBase64 from '../helpers/array-buffer-to-base64';\nimport FCMDetails from './fcm-details';\n\nvar IIDModel =\n/** @class */\nfunction () {\n  function IIDModel() {\n    this.errorFactory_ = new ErrorFactory('messaging', 'Messaging', Errors.map);\n  }\n  /**\n   * Given a PushSubscription and messagingSenderId, get an FCM token.\n   * @public\n   * @param  {string} senderId The 'messagingSenderId' to tie the token to.\n   * @param  {PushSubscription} subscription The PushSusbcription to \"federate\".\n   * @param  {Uint8Array} publicVapidKey The public VAPID key.\n   * @return {Promise<!Object>} Returns the FCM token to be used in place\n   * of the PushSubscription.\n   */\n\n\n  IIDModel.prototype.getToken = function (senderId, subscription, publicVapidKey) {\n    var _this = this;\n\n    var p256dh = arrayBufferToBase64(subscription['getKey']('p256dh'));\n    var auth = arrayBufferToBase64(subscription['getKey']('auth'));\n    var fcmSubscribeBody = \"authorized_entity=\" + senderId + \"&\" + (\"endpoint=\" + subscription.endpoint + \"&\") + (\"encryption_key=\" + p256dh + \"&\") + (\"encryption_auth=\" + auth);\n\n    if (publicVapidKey !== FCMDetails.DEFAULT_PUBLIC_VAPID_KEY) {\n      var applicationPubKey = arrayBufferToBase64(publicVapidKey);\n      fcmSubscribeBody += \"&application_pub_key=\" + applicationPubKey;\n    }\n\n    var headers = new Headers();\n    headers.append('Content-Type', 'application/x-www-form-urlencoded');\n    var subscribeOptions = {\n      method: 'POST',\n      headers: headers,\n      body: fcmSubscribeBody\n    };\n    return fetch(FCMDetails.ENDPOINT + '/fcm/connect/subscribe', subscribeOptions).then(function (response) {\n      return response.json();\n    }).catch(function () {\n      throw _this.errorFactory_.create(Errors.codes.TOKEN_SUBSCRIBE_FAILED);\n    }).then(function (response) {\n      var fcmTokenResponse = response;\n\n      if (fcmTokenResponse['error']) {\n        var message = fcmTokenResponse['error']['message'];\n        throw _this.errorFactory_.create(Errors.codes.TOKEN_SUBSCRIBE_FAILED, {\n          message: message\n        });\n      }\n\n      if (!fcmTokenResponse['token']) {\n        throw _this.errorFactory_.create(Errors.codes.TOKEN_SUBSCRIBE_NO_TOKEN);\n      }\n\n      if (!fcmTokenResponse['pushSet']) {\n        throw _this.errorFactory_.create(Errors.codes.TOKEN_SUBSCRIBE_NO_PUSH_SET);\n      }\n\n      return {\n        token: fcmTokenResponse['token'],\n        pushSet: fcmTokenResponse['pushSet']\n      };\n    });\n  };\n  /**\n   * Update the underlying token details for fcmToken.\n   */\n\n\n  IIDModel.prototype.updateToken = function (senderId, fcmToken, fcmPushSet, subscription, publicVapidKey) {\n    var _this = this;\n\n    var p256dh = arrayBufferToBase64(subscription['getKey']('p256dh'));\n    var auth = arrayBufferToBase64(subscription['getKey']('auth'));\n    var fcmUpdateBody = \"push_set=\" + fcmPushSet + \"&\" + (\"token=\" + fcmToken + \"&\") + (\"authorized_entity=\" + senderId + \"&\") + (\"endpoint=\" + subscription.endpoint + \"&\") + (\"encryption_key=\" + p256dh + \"&\") + (\"encryption_auth=\" + auth);\n\n    if (publicVapidKey !== FCMDetails.DEFAULT_PUBLIC_VAPID_KEY) {\n      var applicationPubKey = arrayBufferToBase64(publicVapidKey);\n      fcmUpdateBody += \"&application_pub_key=\" + applicationPubKey;\n    }\n\n    var headers = new Headers();\n    headers.append('Content-Type', 'application/x-www-form-urlencoded');\n    var updateOptions = {\n      method: 'POST',\n      headers: headers,\n      body: fcmUpdateBody\n    };\n    var updateFetchRes;\n    return fetch(FCMDetails.ENDPOINT + '/fcm/connect/subscribe', updateOptions).then(function (fetchResponse) {\n      updateFetchRes = fetchResponse;\n      return fetchResponse.json();\n    }).catch(function () {\n      throw _this.errorFactory_.create(Errors.codes.TOKEN_UPDATE_FAILED);\n    }).then(function (fcmTokenResponse) {\n      if (!updateFetchRes.ok) {\n        var message = fcmTokenResponse['error']['message'];\n        throw _this.errorFactory_.create(Errors.codes.TOKEN_UPDATE_FAILED, {\n          message: message\n        });\n      }\n\n      if (!fcmTokenResponse['token']) {\n        throw _this.errorFactory_.create(Errors.codes.TOKEN_UPDATE_NO_TOKEN);\n      }\n\n      return fcmTokenResponse['token'];\n    });\n  };\n  /**\n   * Given a fcmToken, pushSet and messagingSenderId, delete an FCM token.\n   */\n\n\n  IIDModel.prototype.deleteToken = function (senderId, fcmToken, fcmPushSet) {\n    var _this = this;\n\n    var fcmUnsubscribeBody = \"authorized_entity=\" + senderId + \"&\" + (\"token=\" + fcmToken + \"&\") + (\"pushSet=\" + fcmPushSet);\n    var headers = new Headers();\n    headers.append('Content-Type', 'application/x-www-form-urlencoded');\n    var unsubscribeOptions = {\n      method: 'POST',\n      headers: headers,\n      body: fcmUnsubscribeBody\n    };\n    return fetch(FCMDetails.ENDPOINT + '/fcm/connect/unsubscribe', unsubscribeOptions).then(function (fetchResponse) {\n      if (!fetchResponse.ok) {\n        return fetchResponse.json().then(function (fcmTokenResponse) {\n          if (fcmTokenResponse['error']) {\n            var message = fcmTokenResponse['error']['message'];\n            throw _this.errorFactory_.create(Errors.codes.TOKEN_UNSUBSCRIBE_FAILED, {\n              message: message\n            });\n          }\n        }, function (err) {\n          throw _this.errorFactory_.create(Errors.codes.TOKEN_UNSUBSCRIBE_FAILED);\n        });\n      }\n    });\n  };\n\n  return IIDModel;\n}();\n\nexport default IIDModel;","map":{"version":3,"sources":["../src/models/iid-model.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n'use strict';\n\nimport { ErrorFactory, base64 } from '@firebase/util';\n\nimport Errors from './errors';\nimport arrayBufferToBase64 from '../helpers/array-buffer-to-base64';\nimport FCMDetails from './fcm-details';\n\nexport default class IIDModel {\n  private errorFactory_: ErrorFactory<string>;\n\n  constructor() {\n    this.errorFactory_ = new ErrorFactory('messaging', 'Messaging', Errors.map);\n  }\n\n  /**\n   * Given a PushSubscription and messagingSenderId, get an FCM token.\n   * @public\n   * @param  {string} senderId The 'messagingSenderId' to tie the token to.\n   * @param  {PushSubscription} subscription The PushSusbcription to \"federate\".\n   * @param  {Uint8Array} publicVapidKey The public VAPID key.\n   * @return {Promise<!Object>} Returns the FCM token to be used in place\n   * of the PushSubscription.\n   */\n  getToken(senderId, subscription, publicVapidKey): Promise<Object> {\n    const p256dh = arrayBufferToBase64(subscription['getKey']('p256dh'));\n    const auth = arrayBufferToBase64(subscription['getKey']('auth'));\n\n    let fcmSubscribeBody =\n      `authorized_entity=${senderId}&` +\n      `endpoint=${subscription.endpoint}&` +\n      `encryption_key=${p256dh}&` +\n      `encryption_auth=${auth}`;\n\n    if (publicVapidKey !== FCMDetails.DEFAULT_PUBLIC_VAPID_KEY) {\n      const applicationPubKey = arrayBufferToBase64(publicVapidKey);\n      fcmSubscribeBody += `&application_pub_key=${applicationPubKey}`;\n    }\n\n    const headers = new Headers();\n    headers.append('Content-Type', 'application/x-www-form-urlencoded');\n\n    const subscribeOptions = {\n      method: 'POST',\n      headers: headers,\n      body: fcmSubscribeBody\n    };\n\n    return fetch(\n      FCMDetails.ENDPOINT + '/fcm/connect/subscribe',\n      subscribeOptions\n    )\n      .then(response => response.json())\n      .catch(() => {\n        throw this.errorFactory_.create(Errors.codes.TOKEN_SUBSCRIBE_FAILED);\n      })\n      .then(response => {\n        const fcmTokenResponse = response;\n        if (fcmTokenResponse['error']) {\n          const message = fcmTokenResponse['error']['message'];\n          throw this.errorFactory_.create(Errors.codes.TOKEN_SUBSCRIBE_FAILED, {\n            message: message\n          });\n        }\n\n        if (!fcmTokenResponse['token']) {\n          throw this.errorFactory_.create(\n            Errors.codes.TOKEN_SUBSCRIBE_NO_TOKEN\n          );\n        }\n\n        if (!fcmTokenResponse['pushSet']) {\n          throw this.errorFactory_.create(\n            Errors.codes.TOKEN_SUBSCRIBE_NO_PUSH_SET\n          );\n        }\n\n        return {\n          token: fcmTokenResponse['token'],\n          pushSet: fcmTokenResponse['pushSet']\n        };\n      });\n  }\n\n  /**\n   * Update the underlying token details for fcmToken.\n   */\n  updateToken(\n    senderId: string,\n    fcmToken: string,\n    fcmPushSet: string,\n    subscription: PushSubscription,\n    publicVapidKey: Uint8Array\n  ): Promise<string> {\n    const p256dh = arrayBufferToBase64(subscription['getKey']('p256dh'));\n    const auth = arrayBufferToBase64(subscription['getKey']('auth'));\n\n    let fcmUpdateBody =\n      `push_set=${fcmPushSet}&` +\n      `token=${fcmToken}&` +\n      `authorized_entity=${senderId}&` +\n      `endpoint=${subscription.endpoint}&` +\n      `encryption_key=${p256dh}&` +\n      `encryption_auth=${auth}`;\n\n    if (publicVapidKey !== FCMDetails.DEFAULT_PUBLIC_VAPID_KEY) {\n      const applicationPubKey = arrayBufferToBase64(publicVapidKey);\n      fcmUpdateBody += `&application_pub_key=${applicationPubKey}`;\n    }\n\n    const headers = new Headers();\n    headers.append('Content-Type', 'application/x-www-form-urlencoded');\n\n    const updateOptions = {\n      method: 'POST',\n      headers: headers,\n      body: fcmUpdateBody\n    };\n\n    let updateFetchRes;\n    return fetch(FCMDetails.ENDPOINT + '/fcm/connect/subscribe', updateOptions)\n      .then(fetchResponse => {\n        updateFetchRes = fetchResponse;\n        return fetchResponse.json();\n      })\n      .catch(() => {\n        throw this.errorFactory_.create(Errors.codes.TOKEN_UPDATE_FAILED);\n      })\n      .then(fcmTokenResponse => {\n        if (!updateFetchRes.ok) {\n          const message = fcmTokenResponse['error']['message'];\n          throw this.errorFactory_.create(Errors.codes.TOKEN_UPDATE_FAILED, {\n            message: message\n          });\n        }\n        if (!fcmTokenResponse['token']) {\n          throw this.errorFactory_.create(Errors.codes.TOKEN_UPDATE_NO_TOKEN);\n        }\n        return fcmTokenResponse['token'];\n      });\n  }\n\n  /**\n   * Given a fcmToken, pushSet and messagingSenderId, delete an FCM token.\n   */\n  deleteToken(\n    senderId: string,\n    fcmToken: string,\n    fcmPushSet: string\n  ): Promise<void> {\n    let fcmUnsubscribeBody =\n      `authorized_entity=${senderId}&` +\n      `token=${fcmToken}&` +\n      `pushSet=${fcmPushSet}`;\n\n    const headers = new Headers();\n    headers.append('Content-Type', 'application/x-www-form-urlencoded');\n\n    const unsubscribeOptions = {\n      method: 'POST',\n      headers: headers,\n      body: fcmUnsubscribeBody\n    };\n\n    return fetch(\n      FCMDetails.ENDPOINT + '/fcm/connect/unsubscribe',\n      unsubscribeOptions\n    ).then(fetchResponse => {\n      if (!fetchResponse.ok) {\n        return fetchResponse.json().then(\n          fcmTokenResponse => {\n            if (fcmTokenResponse['error']) {\n              const message = fcmTokenResponse['error']['message'];\n              throw this.errorFactory_.create(\n                Errors.codes.TOKEN_UNSUBSCRIBE_FAILED,\n                {\n                  message: message\n                }\n              );\n            }\n          },\n          err => {\n            throw this.errorFactory_.create(\n              Errors.codes.TOKEN_UNSUBSCRIBE_FAILED\n            );\n          }\n        );\n      }\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}