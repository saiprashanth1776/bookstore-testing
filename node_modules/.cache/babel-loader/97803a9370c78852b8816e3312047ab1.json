{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar ImmutableTree_1 = require(\"./util/ImmutableTree\");\n\nvar Path_1 = require(\"./util/Path\");\n\nvar util_1 = require(\"@firebase/util\");\n\nvar Node_1 = require(\"./snap/Node\");\n\nvar PriorityIndex_1 = require(\"./snap/indexes/PriorityIndex\");\n\nvar util_2 = require(\"@firebase/util\");\n/**\n * This class holds a collection of writes that can be applied to nodes in unison. It abstracts away the logic with\n * dealing with priority writes and multiple nested writes. At any given path there is only allowed to be one write\n * modifying that path. Any write to an existing path or shadowing an existing path will modify that existing write\n * to reflect the write added.\n *\n * @constructor\n * @param {!ImmutableTree.<!Node>} writeTree\n */\n\n\nvar CompoundWrite =\n/** @class */\nfunction () {\n  function CompoundWrite(writeTree_) {\n    this.writeTree_ = writeTree_;\n  }\n  /**\n   * @param {!Path} path\n   * @param {!Node} node\n   * @return {!CompoundWrite}\n   */\n\n\n  CompoundWrite.prototype.addWrite = function (path, node) {\n    if (path.isEmpty()) {\n      return new CompoundWrite(new ImmutableTree_1.ImmutableTree(node));\n    } else {\n      var rootmost = this.writeTree_.findRootMostValueAndPath(path);\n\n      if (rootmost != null) {\n        var rootMostPath = rootmost.path;\n        var value = rootmost.value;\n        var relativePath = Path_1.Path.relativePath(rootMostPath, path);\n        value = value.updateChild(relativePath, node);\n        return new CompoundWrite(this.writeTree_.set(rootMostPath, value));\n      } else {\n        var subtree = new ImmutableTree_1.ImmutableTree(node);\n        var newWriteTree = this.writeTree_.setTree(path, subtree);\n        return new CompoundWrite(newWriteTree);\n      }\n    }\n  };\n  /**\n   * @param {!Path} path\n   * @param {!Object.<string, !Node>} updates\n   * @return {!CompoundWrite}\n   */\n\n\n  CompoundWrite.prototype.addWrites = function (path, updates) {\n    var newWrite = this;\n    util_1.forEach(updates, function (childKey, node) {\n      newWrite = newWrite.addWrite(path.child(childKey), node);\n    });\n    return newWrite;\n  };\n  /**\n   * Will remove a write at the given path and deeper paths. This will <em>not</em> modify a write at a higher\n   * location, which must be removed by calling this method with that path.\n   *\n   * @param {!Path} path The path at which a write and all deeper writes should be removed\n   * @return {!CompoundWrite} The new CompoundWrite with the removed path\n   */\n\n\n  CompoundWrite.prototype.removeWrite = function (path) {\n    if (path.isEmpty()) {\n      return CompoundWrite.Empty;\n    } else {\n      var newWriteTree = this.writeTree_.setTree(path, ImmutableTree_1.ImmutableTree.Empty);\n      return new CompoundWrite(newWriteTree);\n    }\n  };\n  /**\n   * Returns whether this CompoundWrite will fully overwrite a node at a given location and can therefore be\n   * considered \"complete\".\n   *\n   * @param {!Path} path The path to check for\n   * @return {boolean} Whether there is a complete write at that path\n   */\n\n\n  CompoundWrite.prototype.hasCompleteWrite = function (path) {\n    return this.getCompleteNode(path) != null;\n  };\n  /**\n   * Returns a node for a path if and only if the node is a \"complete\" overwrite at that path. This will not aggregate\n   * writes from deeper paths, but will return child nodes from a more shallow path.\n   *\n   * @param {!Path} path The path to get a complete write\n   * @return {?Node} The node if complete at that path, or null otherwise.\n   */\n\n\n  CompoundWrite.prototype.getCompleteNode = function (path) {\n    var rootmost = this.writeTree_.findRootMostValueAndPath(path);\n\n    if (rootmost != null) {\n      return this.writeTree_.get(rootmost.path).getChild(Path_1.Path.relativePath(rootmost.path, path));\n    } else {\n      return null;\n    }\n  };\n  /**\n   * Returns all children that are guaranteed to be a complete overwrite.\n   *\n   * @return {!Array.<NamedNode>} A list of all complete children.\n   */\n\n\n  CompoundWrite.prototype.getCompleteChildren = function () {\n    var children = [];\n    var node = this.writeTree_.value;\n\n    if (node != null) {\n      // If it's a leaf node, it has no children; so nothing to do.\n      if (!node.isLeafNode()) {\n        node.forEachChild(PriorityIndex_1.PRIORITY_INDEX, function (childName, childNode) {\n          children.push(new Node_1.NamedNode(childName, childNode));\n        });\n      }\n    } else {\n      this.writeTree_.children.inorderTraversal(function (childName, childTree) {\n        if (childTree.value != null) {\n          children.push(new Node_1.NamedNode(childName, childTree.value));\n        }\n      });\n    }\n\n    return children;\n  };\n  /**\n   * @param {!Path} path\n   * @return {!CompoundWrite}\n   */\n\n\n  CompoundWrite.prototype.childCompoundWrite = function (path) {\n    if (path.isEmpty()) {\n      return this;\n    } else {\n      var shadowingNode = this.getCompleteNode(path);\n\n      if (shadowingNode != null) {\n        return new CompoundWrite(new ImmutableTree_1.ImmutableTree(shadowingNode));\n      } else {\n        return new CompoundWrite(this.writeTree_.subtree(path));\n      }\n    }\n  };\n  /**\n   * Returns true if this CompoundWrite is empty and therefore does not modify any nodes.\n   * @return {boolean} Whether this CompoundWrite is empty\n   */\n\n\n  CompoundWrite.prototype.isEmpty = function () {\n    return this.writeTree_.isEmpty();\n  };\n  /**\n   * Applies this CompoundWrite to a node. The node is returned with all writes from this CompoundWrite applied to the\n   * node\n   * @param {!Node} node The node to apply this CompoundWrite to\n   * @return {!Node} The node with all writes applied\n   */\n\n\n  CompoundWrite.prototype.apply = function (node) {\n    return CompoundWrite.applySubtreeWrite_(Path_1.Path.Empty, this.writeTree_, node);\n  };\n  /**\n   * @type {!CompoundWrite}\n   */\n\n\n  CompoundWrite.Empty = new CompoundWrite(new ImmutableTree_1.ImmutableTree(null));\n  /**\n   * @param {!Path} relativePath\n   * @param {!ImmutableTree.<!Node>} writeTree\n   * @param {!Node} node\n   * @return {!Node}\n   * @private\n   */\n\n  CompoundWrite.applySubtreeWrite_ = function (relativePath, writeTree, node) {\n    if (writeTree.value != null) {\n      // Since there a write is always a leaf, we're done here\n      return node.updateChild(relativePath, writeTree.value);\n    } else {\n      var priorityWrite_1 = null;\n      writeTree.children.inorderTraversal(function (childKey, childTree) {\n        if (childKey === '.priority') {\n          // Apply priorities at the end so we don't update priorities for either empty nodes or forget\n          // to apply priorities to empty nodes that are later filled\n          util_2.assert(childTree.value !== null, 'Priority writes must always be leaf nodes');\n          priorityWrite_1 = childTree.value;\n        } else {\n          node = CompoundWrite.applySubtreeWrite_(relativePath.child(childKey), childTree, node);\n        }\n      }); // If there was a priority write, we only apply it if the node is not empty\n\n      if (!node.getChild(relativePath).isEmpty() && priorityWrite_1 !== null) {\n        node = node.updateChild(relativePath.child('.priority'), priorityWrite_1);\n      }\n\n      return node;\n    }\n  };\n\n  return CompoundWrite;\n}();\n\nexports.CompoundWrite = CompoundWrite;","map":{"version":3,"sources":["../src/core/CompoundWrite.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;;;;;;AAgBA,IAAA,eAAA,GAAA,OAAA,CAAA,sBAAA,CAAA;;AACA,IAAA,MAAA,GAAA,OAAA,CAAA,aAAA,CAAA;;AACA,IAAA,MAAA,GAAA,OAAA,CAAA,gBAAA,CAAA;;AACA,IAAA,MAAA,GAAA,OAAA,CAAA,aAAA,CAAA;;AACA,IAAA,eAAA,GAAA,OAAA,CAAA,8BAAA,CAAA;;AACA,IAAA,MAAA,GAAA,OAAA,CAAA,gBAAA,CAAA;AAGA;;;;;;;;;;;AASA,IAAA,aAAA;AAAA;AAAA,YAAA;AACE,WAAA,aAAA,CAAoB,UAApB,EAAmD;AAA/B,SAAA,UAAA,GAAA,UAAA;AAAmC;AAMvD;;;;;;;AAKA,EAAA,aAAA,CAAA,SAAA,CAAA,QAAA,GAAA,UAAS,IAAT,EAAqB,IAArB,EAA+B;AAC7B,QAAI,IAAI,CAAC,OAAL,EAAJ,EAAoB;AAClB,aAAO,IAAI,aAAJ,CAAkB,IAAI,eAAA,CAAA,aAAJ,CAAkB,IAAlB,CAAlB,CAAP;AACD,KAFD,MAEO;AACL,UAAM,QAAQ,GAAG,KAAK,UAAL,CAAgB,wBAAhB,CAAyC,IAAzC,CAAjB;;AACA,UAAI,QAAQ,IAAI,IAAhB,EAAsB;AACpB,YAAM,YAAY,GAAG,QAAQ,CAAC,IAA9B;AACA,YAAI,KAAK,GAAG,QAAQ,CAAC,KAArB;AACA,YAAM,YAAY,GAAG,MAAA,CAAA,IAAA,CAAK,YAAL,CAAkB,YAAlB,EAAgC,IAAhC,CAArB;AACA,QAAA,KAAK,GAAG,KAAK,CAAC,WAAN,CAAkB,YAAlB,EAAgC,IAAhC,CAAR;AACA,eAAO,IAAI,aAAJ,CAAkB,KAAK,UAAL,CAAgB,GAAhB,CAAoB,YAApB,EAAkC,KAAlC,CAAlB,CAAP;AACD,OAND,MAMO;AACL,YAAM,OAAO,GAAG,IAAI,eAAA,CAAA,aAAJ,CAAkB,IAAlB,CAAhB;AACA,YAAM,YAAY,GAAG,KAAK,UAAL,CAAgB,OAAhB,CAAwB,IAAxB,EAA8B,OAA9B,CAArB;AACA,eAAO,IAAI,aAAJ,CAAkB,YAAlB,CAAP;AACD;AACF;AACF,GAjBD;AAmBA;;;;;;;AAKA,EAAA,aAAA,CAAA,SAAA,CAAA,SAAA,GAAA,UAAU,IAAV,EAAsB,OAAtB,EAAuD;AACrD,QAAI,QAAQ,GAAG,IAAf;AACA,IAAA,MAAA,CAAA,OAAA,CAAQ,OAAR,EAAiB,UAAS,QAAT,EAA2B,IAA3B,EAAqC;AACpD,MAAA,QAAQ,GAAG,QAAQ,CAAC,QAAT,CAAkB,IAAI,CAAC,KAAL,CAAW,QAAX,CAAlB,EAAwC,IAAxC,CAAX;AACD,KAFD;AAGA,WAAO,QAAP;AACD,GAND;AAQA;;;;;;;;;AAOA,EAAA,aAAA,CAAA,SAAA,CAAA,WAAA,GAAA,UAAY,IAAZ,EAAsB;AACpB,QAAI,IAAI,CAAC,OAAL,EAAJ,EAAoB;AAClB,aAAO,aAAa,CAAC,KAArB;AACD,KAFD,MAEO;AACL,UAAM,YAAY,GAAG,KAAK,UAAL,CAAgB,OAAhB,CAAwB,IAAxB,EAA8B,eAAA,CAAA,aAAA,CAAc,KAA5C,CAArB;AACA,aAAO,IAAI,aAAJ,CAAkB,YAAlB,CAAP;AACD;AACF,GAPD;AASA;;;;;;;;;AAOA,EAAA,aAAA,CAAA,SAAA,CAAA,gBAAA,GAAA,UAAiB,IAAjB,EAA2B;AACzB,WAAO,KAAK,eAAL,CAAqB,IAArB,KAA8B,IAArC;AACD,GAFD;AAIA;;;;;;;;;AAOA,EAAA,aAAA,CAAA,SAAA,CAAA,eAAA,GAAA,UAAgB,IAAhB,EAA0B;AACxB,QAAM,QAAQ,GAAG,KAAK,UAAL,CAAgB,wBAAhB,CAAyC,IAAzC,CAAjB;;AACA,QAAI,QAAQ,IAAI,IAAhB,EAAsB;AACpB,aAAO,KAAK,UAAL,CACJ,GADI,CACA,QAAQ,CAAC,IADT,EAEJ,QAFI,CAEK,MAAA,CAAA,IAAA,CAAK,YAAL,CAAkB,QAAQ,CAAC,IAA3B,EAAiC,IAAjC,CAFL,CAAP;AAGD,KAJD,MAIO;AACL,aAAO,IAAP;AACD;AACF,GATD;AAWA;;;;;;;AAKA,EAAA,aAAA,CAAA,SAAA,CAAA,mBAAA,GAAA,YAAA;AACE,QAAM,QAAQ,GAAgB,EAA9B;AACA,QAAI,IAAI,GAAG,KAAK,UAAL,CAAgB,KAA3B;;AACA,QAAI,IAAI,IAAI,IAAZ,EAAkB;AAChB;AACA,UAAI,CAAC,IAAI,CAAC,UAAL,EAAL,EAAwB;AACrB,QAAA,IAAqB,CAAC,YAAtB,CAAmC,eAAA,CAAA,cAAnC,EAAmD,UAClD,SADkD,EAElD,SAFkD,EAEzC;AAET,UAAA,QAAQ,CAAC,IAAT,CAAc,IAAI,MAAA,CAAA,SAAJ,CAAc,SAAd,EAAyB,SAAzB,CAAd;AACD,SALA;AAMF;AACF,KAVD,MAUO;AACL,WAAK,UAAL,CAAgB,QAAhB,CAAyB,gBAAzB,CAA0C,UAAS,SAAT,EAAoB,SAApB,EAA6B;AACrE,YAAI,SAAS,CAAC,KAAV,IAAmB,IAAvB,EAA6B;AAC3B,UAAA,QAAQ,CAAC,IAAT,CAAc,IAAI,MAAA,CAAA,SAAJ,CAAc,SAAd,EAAyB,SAAS,CAAC,KAAnC,CAAd;AACD;AACF,OAJD;AAKD;;AACD,WAAO,QAAP;AACD,GArBD;AAuBA;;;;;;AAIA,EAAA,aAAA,CAAA,SAAA,CAAA,kBAAA,GAAA,UAAmB,IAAnB,EAA6B;AAC3B,QAAI,IAAI,CAAC,OAAL,EAAJ,EAAoB;AAClB,aAAO,IAAP;AACD,KAFD,MAEO;AACL,UAAM,aAAa,GAAG,KAAK,eAAL,CAAqB,IAArB,CAAtB;;AACA,UAAI,aAAa,IAAI,IAArB,EAA2B;AACzB,eAAO,IAAI,aAAJ,CAAkB,IAAI,eAAA,CAAA,aAAJ,CAAkB,aAAlB,CAAlB,CAAP;AACD,OAFD,MAEO;AACL,eAAO,IAAI,aAAJ,CAAkB,KAAK,UAAL,CAAgB,OAAhB,CAAwB,IAAxB,CAAlB,CAAP;AACD;AACF;AACF,GAXD;AAaA;;;;;;AAIA,EAAA,aAAA,CAAA,SAAA,CAAA,OAAA,GAAA,YAAA;AACE,WAAO,KAAK,UAAL,CAAgB,OAAhB,EAAP;AACD,GAFD;AAIA;;;;;;;;AAMA,EAAA,aAAA,CAAA,SAAA,CAAA,KAAA,GAAA,UAAM,IAAN,EAAgB;AACd,WAAO,aAAa,CAAC,kBAAd,CAAiC,MAAA,CAAA,IAAA,CAAK,KAAtC,EAA6C,KAAK,UAAlD,EAA8D,IAA9D,CAAP;AACD,GAFD;AAlJA;;;;;AAGO,EAAA,aAAA,CAAA,KAAA,GAAQ,IAAI,aAAJ,CAAkB,IAAI,eAAA,CAAA,aAAJ,CAAkB,IAAlB,CAAlB,CAAR;AAmJP;;;;;;;;AAOe,EAAA,aAAA,CAAA,kBAAA,GAAqB,UAClC,YADkC,EAElC,SAFkC,EAGlC,IAHkC,EAGxB;AAEV,QAAI,SAAS,CAAC,KAAV,IAAmB,IAAvB,EAA6B;AAC3B;AACA,aAAO,IAAI,CAAC,WAAL,CAAiB,YAAjB,EAA+B,SAAS,CAAC,KAAzC,CAAP;AACD,KAHD,MAGO;AACL,UAAI,eAAa,GAAG,IAApB;AACA,MAAA,SAAS,CAAC,QAAV,CAAmB,gBAAnB,CAAoC,UAAS,QAAT,EAAmB,SAAnB,EAA4B;AAC9D,YAAI,QAAQ,KAAK,WAAjB,EAA8B;AAC5B;AACA;AACA,UAAA,MAAA,CAAA,MAAA,CACE,SAAS,CAAC,KAAV,KAAoB,IADtB,EAEE,2CAFF;AAIA,UAAA,eAAa,GAAG,SAAS,CAAC,KAA1B;AACD,SARD,MAQO;AACL,UAAA,IAAI,GAAG,aAAa,CAAC,kBAAd,CACL,YAAY,CAAC,KAAb,CAAmB,QAAnB,CADK,EAEL,SAFK,EAGL,IAHK,CAAP;AAKD;AACF,OAhBD,EAFK,CAmBL;;AACA,UAAI,CAAC,IAAI,CAAC,QAAL,CAAc,YAAd,EAA4B,OAA5B,EAAD,IAA0C,eAAa,KAAK,IAAhE,EAAsE;AACpE,QAAA,IAAI,GAAG,IAAI,CAAC,WAAL,CAAiB,YAAY,CAAC,KAAb,CAAmB,WAAnB,CAAjB,EAAkD,eAAlD,CAAP;AACD;;AACD,aAAO,IAAP;AACD;AACF,GAjCc;;AAkCjB,SAAA,aAAA;AAAC,CAjMD,EAAA;;AAAa,OAAA,CAAA,aAAA,GAAA,aAAA","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ImmutableTree } from './util/ImmutableTree';\nimport { Path } from './util/Path';\nimport { forEach } from '@firebase/util';\nimport { Node, NamedNode } from './snap/Node';\nimport { PRIORITY_INDEX } from './snap/indexes/PriorityIndex';\nimport { assert } from '@firebase/util';\nimport { ChildrenNode } from './snap/ChildrenNode';\n\n/**\n * This class holds a collection of writes that can be applied to nodes in unison. It abstracts away the logic with\n * dealing with priority writes and multiple nested writes. At any given path there is only allowed to be one write\n * modifying that path. Any write to an existing path or shadowing an existing path will modify that existing write\n * to reflect the write added.\n *\n * @constructor\n * @param {!ImmutableTree.<!Node>} writeTree\n */\nexport class CompoundWrite {\n  constructor(private writeTree_: ImmutableTree<Node>) {}\n  /**\n   * @type {!CompoundWrite}\n   */\n  static Empty = new CompoundWrite(new ImmutableTree(null));\n\n  /**\n   * @param {!Path} path\n   * @param {!Node} node\n   * @return {!CompoundWrite}\n   */\n  addWrite(path: Path, node: Node): CompoundWrite {\n    if (path.isEmpty()) {\n      return new CompoundWrite(new ImmutableTree(node));\n    } else {\n      const rootmost = this.writeTree_.findRootMostValueAndPath(path);\n      if (rootmost != null) {\n        const rootMostPath = rootmost.path;\n        let value = rootmost.value;\n        const relativePath = Path.relativePath(rootMostPath, path);\n        value = value.updateChild(relativePath, node);\n        return new CompoundWrite(this.writeTree_.set(rootMostPath, value));\n      } else {\n        const subtree = new ImmutableTree(node);\n        const newWriteTree = this.writeTree_.setTree(path, subtree);\n        return new CompoundWrite(newWriteTree);\n      }\n    }\n  }\n\n  /**\n   * @param {!Path} path\n   * @param {!Object.<string, !Node>} updates\n   * @return {!CompoundWrite}\n   */\n  addWrites(path: Path, updates: { [name: string]: Node }): CompoundWrite {\n    let newWrite = this as CompoundWrite;\n    forEach(updates, function(childKey: string, node: Node) {\n      newWrite = newWrite.addWrite(path.child(childKey), node);\n    });\n    return newWrite;\n  }\n\n  /**\n   * Will remove a write at the given path and deeper paths. This will <em>not</em> modify a write at a higher\n   * location, which must be removed by calling this method with that path.\n   *\n   * @param {!Path} path The path at which a write and all deeper writes should be removed\n   * @return {!CompoundWrite} The new CompoundWrite with the removed path\n   */\n  removeWrite(path: Path): CompoundWrite {\n    if (path.isEmpty()) {\n      return CompoundWrite.Empty;\n    } else {\n      const newWriteTree = this.writeTree_.setTree(path, ImmutableTree.Empty);\n      return new CompoundWrite(newWriteTree);\n    }\n  }\n\n  /**\n   * Returns whether this CompoundWrite will fully overwrite a node at a given location and can therefore be\n   * considered \"complete\".\n   *\n   * @param {!Path} path The path to check for\n   * @return {boolean} Whether there is a complete write at that path\n   */\n  hasCompleteWrite(path: Path): boolean {\n    return this.getCompleteNode(path) != null;\n  }\n\n  /**\n   * Returns a node for a path if and only if the node is a \"complete\" overwrite at that path. This will not aggregate\n   * writes from deeper paths, but will return child nodes from a more shallow path.\n   *\n   * @param {!Path} path The path to get a complete write\n   * @return {?Node} The node if complete at that path, or null otherwise.\n   */\n  getCompleteNode(path: Path): Node | null {\n    const rootmost = this.writeTree_.findRootMostValueAndPath(path);\n    if (rootmost != null) {\n      return this.writeTree_\n        .get(rootmost.path)\n        .getChild(Path.relativePath(rootmost.path, path));\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Returns all children that are guaranteed to be a complete overwrite.\n   *\n   * @return {!Array.<NamedNode>} A list of all complete children.\n   */\n  getCompleteChildren(): Array<NamedNode> {\n    const children: NamedNode[] = [];\n    let node = this.writeTree_.value;\n    if (node != null) {\n      // If it's a leaf node, it has no children; so nothing to do.\n      if (!node.isLeafNode()) {\n        (node as ChildrenNode).forEachChild(PRIORITY_INDEX, function(\n          childName,\n          childNode\n        ) {\n          children.push(new NamedNode(childName, childNode));\n        });\n      }\n    } else {\n      this.writeTree_.children.inorderTraversal(function(childName, childTree) {\n        if (childTree.value != null) {\n          children.push(new NamedNode(childName, childTree.value));\n        }\n      });\n    }\n    return children;\n  }\n\n  /**\n   * @param {!Path} path\n   * @return {!CompoundWrite}\n   */\n  childCompoundWrite(path: Path): CompoundWrite {\n    if (path.isEmpty()) {\n      return this;\n    } else {\n      const shadowingNode = this.getCompleteNode(path);\n      if (shadowingNode != null) {\n        return new CompoundWrite(new ImmutableTree(shadowingNode));\n      } else {\n        return new CompoundWrite(this.writeTree_.subtree(path));\n      }\n    }\n  }\n\n  /**\n   * Returns true if this CompoundWrite is empty and therefore does not modify any nodes.\n   * @return {boolean} Whether this CompoundWrite is empty\n   */\n  isEmpty(): boolean {\n    return this.writeTree_.isEmpty();\n  }\n\n  /**\n   * Applies this CompoundWrite to a node. The node is returned with all writes from this CompoundWrite applied to the\n   * node\n   * @param {!Node} node The node to apply this CompoundWrite to\n   * @return {!Node} The node with all writes applied\n   */\n  apply(node: Node): Node {\n    return CompoundWrite.applySubtreeWrite_(Path.Empty, this.writeTree_, node);\n  }\n\n  /**\n   * @param {!Path} relativePath\n   * @param {!ImmutableTree.<!Node>} writeTree\n   * @param {!Node} node\n   * @return {!Node}\n   * @private\n   */\n  private static applySubtreeWrite_ = function(\n    relativePath: Path,\n    writeTree: ImmutableTree<Node>,\n    node: Node\n  ): Node {\n    if (writeTree.value != null) {\n      // Since there a write is always a leaf, we're done here\n      return node.updateChild(relativePath, writeTree.value);\n    } else {\n      let priorityWrite = null;\n      writeTree.children.inorderTraversal(function(childKey, childTree) {\n        if (childKey === '.priority') {\n          // Apply priorities at the end so we don't update priorities for either empty nodes or forget\n          // to apply priorities to empty nodes that are later filled\n          assert(\n            childTree.value !== null,\n            'Priority writes must always be leaf nodes'\n          );\n          priorityWrite = childTree.value;\n        } else {\n          node = CompoundWrite.applySubtreeWrite_(\n            relativePath.child(childKey),\n            childTree,\n            node\n          );\n        }\n      });\n      // If there was a priority write, we only apply it if the node is not empty\n      if (!node.getChild(relativePath).isEmpty() && priorityWrite !== null) {\n        node = node.updateChild(relativePath.child('.priority'), priorityWrite);\n      }\n      return node;\n    }\n  };\n}\n"]},"metadata":{},"sourceType":"script"}