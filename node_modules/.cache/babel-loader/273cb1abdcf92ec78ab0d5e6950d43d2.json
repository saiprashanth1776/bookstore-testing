{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar util_1 = require(\"@firebase/util\");\n\nvar util_2 = require(\"../util/util\");\n\nvar snap_1 = require(\"./snap\");\n\nvar __childrenNodeConstructor;\n/**\n * LeafNode is a class for storing leaf nodes in a DataSnapshot.  It\n * implements Node and stores the value of the node (a string,\n * number, or boolean) accessible via getValue().\n */\n\n\nvar LeafNode =\n/** @class */\nfunction () {\n  /**\n   * @implements {Node}\n   * @param {!(string|number|boolean|Object)} value_ The value to store in this leaf node.\n   *                                         The object type is possible in the event of a deferred value\n   * @param {!Node=} priorityNode_ The priority of this node.\n   */\n  function LeafNode(value_, priorityNode_) {\n    if (priorityNode_ === void 0) {\n      priorityNode_ = LeafNode.__childrenNodeConstructor.EMPTY_NODE;\n    }\n\n    this.value_ = value_;\n    this.priorityNode_ = priorityNode_;\n    this.lazyHash_ = null;\n    util_1.assert(this.value_ !== undefined && this.value_ !== null, \"LeafNode shouldn't be created with null/undefined value.\");\n    snap_1.validatePriorityNode(this.priorityNode_);\n  }\n\n  Object.defineProperty(LeafNode, \"__childrenNodeConstructor\", {\n    get: function () {\n      return __childrenNodeConstructor;\n    },\n    set: function (val) {\n      __childrenNodeConstructor = val;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /** @inheritDoc */\n\n  LeafNode.prototype.isLeafNode = function () {\n    return true;\n  };\n  /** @inheritDoc */\n\n\n  LeafNode.prototype.getPriority = function () {\n    return this.priorityNode_;\n  };\n  /** @inheritDoc */\n\n\n  LeafNode.prototype.updatePriority = function (newPriorityNode) {\n    return new LeafNode(this.value_, newPriorityNode);\n  };\n  /** @inheritDoc */\n\n\n  LeafNode.prototype.getImmediateChild = function (childName) {\n    // Hack to treat priority as a regular child\n    if (childName === '.priority') {\n      return this.priorityNode_;\n    } else {\n      return LeafNode.__childrenNodeConstructor.EMPTY_NODE;\n    }\n  };\n  /** @inheritDoc */\n\n\n  LeafNode.prototype.getChild = function (path) {\n    if (path.isEmpty()) {\n      return this;\n    } else if (path.getFront() === '.priority') {\n      return this.priorityNode_;\n    } else {\n      return LeafNode.__childrenNodeConstructor.EMPTY_NODE;\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  LeafNode.prototype.hasChild = function () {\n    return false;\n  };\n  /** @inheritDoc */\n\n\n  LeafNode.prototype.getPredecessorChildName = function (childName, childNode) {\n    return null;\n  };\n  /** @inheritDoc */\n\n\n  LeafNode.prototype.updateImmediateChild = function (childName, newChildNode) {\n    if (childName === '.priority') {\n      return this.updatePriority(newChildNode);\n    } else if (newChildNode.isEmpty() && childName !== '.priority') {\n      return this;\n    } else {\n      return LeafNode.__childrenNodeConstructor.EMPTY_NODE.updateImmediateChild(childName, newChildNode).updatePriority(this.priorityNode_);\n    }\n  };\n  /** @inheritDoc */\n\n\n  LeafNode.prototype.updateChild = function (path, newChildNode) {\n    var front = path.getFront();\n\n    if (front === null) {\n      return newChildNode;\n    } else if (newChildNode.isEmpty() && front !== '.priority') {\n      return this;\n    } else {\n      util_1.assert(front !== '.priority' || path.getLength() === 1, '.priority must be the last token in a path');\n      return this.updateImmediateChild(front, LeafNode.__childrenNodeConstructor.EMPTY_NODE.updateChild(path.popFront(), newChildNode));\n    }\n  };\n  /** @inheritDoc */\n\n\n  LeafNode.prototype.isEmpty = function () {\n    return false;\n  };\n  /** @inheritDoc */\n\n\n  LeafNode.prototype.numChildren = function () {\n    return 0;\n  };\n  /** @inheritDoc */\n\n\n  LeafNode.prototype.forEachChild = function (index, action) {\n    return false;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  LeafNode.prototype.val = function (exportFormat) {\n    if (exportFormat && !this.getPriority().isEmpty()) return {\n      '.value': this.getValue(),\n      '.priority': this.getPriority().val()\n    };else return this.getValue();\n  };\n  /** @inheritDoc */\n\n\n  LeafNode.prototype.hash = function () {\n    if (this.lazyHash_ === null) {\n      var toHash = '';\n      if (!this.priorityNode_.isEmpty()) toHash += 'priority:' + snap_1.priorityHashText(this.priorityNode_.val()) + ':';\n      var type = typeof this.value_;\n      toHash += type + ':';\n\n      if (type === 'number') {\n        toHash += util_2.doubleToIEEE754String(this.value_);\n      } else {\n        toHash += this.value_;\n      }\n\n      this.lazyHash_ = util_2.sha1(toHash);\n    }\n\n    return this.lazyHash_;\n  };\n  /**\n   * Returns the value of the leaf node.\n   * @return {Object|string|number|boolean} The value of the node.\n   */\n\n\n  LeafNode.prototype.getValue = function () {\n    return this.value_;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  LeafNode.prototype.compareTo = function (other) {\n    if (other === LeafNode.__childrenNodeConstructor.EMPTY_NODE) {\n      return 1;\n    } else if (other instanceof LeafNode.__childrenNodeConstructor) {\n      return -1;\n    } else {\n      util_1.assert(other.isLeafNode(), 'Unknown node type');\n      return this.compareToLeafNode_(other);\n    }\n  };\n  /**\n   * Comparison specifically for two leaf nodes\n   * @param {!LeafNode} otherLeaf\n   * @return {!number}\n   * @private\n   */\n\n\n  LeafNode.prototype.compareToLeafNode_ = function (otherLeaf) {\n    var otherLeafType = typeof otherLeaf.value_;\n    var thisLeafType = typeof this.value_;\n    var otherIndex = LeafNode.VALUE_TYPE_ORDER.indexOf(otherLeafType);\n    var thisIndex = LeafNode.VALUE_TYPE_ORDER.indexOf(thisLeafType);\n    util_1.assert(otherIndex >= 0, 'Unknown leaf type: ' + otherLeafType);\n    util_1.assert(thisIndex >= 0, 'Unknown leaf type: ' + thisLeafType);\n\n    if (otherIndex === thisIndex) {\n      // Same type, compare values\n      if (thisLeafType === 'object') {\n        // Deferred value nodes are all equal, but we should also never get to this point...\n        return 0;\n      } else {\n        // Note that this works because true > false, all others are number or string comparisons\n        if (this.value_ < otherLeaf.value_) {\n          return -1;\n        } else if (this.value_ === otherLeaf.value_) {\n          return 0;\n        } else {\n          return 1;\n        }\n      }\n    } else {\n      return thisIndex - otherIndex;\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  LeafNode.prototype.withIndex = function () {\n    return this;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  LeafNode.prototype.isIndexed = function () {\n    return true;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  LeafNode.prototype.equals = function (other) {\n    /**\n     * @inheritDoc\n     */\n    if (other === this) {\n      return true;\n    } else if (other.isLeafNode()) {\n      var otherLeaf = other;\n      return this.value_ === otherLeaf.value_ && this.priorityNode_.equals(otherLeaf.priorityNode_);\n    } else {\n      return false;\n    }\n  };\n  /**\n   * The sort order for comparing leaf nodes of different types. If two leaf nodes have\n   * the same type, the comparison falls back to their value\n   * @type {Array.<!string>}\n   * @const\n   */\n\n\n  LeafNode.VALUE_TYPE_ORDER = ['object', 'boolean', 'number', 'string'];\n  return LeafNode;\n}();\n\nexports.LeafNode = LeafNode;","map":{"version":3,"sources":["../src/core/snap/LeafNode.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert } from '@firebase/util';\nimport { doubleToIEEE754String, sha1 } from '../util/util';\nimport { priorityHashText, validatePriorityNode } from './snap';\nimport { Node } from './Node';\nimport { Path } from '../util/Path';\nimport { Index } from './indexes/Index';\nimport { ChildrenNodeConstructor } from './ChildrenNode';\n\nlet __childrenNodeConstructor: ChildrenNodeConstructor;\n\n/**\n * LeafNode is a class for storing leaf nodes in a DataSnapshot.  It\n * implements Node and stores the value of the node (a string,\n * number, or boolean) accessible via getValue().\n */\nexport class LeafNode implements Node {\n  static set __childrenNodeConstructor(val: ChildrenNodeConstructor) {\n    __childrenNodeConstructor = val;\n  }\n\n  static get __childrenNodeConstructor() {\n    return __childrenNodeConstructor;\n  }\n\n  /**\n   * The sort order for comparing leaf nodes of different types. If two leaf nodes have\n   * the same type, the comparison falls back to their value\n   * @type {Array.<!string>}\n   * @const\n   */\n  static VALUE_TYPE_ORDER = ['object', 'boolean', 'number', 'string'];\n\n  private lazyHash_: string | null = null;\n\n  /**\n   * @implements {Node}\n   * @param {!(string|number|boolean|Object)} value_ The value to store in this leaf node.\n   *                                         The object type is possible in the event of a deferred value\n   * @param {!Node=} priorityNode_ The priority of this node.\n   */\n  constructor(\n    private readonly value_: string | number | boolean | object,\n    private priorityNode_: Node = LeafNode.__childrenNodeConstructor.EMPTY_NODE\n  ) {\n    assert(\n      this.value_ !== undefined && this.value_ !== null,\n      \"LeafNode shouldn't be created with null/undefined value.\"\n    );\n\n    validatePriorityNode(this.priorityNode_);\n  }\n\n  /** @inheritDoc */\n  isLeafNode(): boolean {\n    return true;\n  }\n\n  /** @inheritDoc */\n  getPriority(): Node {\n    return this.priorityNode_;\n  }\n\n  /** @inheritDoc */\n  updatePriority(newPriorityNode: Node): Node {\n    return new LeafNode(this.value_, newPriorityNode);\n  }\n\n  /** @inheritDoc */\n  getImmediateChild(childName: string): Node {\n    // Hack to treat priority as a regular child\n    if (childName === '.priority') {\n      return this.priorityNode_;\n    } else {\n      return LeafNode.__childrenNodeConstructor.EMPTY_NODE;\n    }\n  }\n\n  /** @inheritDoc */\n  getChild(path: Path): Node {\n    if (path.isEmpty()) {\n      return this;\n    } else if (path.getFront() === '.priority') {\n      return this.priorityNode_;\n    } else {\n      return LeafNode.__childrenNodeConstructor.EMPTY_NODE;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  hasChild(): boolean {\n    return false;\n  }\n\n  /** @inheritDoc */\n  getPredecessorChildName(childName: String, childNode: Node): null {\n    return null;\n  }\n\n  /** @inheritDoc */\n  updateImmediateChild(childName: string, newChildNode: Node): Node {\n    if (childName === '.priority') {\n      return this.updatePriority(newChildNode);\n    } else if (newChildNode.isEmpty() && childName !== '.priority') {\n      return this;\n    } else {\n      return LeafNode.__childrenNodeConstructor.EMPTY_NODE.updateImmediateChild(\n        childName,\n        newChildNode\n      ).updatePriority(this.priorityNode_);\n    }\n  }\n\n  /** @inheritDoc */\n  updateChild(path: Path, newChildNode: Node): Node {\n    const front = path.getFront();\n    if (front === null) {\n      return newChildNode;\n    } else if (newChildNode.isEmpty() && front !== '.priority') {\n      return this;\n    } else {\n      assert(\n        front !== '.priority' || path.getLength() === 1,\n        '.priority must be the last token in a path'\n      );\n\n      return this.updateImmediateChild(\n        front,\n        LeafNode.__childrenNodeConstructor.EMPTY_NODE.updateChild(\n          path.popFront(),\n          newChildNode\n        )\n      );\n    }\n  }\n\n  /** @inheritDoc */\n  isEmpty(): boolean {\n    return false;\n  }\n\n  /** @inheritDoc */\n  numChildren(): number {\n    return 0;\n  }\n\n  /** @inheritDoc */\n  forEachChild(index: Index, action: (s: string, n: Node) => void): any {\n    return false;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  val(exportFormat?: boolean): Object {\n    if (exportFormat && !this.getPriority().isEmpty())\n      return {\n        '.value': this.getValue(),\n        '.priority': this.getPriority().val()\n      };\n    else return this.getValue();\n  }\n\n  /** @inheritDoc */\n  hash(): string {\n    if (this.lazyHash_ === null) {\n      let toHash = '';\n      if (!this.priorityNode_.isEmpty())\n        toHash +=\n          'priority:' +\n          priorityHashText(this.priorityNode_.val() as number | string) +\n          ':';\n\n      const type = typeof this.value_;\n      toHash += type + ':';\n      if (type === 'number') {\n        toHash += doubleToIEEE754String(this.value_ as number);\n      } else {\n        toHash += this.value_;\n      }\n      this.lazyHash_ = sha1(toHash);\n    }\n    return this.lazyHash_;\n  }\n\n  /**\n   * Returns the value of the leaf node.\n   * @return {Object|string|number|boolean} The value of the node.\n   */\n  getValue(): object | string | number | boolean {\n    return this.value_;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  compareTo(other: Node): number {\n    if (other === LeafNode.__childrenNodeConstructor.EMPTY_NODE) {\n      return 1;\n    } else if (other instanceof LeafNode.__childrenNodeConstructor) {\n      return -1;\n    } else {\n      assert(other.isLeafNode(), 'Unknown node type');\n      return this.compareToLeafNode_(other as LeafNode);\n    }\n  }\n\n  /**\n   * Comparison specifically for two leaf nodes\n   * @param {!LeafNode} otherLeaf\n   * @return {!number}\n   * @private\n   */\n  private compareToLeafNode_(otherLeaf: LeafNode): number {\n    const otherLeafType = typeof otherLeaf.value_;\n    const thisLeafType = typeof this.value_;\n    const otherIndex = LeafNode.VALUE_TYPE_ORDER.indexOf(otherLeafType);\n    const thisIndex = LeafNode.VALUE_TYPE_ORDER.indexOf(thisLeafType);\n    assert(otherIndex >= 0, 'Unknown leaf type: ' + otherLeafType);\n    assert(thisIndex >= 0, 'Unknown leaf type: ' + thisLeafType);\n    if (otherIndex === thisIndex) {\n      // Same type, compare values\n      if (thisLeafType === 'object') {\n        // Deferred value nodes are all equal, but we should also never get to this point...\n        return 0;\n      } else {\n        // Note that this works because true > false, all others are number or string comparisons\n        if (this.value_ < otherLeaf.value_) {\n          return -1;\n        } else if (this.value_ === otherLeaf.value_) {\n          return 0;\n        } else {\n          return 1;\n        }\n      }\n    } else {\n      return thisIndex - otherIndex;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  withIndex(): Node {\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  isIndexed(): boolean {\n    return true;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  equals(other: Node): boolean {\n    /**\n     * @inheritDoc\n     */\n    if (other === this) {\n      return true;\n    } else if (other.isLeafNode()) {\n      const otherLeaf = other as LeafNode;\n      return (\n        this.value_ === otherLeaf.value_ &&\n        this.priorityNode_.equals(otherLeaf.priorityNode_)\n      );\n    } else {\n      return false;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}