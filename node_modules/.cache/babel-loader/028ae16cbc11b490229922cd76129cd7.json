{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar app_1 = require(\"@firebase/app\");\n\nvar util_1 = require(\"@firebase/util\");\n\nvar util_2 = require(\"../core/util/util\");\n\nvar StatsManager_1 = require(\"../core/stats/StatsManager\");\n\nvar Constants_1 = require(\"./Constants\");\n\nvar util_3 = require(\"@firebase/util\");\n\nvar storage_1 = require(\"../core/storage/storage\");\n\nvar util_4 = require(\"@firebase/util\");\n\nvar util_5 = require(\"@firebase/util\");\n\nvar WEBSOCKET_MAX_FRAME_SIZE = 16384;\nvar WEBSOCKET_KEEPALIVE_INTERVAL = 45000;\nvar WebSocketImpl = null;\n\nif (typeof MozWebSocket !== 'undefined') {\n  WebSocketImpl = MozWebSocket;\n} else if (typeof WebSocket !== 'undefined') {\n  WebSocketImpl = WebSocket;\n}\n\nfunction setWebSocketImpl(impl) {\n  WebSocketImpl = impl;\n}\n\nexports.setWebSocketImpl = setWebSocketImpl;\n/**\n * Create a new websocket connection with the given callbacks.\n * @constructor\n * @implements {Transport}\n */\n\nvar WebSocketConnection =\n/** @class */\nfunction () {\n  /**\n   * @param {string} connId identifier for this transport\n   * @param {RepoInfo} repoInfo The info for the websocket endpoint.\n   * @param {string=} transportSessionId Optional transportSessionId if this is connecting to an existing transport\n   *                                         session\n   * @param {string=} lastSessionId Optional lastSessionId if there was a previous connection\n   */\n  function WebSocketConnection(connId, repoInfo, transportSessionId, lastSessionId) {\n    this.connId = connId;\n    this.keepaliveTimer = null;\n    this.frames = null;\n    this.totalFrames = 0;\n    this.bytesSent = 0;\n    this.bytesReceived = 0;\n    this.log_ = util_2.logWrapper(this.connId);\n    this.stats_ = StatsManager_1.StatsManager.getCollection(repoInfo);\n    this.connURL = WebSocketConnection.connectionURL_(repoInfo, transportSessionId, lastSessionId);\n  }\n  /**\n   * @param {RepoInfo} repoInfo The info for the websocket endpoint.\n   * @param {string=} transportSessionId Optional transportSessionId if this is connecting to an existing transport\n   *                                         session\n   * @param {string=} lastSessionId Optional lastSessionId if there was a previous connection\n   * @return {string} connection url\n   * @private\n   */\n\n\n  WebSocketConnection.connectionURL_ = function (repoInfo, transportSessionId, lastSessionId) {\n    var urlParams = {};\n    urlParams[Constants_1.VERSION_PARAM] = Constants_1.PROTOCOL_VERSION;\n\n    if (!util_5.isNodeSdk() && typeof location !== 'undefined' && location.href && location.href.indexOf(Constants_1.FORGE_DOMAIN) !== -1) {\n      urlParams[Constants_1.REFERER_PARAM] = Constants_1.FORGE_REF;\n    }\n\n    if (transportSessionId) {\n      urlParams[Constants_1.TRANSPORT_SESSION_PARAM] = transportSessionId;\n    }\n\n    if (lastSessionId) {\n      urlParams[Constants_1.LAST_SESSION_PARAM] = lastSessionId;\n    }\n\n    return repoInfo.connectionURL(Constants_1.WEBSOCKET, urlParams);\n  };\n  /**\n   *\n   * @param onMessage Callback when messages arrive\n   * @param onDisconnect Callback with connection lost.\n   */\n\n\n  WebSocketConnection.prototype.open = function (onMessage, onDisconnect) {\n    var _this = this;\n\n    this.onDisconnect = onDisconnect;\n    this.onMessage = onMessage;\n    this.log_('Websocket connecting to ' + this.connURL);\n    this.everConnected_ = false; // Assume failure until proven otherwise.\n\n    storage_1.PersistentStorage.set('previous_websocket_failure', true);\n\n    try {\n      if (util_5.isNodeSdk()) {\n        var device = util_3.CONSTANTS.NODE_ADMIN ? 'AdminNode' : 'Node'; // UA Format: Firebase/<wire_protocol>/<sdk_version>/<platform>/<device>\n\n        var options = {\n          headers: {\n            'User-Agent': \"Firebase/\" + Constants_1.PROTOCOL_VERSION + \"/\" + app_1.default.SDK_VERSION + \"/\" + process.platform + \"/\" + device\n          }\n        }; // Plumb appropriate http_proxy environment variable into faye-websocket if it exists.\n\n        var env = process['env'];\n        var proxy = this.connURL.indexOf('wss://') == 0 ? env['HTTPS_PROXY'] || env['https_proxy'] : env['HTTP_PROXY'] || env['http_proxy'];\n\n        if (proxy) {\n          options['proxy'] = {\n            origin: proxy\n          };\n        }\n\n        this.mySock = new WebSocketImpl(this.connURL, [], options);\n      } else {\n        this.mySock = new WebSocketImpl(this.connURL);\n      }\n    } catch (e) {\n      this.log_('Error instantiating WebSocket.');\n      var error = e.message || e.data;\n\n      if (error) {\n        this.log_(error);\n      }\n\n      this.onClosed_();\n      return;\n    }\n\n    this.mySock.onopen = function () {\n      _this.log_('Websocket connected.');\n\n      _this.everConnected_ = true;\n    };\n\n    this.mySock.onclose = function () {\n      _this.log_('Websocket connection was disconnected.');\n\n      _this.mySock = null;\n\n      _this.onClosed_();\n    };\n\n    this.mySock.onmessage = function (m) {\n      _this.handleIncomingFrame(m);\n    };\n\n    this.mySock.onerror = function (e) {\n      _this.log_('WebSocket error.  Closing connection.');\n\n      var error = e.message || e.data;\n\n      if (error) {\n        _this.log_(error);\n      }\n\n      _this.onClosed_();\n    };\n  };\n  /**\n   * No-op for websockets, we don't need to do anything once the connection is confirmed as open\n   */\n\n\n  WebSocketConnection.prototype.start = function () {};\n\n  WebSocketConnection.forceDisallow = function () {\n    WebSocketConnection.forceDisallow_ = true;\n  };\n\n  WebSocketConnection.isAvailable = function () {\n    var isOldAndroid = false;\n\n    if (typeof navigator !== 'undefined' && navigator.userAgent) {\n      var oldAndroidRegex = /Android ([0-9]{0,}\\.[0-9]{0,})/;\n      var oldAndroidMatch = navigator.userAgent.match(oldAndroidRegex);\n\n      if (oldAndroidMatch && oldAndroidMatch.length > 1) {\n        if (parseFloat(oldAndroidMatch[1]) < 4.4) {\n          isOldAndroid = true;\n        }\n      }\n    }\n\n    return !isOldAndroid && WebSocketImpl !== null && !WebSocketConnection.forceDisallow_;\n  };\n  /**\n   * Returns true if we previously failed to connect with this transport.\n   * @return {boolean}\n   */\n\n\n  WebSocketConnection.previouslyFailed = function () {\n    // If our persistent storage is actually only in-memory storage,\n    // we default to assuming that it previously failed to be safe.\n    return storage_1.PersistentStorage.isInMemoryStorage || storage_1.PersistentStorage.get('previous_websocket_failure') === true;\n  };\n\n  WebSocketConnection.prototype.markConnectionHealthy = function () {\n    storage_1.PersistentStorage.remove('previous_websocket_failure');\n  };\n\n  WebSocketConnection.prototype.appendFrame_ = function (data) {\n    this.frames.push(data);\n\n    if (this.frames.length == this.totalFrames) {\n      var fullMess = this.frames.join('');\n      this.frames = null;\n      var jsonMess = util_4.jsonEval(fullMess); //handle the message\n\n      this.onMessage(jsonMess);\n    }\n  };\n  /**\n   * @param {number} frameCount The number of frames we are expecting from the server\n   * @private\n   */\n\n\n  WebSocketConnection.prototype.handleNewFrameCount_ = function (frameCount) {\n    this.totalFrames = frameCount;\n    this.frames = [];\n  };\n  /**\n   * Attempts to parse a frame count out of some text. If it can't, assumes a value of 1\n   * @param {!String} data\n   * @return {?String} Any remaining data to be process, or null if there is none\n   * @private\n   */\n\n\n  WebSocketConnection.prototype.extractFrameCount_ = function (data) {\n    util_1.assert(this.frames === null, 'We already have a frame buffer'); // TODO: The server is only supposed to send up to 9999 frames (i.e. length <= 4), but that isn't being enforced\n    // currently.  So allowing larger frame counts (length <= 6).  See https://app.asana.com/0/search/8688598998380/8237608042508\n\n    if (data.length <= 6) {\n      var frameCount = Number(data);\n\n      if (!isNaN(frameCount)) {\n        this.handleNewFrameCount_(frameCount);\n        return null;\n      }\n    }\n\n    this.handleNewFrameCount_(1);\n    return data;\n  };\n  /**\n   * Process a websocket frame that has arrived from the server.\n   * @param mess The frame data\n   */\n\n\n  WebSocketConnection.prototype.handleIncomingFrame = function (mess) {\n    if (this.mySock === null) return; // Chrome apparently delivers incoming packets even after we .close() the connection sometimes.\n\n    var data = mess['data'];\n    this.bytesReceived += data.length;\n    this.stats_.incrementCounter('bytes_received', data.length);\n    this.resetKeepAlive();\n\n    if (this.frames !== null) {\n      // we're buffering\n      this.appendFrame_(data);\n    } else {\n      // try to parse out a frame count, otherwise, assume 1 and process it\n      var remainingData = this.extractFrameCount_(data);\n\n      if (remainingData !== null) {\n        this.appendFrame_(remainingData);\n      }\n    }\n  };\n  /**\n   * Send a message to the server\n   * @param {Object} data The JSON object to transmit\n   */\n\n\n  WebSocketConnection.prototype.send = function (data) {\n    this.resetKeepAlive();\n    var dataStr = util_4.stringify(data);\n    this.bytesSent += dataStr.length;\n    this.stats_.incrementCounter('bytes_sent', dataStr.length); //We can only fit a certain amount in each websocket frame, so we need to split this request\n    //up into multiple pieces if it doesn't fit in one request.\n\n    var dataSegs = util_2.splitStringBySize(dataStr, WEBSOCKET_MAX_FRAME_SIZE); //Send the length header\n\n    if (dataSegs.length > 1) {\n      this.sendString_(String(dataSegs.length));\n    } //Send the actual data in segments.\n\n\n    for (var i = 0; i < dataSegs.length; i++) {\n      this.sendString_(dataSegs[i]);\n    }\n  };\n\n  WebSocketConnection.prototype.shutdown_ = function () {\n    this.isClosed_ = true;\n\n    if (this.keepaliveTimer) {\n      clearInterval(this.keepaliveTimer);\n      this.keepaliveTimer = null;\n    }\n\n    if (this.mySock) {\n      this.mySock.close();\n      this.mySock = null;\n    }\n  };\n\n  WebSocketConnection.prototype.onClosed_ = function () {\n    if (!this.isClosed_) {\n      this.log_('WebSocket is closing itself');\n      this.shutdown_(); // since this is an internal close, trigger the close listener\n\n      if (this.onDisconnect) {\n        this.onDisconnect(this.everConnected_);\n        this.onDisconnect = null;\n      }\n    }\n  };\n  /**\n   * External-facing close handler.\n   * Close the websocket and kill the connection.\n   */\n\n\n  WebSocketConnection.prototype.close = function () {\n    if (!this.isClosed_) {\n      this.log_('WebSocket is being closed');\n      this.shutdown_();\n    }\n  };\n  /**\n   * Kill the current keepalive timer and start a new one, to ensure that it always fires N seconds after\n   * the last activity.\n   */\n\n\n  WebSocketConnection.prototype.resetKeepAlive = function () {\n    var _this = this;\n\n    clearInterval(this.keepaliveTimer);\n    this.keepaliveTimer = setInterval(function () {\n      //If there has been no websocket activity for a while, send a no-op\n      if (_this.mySock) {\n        _this.sendString_('0');\n      }\n\n      _this.resetKeepAlive();\n    }, Math.floor(WEBSOCKET_KEEPALIVE_INTERVAL));\n  };\n  /**\n   * Send a string over the websocket.\n   *\n   * @param {string} str String to send.\n   * @private\n   */\n\n\n  WebSocketConnection.prototype.sendString_ = function (str) {\n    // Firefox seems to sometimes throw exceptions (NS_ERROR_UNEXPECTED) from websocket .send()\n    // calls for some unknown reason.  We treat these as an error and disconnect.\n    // See https://app.asana.com/0/58926111402292/68021340250410\n    try {\n      this.mySock.send(str);\n    } catch (e) {\n      this.log_('Exception thrown from WebSocket.send():', e.message || e.data, 'Closing connection.');\n      setTimeout(this.onClosed_.bind(this), 0);\n    }\n  };\n  /**\n   * Number of response before we consider the connection \"healthy.\"\n   * @type {number}\n   */\n\n\n  WebSocketConnection.responsesRequiredToBeHealthy = 2;\n  /**\n   * Time to wait for the connection te become healthy before giving up.\n   * @type {number}\n   */\n\n  WebSocketConnection.healthyTimeout = 30000;\n  return WebSocketConnection;\n}();\n\nexports.WebSocketConnection = WebSocketConnection;","map":{"version":3,"sources":["../src/realtime/WebSocketConnection.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { RepoInfo } from '../core/RepoInfo';\n\ndeclare const MozWebSocket: any;\n\nimport firebase from '@firebase/app';\nimport { assert } from '@firebase/util';\nimport { logWrapper, splitStringBySize } from '../core/util/util';\nimport { StatsManager } from '../core/stats/StatsManager';\nimport {\n  FORGE_DOMAIN,\n  FORGE_REF,\n  LAST_SESSION_PARAM,\n  PROTOCOL_VERSION,\n  REFERER_PARAM,\n  TRANSPORT_SESSION_PARAM,\n  VERSION_PARAM,\n  WEBSOCKET\n} from './Constants';\nimport { CONSTANTS as ENV_CONSTANTS } from '@firebase/util';\nimport { PersistentStorage } from '../core/storage/storage';\nimport { jsonEval, stringify } from '@firebase/util';\nimport { isNodeSdk } from '@firebase/util';\nimport { Transport } from './Transport';\nimport { StatsCollection } from '../core/stats/StatsCollection';\n\nconst WEBSOCKET_MAX_FRAME_SIZE = 16384;\nconst WEBSOCKET_KEEPALIVE_INTERVAL = 45000;\n\nlet WebSocketImpl = null;\nif (typeof MozWebSocket !== 'undefined') {\n  WebSocketImpl = MozWebSocket;\n} else if (typeof WebSocket !== 'undefined') {\n  WebSocketImpl = WebSocket;\n}\n\nexport function setWebSocketImpl(impl) {\n  WebSocketImpl = impl;\n}\n\n/**\n * Create a new websocket connection with the given callbacks.\n * @constructor\n * @implements {Transport}\n */\nexport class WebSocketConnection implements Transport {\n  keepaliveTimer: number | null = null;\n  frames: string[] | null = null;\n  totalFrames = 0;\n  bytesSent = 0;\n  bytesReceived = 0;\n  connURL: string;\n  onDisconnect: (a?: boolean) => void;\n  onMessage: (msg: Object) => void;\n  mySock: any | null;\n  private log_: (...a: any[]) => void;\n  private stats_: StatsCollection;\n  private everConnected_: boolean;\n  private isClosed_: boolean;\n\n  /**\n   * @param {string} connId identifier for this transport\n   * @param {RepoInfo} repoInfo The info for the websocket endpoint.\n   * @param {string=} transportSessionId Optional transportSessionId if this is connecting to an existing transport\n   *                                         session\n   * @param {string=} lastSessionId Optional lastSessionId if there was a previous connection\n   */\n  constructor(\n    public connId: string,\n    repoInfo: RepoInfo,\n    transportSessionId?: string,\n    lastSessionId?: string\n  ) {\n    this.log_ = logWrapper(this.connId);\n    this.stats_ = StatsManager.getCollection(repoInfo);\n    this.connURL = WebSocketConnection.connectionURL_(\n      repoInfo,\n      transportSessionId,\n      lastSessionId\n    );\n  }\n\n  /**\n   * @param {RepoInfo} repoInfo The info for the websocket endpoint.\n   * @param {string=} transportSessionId Optional transportSessionId if this is connecting to an existing transport\n   *                                         session\n   * @param {string=} lastSessionId Optional lastSessionId if there was a previous connection\n   * @return {string} connection url\n   * @private\n   */\n  private static connectionURL_(\n    repoInfo: RepoInfo,\n    transportSessionId?: string,\n    lastSessionId?: string\n  ): string {\n    const urlParams: { [k: string]: string } = {};\n    urlParams[VERSION_PARAM] = PROTOCOL_VERSION;\n\n    if (\n      !isNodeSdk() &&\n      typeof location !== 'undefined' &&\n      location.href &&\n      location.href.indexOf(FORGE_DOMAIN) !== -1\n    ) {\n      urlParams[REFERER_PARAM] = FORGE_REF;\n    }\n    if (transportSessionId) {\n      urlParams[TRANSPORT_SESSION_PARAM] = transportSessionId;\n    }\n    if (lastSessionId) {\n      urlParams[LAST_SESSION_PARAM] = lastSessionId;\n    }\n    return repoInfo.connectionURL(WEBSOCKET, urlParams);\n  }\n\n  /**\n   *\n   * @param onMessage Callback when messages arrive\n   * @param onDisconnect Callback with connection lost.\n   */\n  open(onMessage: (msg: Object) => void, onDisconnect: (a?: boolean) => void) {\n    this.onDisconnect = onDisconnect;\n    this.onMessage = onMessage;\n\n    this.log_('Websocket connecting to ' + this.connURL);\n\n    this.everConnected_ = false;\n    // Assume failure until proven otherwise.\n    PersistentStorage.set('previous_websocket_failure', true);\n\n    try {\n      if (isNodeSdk()) {\n        const device = ENV_CONSTANTS.NODE_ADMIN ? 'AdminNode' : 'Node';\n        // UA Format: Firebase/<wire_protocol>/<sdk_version>/<platform>/<device>\n        const options: { [k: string]: object } = {\n          headers: {\n            'User-Agent': `Firebase/${PROTOCOL_VERSION}/${\n              firebase.SDK_VERSION\n            }/${process.platform}/${device}`\n          }\n        };\n\n        // Plumb appropriate http_proxy environment variable into faye-websocket if it exists.\n        const env = process['env'];\n        const proxy =\n          this.connURL.indexOf('wss://') == 0\n            ? env['HTTPS_PROXY'] || env['https_proxy']\n            : env['HTTP_PROXY'] || env['http_proxy'];\n\n        if (proxy) {\n          options['proxy'] = { origin: proxy };\n        }\n\n        this.mySock = new WebSocketImpl(this.connURL, [], options);\n      } else {\n        this.mySock = new WebSocketImpl(this.connURL);\n      }\n    } catch (e) {\n      this.log_('Error instantiating WebSocket.');\n      const error = e.message || e.data;\n      if (error) {\n        this.log_(error);\n      }\n      this.onClosed_();\n      return;\n    }\n\n    this.mySock.onopen = () => {\n      this.log_('Websocket connected.');\n      this.everConnected_ = true;\n    };\n\n    this.mySock.onclose = () => {\n      this.log_('Websocket connection was disconnected.');\n      this.mySock = null;\n      this.onClosed_();\n    };\n\n    this.mySock.onmessage = (m: object) => {\n      this.handleIncomingFrame(m);\n    };\n\n    this.mySock.onerror = (e: any) => {\n      this.log_('WebSocket error.  Closing connection.');\n      const error = e.message || e.data;\n      if (error) {\n        this.log_(error);\n      }\n      this.onClosed_();\n    };\n  }\n\n  /**\n   * No-op for websockets, we don't need to do anything once the connection is confirmed as open\n   */\n  start() {}\n\n  static forceDisallow_: Boolean;\n\n  static forceDisallow() {\n    WebSocketConnection.forceDisallow_ = true;\n  }\n\n  static isAvailable(): boolean {\n    let isOldAndroid = false;\n    if (typeof navigator !== 'undefined' && navigator.userAgent) {\n      const oldAndroidRegex = /Android ([0-9]{0,}\\.[0-9]{0,})/;\n      const oldAndroidMatch = navigator.userAgent.match(oldAndroidRegex);\n      if (oldAndroidMatch && oldAndroidMatch.length > 1) {\n        if (parseFloat(oldAndroidMatch[1]) < 4.4) {\n          isOldAndroid = true;\n        }\n      }\n    }\n\n    return (\n      !isOldAndroid &&\n      WebSocketImpl !== null &&\n      !WebSocketConnection.forceDisallow_\n    );\n  }\n\n  /**\n   * Number of response before we consider the connection \"healthy.\"\n   * @type {number}\n   */\n  static responsesRequiredToBeHealthy = 2;\n\n  /**\n   * Time to wait for the connection te become healthy before giving up.\n   * @type {number}\n   */\n  static healthyTimeout = 30000;\n\n  /**\n   * Returns true if we previously failed to connect with this transport.\n   * @return {boolean}\n   */\n  static previouslyFailed(): boolean {\n    // If our persistent storage is actually only in-memory storage,\n    // we default to assuming that it previously failed to be safe.\n    return (\n      PersistentStorage.isInMemoryStorage ||\n      PersistentStorage.get('previous_websocket_failure') === true\n    );\n  }\n\n  markConnectionHealthy() {\n    PersistentStorage.remove('previous_websocket_failure');\n  }\n\n  private appendFrame_(data: string) {\n    this.frames.push(data);\n    if (this.frames.length == this.totalFrames) {\n      const fullMess = this.frames.join('');\n      this.frames = null;\n      const jsonMess = jsonEval(fullMess);\n\n      //handle the message\n      this.onMessage(jsonMess);\n    }\n  }\n\n  /**\n   * @param {number} frameCount The number of frames we are expecting from the server\n   * @private\n   */\n  private handleNewFrameCount_(frameCount: number) {\n    this.totalFrames = frameCount;\n    this.frames = [];\n  }\n\n  /**\n   * Attempts to parse a frame count out of some text. If it can't, assumes a value of 1\n   * @param {!String} data\n   * @return {?String} Any remaining data to be process, or null if there is none\n   * @private\n   */\n  private extractFrameCount_(data: string): string | null {\n    assert(this.frames === null, 'We already have a frame buffer');\n    // TODO: The server is only supposed to send up to 9999 frames (i.e. length <= 4), but that isn't being enforced\n    // currently.  So allowing larger frame counts (length <= 6).  See https://app.asana.com/0/search/8688598998380/8237608042508\n    if (data.length <= 6) {\n      const frameCount = Number(data);\n      if (!isNaN(frameCount)) {\n        this.handleNewFrameCount_(frameCount);\n        return null;\n      }\n    }\n    this.handleNewFrameCount_(1);\n    return data;\n  }\n\n  /**\n   * Process a websocket frame that has arrived from the server.\n   * @param mess The frame data\n   */\n  handleIncomingFrame(mess: { [k: string]: any }) {\n    if (this.mySock === null) return; // Chrome apparently delivers incoming packets even after we .close() the connection sometimes.\n    const data = mess['data'] as string;\n    this.bytesReceived += data.length;\n    this.stats_.incrementCounter('bytes_received', data.length);\n\n    this.resetKeepAlive();\n\n    if (this.frames !== null) {\n      // we're buffering\n      this.appendFrame_(data);\n    } else {\n      // try to parse out a frame count, otherwise, assume 1 and process it\n      const remainingData = this.extractFrameCount_(data);\n      if (remainingData !== null) {\n        this.appendFrame_(remainingData);\n      }\n    }\n  }\n\n  /**\n   * Send a message to the server\n   * @param {Object} data The JSON object to transmit\n   */\n  send(data: Object) {\n    this.resetKeepAlive();\n\n    const dataStr = stringify(data);\n    this.bytesSent += dataStr.length;\n    this.stats_.incrementCounter('bytes_sent', dataStr.length);\n\n    //We can only fit a certain amount in each websocket frame, so we need to split this request\n    //up into multiple pieces if it doesn't fit in one request.\n\n    const dataSegs = splitStringBySize(dataStr, WEBSOCKET_MAX_FRAME_SIZE);\n\n    //Send the length header\n    if (dataSegs.length > 1) {\n      this.sendString_(String(dataSegs.length));\n    }\n\n    //Send the actual data in segments.\n    for (let i = 0; i < dataSegs.length; i++) {\n      this.sendString_(dataSegs[i]);\n    }\n  }\n\n  private shutdown_() {\n    this.isClosed_ = true;\n    if (this.keepaliveTimer) {\n      clearInterval(this.keepaliveTimer);\n      this.keepaliveTimer = null;\n    }\n\n    if (this.mySock) {\n      this.mySock.close();\n      this.mySock = null;\n    }\n  }\n\n  private onClosed_() {\n    if (!this.isClosed_) {\n      this.log_('WebSocket is closing itself');\n      this.shutdown_();\n\n      // since this is an internal close, trigger the close listener\n      if (this.onDisconnect) {\n        this.onDisconnect(this.everConnected_);\n        this.onDisconnect = null;\n      }\n    }\n  }\n\n  /**\n   * External-facing close handler.\n   * Close the websocket and kill the connection.\n   */\n  close() {\n    if (!this.isClosed_) {\n      this.log_('WebSocket is being closed');\n      this.shutdown_();\n    }\n  }\n\n  /**\n   * Kill the current keepalive timer and start a new one, to ensure that it always fires N seconds after\n   * the last activity.\n   */\n  resetKeepAlive() {\n    clearInterval(this.keepaliveTimer);\n    this.keepaliveTimer = setInterval(() => {\n      //If there has been no websocket activity for a while, send a no-op\n      if (this.mySock) {\n        this.sendString_('0');\n      }\n      this.resetKeepAlive();\n    }, Math.floor(WEBSOCKET_KEEPALIVE_INTERVAL)) as any;\n  }\n\n  /**\n   * Send a string over the websocket.\n   *\n   * @param {string} str String to send.\n   * @private\n   */\n  private sendString_(str: string) {\n    // Firefox seems to sometimes throw exceptions (NS_ERROR_UNEXPECTED) from websocket .send()\n    // calls for some unknown reason.  We treat these as an error and disconnect.\n    // See https://app.asana.com/0/58926111402292/68021340250410\n    try {\n      this.mySock.send(str);\n    } catch (e) {\n      this.log_(\n        'Exception thrown from WebSocket.send():',\n        e.message || e.data,\n        'Closing connection.'\n      );\n      setTimeout(this.onClosed_.bind(this), 0);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}