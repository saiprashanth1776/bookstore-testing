{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar util_1 = require(\"@firebase/util\");\n\nvar util_2 = require(\"./util/util\");\n\nvar AckUserWrite_1 = require(\"./operation/AckUserWrite\");\n\nvar ChildrenNode_1 = require(\"./snap/ChildrenNode\");\n\nvar util_3 = require(\"@firebase/util\");\n\nvar ImmutableTree_1 = require(\"./util/ImmutableTree\");\n\nvar ListenComplete_1 = require(\"./operation/ListenComplete\");\n\nvar Merge_1 = require(\"./operation/Merge\");\n\nvar Operation_1 = require(\"./operation/Operation\");\n\nvar Overwrite_1 = require(\"./operation/Overwrite\");\n\nvar Path_1 = require(\"./util/Path\");\n\nvar SyncPoint_1 = require(\"./SyncPoint\");\n\nvar WriteTree_1 = require(\"./WriteTree\");\n/**\n * SyncTree is the central class for managing event callback registration, data caching, views\n * (query processing), and event generation.  There are typically two SyncTree instances for\n * each Repo, one for the normal Firebase data, and one for the .info data.\n *\n * It has a number of responsibilities, including:\n *  - Tracking all user event callbacks (registered via addEventRegistration() and removeEventRegistration()).\n *  - Applying and caching data changes for user set(), transaction(), and update() calls\n *    (applyUserOverwrite(), applyUserMerge()).\n *  - Applying and caching data changes for server data changes (applyServerOverwrite(),\n *    applyServerMerge()).\n *  - Generating user-facing events for server and user changes (all of the apply* methods\n *    return the set of events that need to be raised as a result).\n *  - Maintaining the appropriate set of server listens to ensure we are always subscribed\n *    to the correct set of paths and queries to satisfy the current set of user event\n *    callbacks (listens are started/stopped using the provided listenProvider).\n *\n * NOTE: Although SyncTree tracks event callbacks and calculates events to raise, the actual\n * events are returned to the caller rather than raised synchronously.\n *\n * @constructor\n */\n\n\nvar SyncTree =\n/** @class */\nfunction () {\n  /**\n   * @param {!ListenProvider} listenProvider_ Used by SyncTree to start / stop listening\n   *   to server data.\n   */\n  function SyncTree(listenProvider_) {\n    this.listenProvider_ = listenProvider_;\n    /**\n     * Tree of SyncPoints.  There's a SyncPoint at any location that has 1 or more views.\n     * @type {!ImmutableTree.<!SyncPoint>}\n     * @private\n     */\n\n    this.syncPointTree_ = ImmutableTree_1.ImmutableTree.Empty;\n    /**\n     * A tree of all pending user writes (user-initiated set()'s, transaction()'s, update()'s, etc.).\n     * @type {!WriteTree}\n     * @private\n     */\n\n    this.pendingWriteTree_ = new WriteTree_1.WriteTree();\n    this.tagToQueryMap_ = {};\n    this.queryToTagMap_ = {};\n  }\n  /**\n   * Apply the data changes for a user-generated set() or transaction() call.\n   *\n   * @param {!Path} path\n   * @param {!Node} newData\n   * @param {number} writeId\n   * @param {boolean=} visible\n   * @return {!Array.<!Event>} Events to raise.\n   */\n\n\n  SyncTree.prototype.applyUserOverwrite = function (path, newData, writeId, visible) {\n    // Record pending write.\n    this.pendingWriteTree_.addOverwrite(path, newData, writeId, visible);\n\n    if (!visible) {\n      return [];\n    } else {\n      return this.applyOperationToSyncPoints_(new Overwrite_1.Overwrite(Operation_1.OperationSource.User, path, newData));\n    }\n  };\n  /**\n   * Apply the data from a user-generated update() call\n   *\n   * @param {!Path} path\n   * @param {!Object.<string, !Node>} changedChildren\n   * @param {!number} writeId\n   * @return {!Array.<!Event>} Events to raise.\n   */\n\n\n  SyncTree.prototype.applyUserMerge = function (path, changedChildren, writeId) {\n    // Record pending merge.\n    this.pendingWriteTree_.addMerge(path, changedChildren, writeId);\n    var changeTree = ImmutableTree_1.ImmutableTree.fromObject(changedChildren);\n    return this.applyOperationToSyncPoints_(new Merge_1.Merge(Operation_1.OperationSource.User, path, changeTree));\n  };\n  /**\n   * Acknowledge a pending user write that was previously registered with applyUserOverwrite() or applyUserMerge().\n   *\n   * @param {!number} writeId\n   * @param {boolean=} revert True if the given write failed and needs to be reverted\n   * @return {!Array.<!Event>} Events to raise.\n   */\n\n\n  SyncTree.prototype.ackUserWrite = function (writeId, revert) {\n    if (revert === void 0) {\n      revert = false;\n    }\n\n    var write = this.pendingWriteTree_.getWrite(writeId);\n    var needToReevaluate = this.pendingWriteTree_.removeWrite(writeId);\n\n    if (!needToReevaluate) {\n      return [];\n    } else {\n      var affectedTree_1 = ImmutableTree_1.ImmutableTree.Empty;\n\n      if (write.snap != null) {\n        // overwrite\n        affectedTree_1 = affectedTree_1.set(Path_1.Path.Empty, true);\n      } else {\n        util_3.forEach(write.children, function (pathString, node) {\n          affectedTree_1 = affectedTree_1.set(new Path_1.Path(pathString), node);\n        });\n      }\n\n      return this.applyOperationToSyncPoints_(new AckUserWrite_1.AckUserWrite(write.path, affectedTree_1, revert));\n    }\n  };\n  /**\n   * Apply new server data for the specified path..\n   *\n   * @param {!Path} path\n   * @param {!Node} newData\n   * @return {!Array.<!Event>} Events to raise.\n   */\n\n\n  SyncTree.prototype.applyServerOverwrite = function (path, newData) {\n    return this.applyOperationToSyncPoints_(new Overwrite_1.Overwrite(Operation_1.OperationSource.Server, path, newData));\n  };\n  /**\n   * Apply new server data to be merged in at the specified path.\n   *\n   * @param {!Path} path\n   * @param {!Object.<string, !Node>} changedChildren\n   * @return {!Array.<!Event>} Events to raise.\n   */\n\n\n  SyncTree.prototype.applyServerMerge = function (path, changedChildren) {\n    var changeTree = ImmutableTree_1.ImmutableTree.fromObject(changedChildren);\n    return this.applyOperationToSyncPoints_(new Merge_1.Merge(Operation_1.OperationSource.Server, path, changeTree));\n  };\n  /**\n   * Apply a listen complete for a query\n   *\n   * @param {!Path} path\n   * @return {!Array.<!Event>} Events to raise.\n   */\n\n\n  SyncTree.prototype.applyListenComplete = function (path) {\n    return this.applyOperationToSyncPoints_(new ListenComplete_1.ListenComplete(Operation_1.OperationSource.Server, path));\n  };\n  /**\n   * Apply new server data for the specified tagged query.\n   *\n   * @param {!Path} path\n   * @param {!Node} snap\n   * @param {!number} tag\n   * @return {!Array.<!Event>} Events to raise.\n   */\n\n\n  SyncTree.prototype.applyTaggedQueryOverwrite = function (path, snap, tag) {\n    var queryKey = this.queryKeyForTag_(tag);\n\n    if (queryKey != null) {\n      var r = SyncTree.parseQueryKey_(queryKey);\n      var queryPath = r.path,\n          queryId = r.queryId;\n      var relativePath = Path_1.Path.relativePath(queryPath, path);\n      var op = new Overwrite_1.Overwrite(Operation_1.OperationSource.forServerTaggedQuery(queryId), relativePath, snap);\n      return this.applyTaggedOperation_(queryPath, op);\n    } else {\n      // Query must have been removed already\n      return [];\n    }\n  };\n  /**\n   * Apply server data to be merged in for the specified tagged query.\n   *\n   * @param {!Path} path\n   * @param {!Object.<string, !Node>} changedChildren\n   * @param {!number} tag\n   * @return {!Array.<!Event>} Events to raise.\n   */\n\n\n  SyncTree.prototype.applyTaggedQueryMerge = function (path, changedChildren, tag) {\n    var queryKey = this.queryKeyForTag_(tag);\n\n    if (queryKey) {\n      var r = SyncTree.parseQueryKey_(queryKey);\n      var queryPath = r.path,\n          queryId = r.queryId;\n      var relativePath = Path_1.Path.relativePath(queryPath, path);\n      var changeTree = ImmutableTree_1.ImmutableTree.fromObject(changedChildren);\n      var op = new Merge_1.Merge(Operation_1.OperationSource.forServerTaggedQuery(queryId), relativePath, changeTree);\n      return this.applyTaggedOperation_(queryPath, op);\n    } else {\n      // We've already removed the query. No big deal, ignore the update\n      return [];\n    }\n  };\n  /**\n   * Apply a listen complete for a tagged query\n   *\n   * @param {!Path} path\n   * @param {!number} tag\n   * @return {!Array.<!Event>} Events to raise.\n   */\n\n\n  SyncTree.prototype.applyTaggedListenComplete = function (path, tag) {\n    var queryKey = this.queryKeyForTag_(tag);\n\n    if (queryKey) {\n      var r = SyncTree.parseQueryKey_(queryKey);\n      var queryPath = r.path,\n          queryId = r.queryId;\n      var relativePath = Path_1.Path.relativePath(queryPath, path);\n      var op = new ListenComplete_1.ListenComplete(Operation_1.OperationSource.forServerTaggedQuery(queryId), relativePath);\n      return this.applyTaggedOperation_(queryPath, op);\n    } else {\n      // We've already removed the query. No big deal, ignore the update\n      return [];\n    }\n  };\n  /**\n   * Add an event callback for the specified query.\n   *\n   * @param {!Query} query\n   * @param {!EventRegistration} eventRegistration\n   * @return {!Array.<!Event>} Events to raise.\n   */\n\n\n  SyncTree.prototype.addEventRegistration = function (query, eventRegistration) {\n    var path = query.path;\n    var serverCache = null;\n    var foundAncestorDefaultView = false; // Any covering writes will necessarily be at the root, so really all we need to find is the server cache.\n    // Consider optimizing this once there's a better understanding of what actual behavior will be.\n\n    this.syncPointTree_.foreachOnPath(path, function (pathToSyncPoint, sp) {\n      var relativePath = Path_1.Path.relativePath(pathToSyncPoint, path);\n      serverCache = serverCache || sp.getCompleteServerCache(relativePath);\n      foundAncestorDefaultView = foundAncestorDefaultView || sp.hasCompleteView();\n    });\n    var syncPoint = this.syncPointTree_.get(path);\n\n    if (!syncPoint) {\n      syncPoint = new SyncPoint_1.SyncPoint();\n      this.syncPointTree_ = this.syncPointTree_.set(path, syncPoint);\n    } else {\n      foundAncestorDefaultView = foundAncestorDefaultView || syncPoint.hasCompleteView();\n      serverCache = serverCache || syncPoint.getCompleteServerCache(Path_1.Path.Empty);\n    }\n\n    var serverCacheComplete;\n\n    if (serverCache != null) {\n      serverCacheComplete = true;\n    } else {\n      serverCacheComplete = false;\n      serverCache = ChildrenNode_1.ChildrenNode.EMPTY_NODE;\n      var subtree = this.syncPointTree_.subtree(path);\n      subtree.foreachChild(function (childName, childSyncPoint) {\n        var completeCache = childSyncPoint.getCompleteServerCache(Path_1.Path.Empty);\n\n        if (completeCache) {\n          serverCache = serverCache.updateImmediateChild(childName, completeCache);\n        }\n      });\n    }\n\n    var viewAlreadyExists = syncPoint.viewExistsForQuery(query);\n\n    if (!viewAlreadyExists && !query.getQueryParams().loadsAllData()) {\n      // We need to track a tag for this query\n      var queryKey = SyncTree.makeQueryKey_(query);\n      util_1.assert(!(queryKey in this.queryToTagMap_), 'View does not exist, but we have a tag');\n      var tag = SyncTree.getNextQueryTag_();\n      this.queryToTagMap_[queryKey] = tag; // Coerce to string to avoid sparse arrays.\n\n      this.tagToQueryMap_['_' + tag] = queryKey;\n    }\n\n    var writesCache = this.pendingWriteTree_.childWrites(path);\n    var events = syncPoint.addEventRegistration(query, eventRegistration, writesCache, serverCache, serverCacheComplete);\n\n    if (!viewAlreadyExists && !foundAncestorDefaultView) {\n      var view\n      /** @type !View */\n      = syncPoint.viewForQuery(query);\n      events = events.concat(this.setupListener_(query, view));\n    }\n\n    return events;\n  };\n  /**\n   * Remove event callback(s).\n   *\n   * If query is the default query, we'll check all queries for the specified eventRegistration.\n   * If eventRegistration is null, we'll remove all callbacks for the specified query/queries.\n   *\n   * @param {!Query} query\n   * @param {?EventRegistration} eventRegistration If null, all callbacks are removed.\n   * @param {Error=} cancelError If a cancelError is provided, appropriate cancel events will be returned.\n   * @return {!Array.<!Event>} Cancel events, if cancelError was provided.\n   */\n\n\n  SyncTree.prototype.removeEventRegistration = function (query, eventRegistration, cancelError) {\n    var _this = this; // Find the syncPoint first. Then deal with whether or not it has matching listeners\n\n\n    var path = query.path;\n    var maybeSyncPoint = this.syncPointTree_.get(path);\n    var cancelEvents = []; // A removal on a default query affects all queries at that location. A removal on an indexed query, even one without\n    // other query constraints, does *not* affect all queries at that location. So this check must be for 'default', and\n    // not loadsAllData().\n\n    if (maybeSyncPoint && (query.queryIdentifier() === 'default' || maybeSyncPoint.viewExistsForQuery(query))) {\n      /**\n       * @type {{removed: !Array.<!Query>, events: !Array.<!Event>}}\n       */\n      var removedAndEvents = maybeSyncPoint.removeEventRegistration(query, eventRegistration, cancelError);\n\n      if (maybeSyncPoint.isEmpty()) {\n        this.syncPointTree_ = this.syncPointTree_.remove(path);\n      }\n\n      var removed = removedAndEvents.removed;\n      cancelEvents = removedAndEvents.events; // We may have just removed one of many listeners and can short-circuit this whole process\n      // We may also not have removed a default listener, in which case all of the descendant listeners should already be\n      // properly set up.\n      //\n      // Since indexed queries can shadow if they don't have other query constraints, check for loadsAllData(), instead of\n      // queryId === 'default'\n\n      var removingDefault = -1 !== removed.findIndex(function (query) {\n        return query.getQueryParams().loadsAllData();\n      });\n      var covered = this.syncPointTree_.findOnPath(path, function (relativePath, parentSyncPoint) {\n        return parentSyncPoint.hasCompleteView();\n      });\n\n      if (removingDefault && !covered) {\n        var subtree = this.syncPointTree_.subtree(path); // There are potentially child listeners. Determine what if any listens we need to send before executing the\n        // removal\n\n        if (!subtree.isEmpty()) {\n          // We need to fold over our subtree and collect the listeners to send\n          var newViews = this.collectDistinctViewsForSubTree_(subtree); // Ok, we've collected all the listens we need. Set them up.\n\n          for (var i = 0; i < newViews.length; ++i) {\n            var view = newViews[i],\n                newQuery = view.getQuery();\n            var listener = this.createListenerForView_(view);\n            this.listenProvider_.startListening(SyncTree.queryForListening_(newQuery), this.tagForQuery_(newQuery), listener.hashFn, listener.onComplete);\n          }\n        } else {// There's nothing below us, so nothing we need to start listening on\n        }\n      } // If we removed anything and we're not covered by a higher up listen, we need to stop listening on this query\n      // The above block has us covered in terms of making sure we're set up on listens lower in the tree.\n      // Also, note that if we have a cancelError, it's already been removed at the provider level.\n\n\n      if (!covered && removed.length > 0 && !cancelError) {\n        // If we removed a default, then we weren't listening on any of the other queries here. Just cancel the one\n        // default. Otherwise, we need to iterate through and cancel each individual query\n        if (removingDefault) {\n          // We don't tag default listeners\n          var defaultTag = null;\n          this.listenProvider_.stopListening(SyncTree.queryForListening_(query), defaultTag);\n        } else {\n          removed.forEach(function (queryToRemove) {\n            var tagToRemove = _this.queryToTagMap_[SyncTree.makeQueryKey_(queryToRemove)];\n\n            _this.listenProvider_.stopListening(SyncTree.queryForListening_(queryToRemove), tagToRemove);\n          });\n        }\n      } // Now, clear all of the tags we're tracking for the removed listens\n\n\n      this.removeTags_(removed);\n    } else {// No-op, this listener must've been already removed\n    }\n\n    return cancelEvents;\n  };\n  /**\n   * Returns a complete cache, if we have one, of the data at a particular path. The location must have a listener above\n   * it, but as this is only used by transaction code, that should always be the case anyways.\n   *\n   * Note: this method will *include* hidden writes from transaction with applyLocally set to false.\n   * @param {!Path} path The path to the data we want\n   * @param {Array.<number>=} writeIdsToExclude A specific set to be excluded\n   * @return {?Node}\n   */\n\n\n  SyncTree.prototype.calcCompleteEventCache = function (path, writeIdsToExclude) {\n    var includeHiddenSets = true;\n    var writeTree = this.pendingWriteTree_;\n    var serverCache = this.syncPointTree_.findOnPath(path, function (pathSoFar, syncPoint) {\n      var relativePath = Path_1.Path.relativePath(pathSoFar, path);\n      var serverCache = syncPoint.getCompleteServerCache(relativePath);\n\n      if (serverCache) {\n        return serverCache;\n      }\n    });\n    return writeTree.calcCompleteEventCache(path, serverCache, writeIdsToExclude, includeHiddenSets);\n  };\n  /**\n   * This collapses multiple unfiltered views into a single view, since we only need a single\n   * listener for them.\n   *\n   * @param {!ImmutableTree.<!SyncPoint>} subtree\n   * @return {!Array.<!View>}\n   * @private\n   */\n\n\n  SyncTree.prototype.collectDistinctViewsForSubTree_ = function (subtree) {\n    return subtree.fold(function (relativePath, maybeChildSyncPoint, childMap) {\n      if (maybeChildSyncPoint && maybeChildSyncPoint.hasCompleteView()) {\n        var completeView = maybeChildSyncPoint.getCompleteView();\n        return [completeView];\n      } else {\n        // No complete view here, flatten any deeper listens into an array\n        var views_1 = [];\n\n        if (maybeChildSyncPoint) {\n          views_1 = maybeChildSyncPoint.getQueryViews();\n        }\n\n        util_3.forEach(childMap, function (key, childViews) {\n          views_1 = views_1.concat(childViews);\n        });\n        return views_1;\n      }\n    });\n  };\n  /**\n   * @param {!Array.<!Query>} queries\n   * @private\n   */\n\n\n  SyncTree.prototype.removeTags_ = function (queries) {\n    for (var j = 0; j < queries.length; ++j) {\n      var removedQuery = queries[j];\n\n      if (!removedQuery.getQueryParams().loadsAllData()) {\n        // We should have a tag for this\n        var removedQueryKey = SyncTree.makeQueryKey_(removedQuery);\n        var removedQueryTag = this.queryToTagMap_[removedQueryKey];\n        delete this.queryToTagMap_[removedQueryKey];\n        delete this.tagToQueryMap_['_' + removedQueryTag];\n      }\n    }\n  };\n  /**\n   * Normalizes a query to a query we send the server for listening\n   * @param {!Query} query\n   * @return {!Query} The normalized query\n   * @private\n   */\n\n\n  SyncTree.queryForListening_ = function (query) {\n    if (query.getQueryParams().loadsAllData() && !query.getQueryParams().isDefault()) {\n      // We treat queries that load all data as default queries\n      // Cast is necessary because ref() technically returns Firebase which is actually fb.api.Firebase which inherits\n      // from Query\n      return (\n        /** @type {!Query} */\n        query.getRef()\n      );\n    } else {\n      return query;\n    }\n  };\n  /**\n   * For a given new listen, manage the de-duplication of outstanding subscriptions.\n   *\n   * @param {!Query} query\n   * @param {!View} view\n   * @return {!Array.<!Event>} This method can return events to support synchronous data sources\n   * @private\n   */\n\n\n  SyncTree.prototype.setupListener_ = function (query, view) {\n    var path = query.path;\n    var tag = this.tagForQuery_(query);\n    var listener = this.createListenerForView_(view);\n    var events = this.listenProvider_.startListening(SyncTree.queryForListening_(query), tag, listener.hashFn, listener.onComplete);\n    var subtree = this.syncPointTree_.subtree(path); // The root of this subtree has our query. We're here because we definitely need to send a listen for that, but we\n    // may need to shadow other listens as well.\n\n    if (tag) {\n      util_1.assert(!subtree.value.hasCompleteView(), \"If we're adding a query, it shouldn't be shadowed\");\n    } else {\n      // Shadow everything at or below this location, this is a default listener.\n      var queriesToStop = subtree.fold(function (relativePath, maybeChildSyncPoint, childMap) {\n        if (!relativePath.isEmpty() && maybeChildSyncPoint && maybeChildSyncPoint.hasCompleteView()) {\n          return [maybeChildSyncPoint.getCompleteView().getQuery()];\n        } else {\n          // No default listener here, flatten any deeper queries into an array\n          var queries_1 = [];\n\n          if (maybeChildSyncPoint) {\n            queries_1 = queries_1.concat(maybeChildSyncPoint.getQueryViews().map(function (view) {\n              return view.getQuery();\n            }));\n          }\n\n          util_3.forEach(childMap, function (key, childQueries) {\n            queries_1 = queries_1.concat(childQueries);\n          });\n          return queries_1;\n        }\n      });\n\n      for (var i = 0; i < queriesToStop.length; ++i) {\n        var queryToStop = queriesToStop[i];\n        this.listenProvider_.stopListening(SyncTree.queryForListening_(queryToStop), this.tagForQuery_(queryToStop));\n      }\n    }\n\n    return events;\n  };\n  /**\n   *\n   * @param {!View} view\n   * @return {{hashFn: function(), onComplete: function(!string, *)}}\n   * @private\n   */\n\n\n  SyncTree.prototype.createListenerForView_ = function (view) {\n    var _this = this;\n\n    var query = view.getQuery();\n    var tag = this.tagForQuery_(query);\n    return {\n      hashFn: function () {\n        var cache = view.getServerCache() || ChildrenNode_1.ChildrenNode.EMPTY_NODE;\n        return cache.hash();\n      },\n      onComplete: function (status) {\n        if (status === 'ok') {\n          if (tag) {\n            return _this.applyTaggedListenComplete(query.path, tag);\n          } else {\n            return _this.applyListenComplete(query.path);\n          }\n        } else {\n          // If a listen failed, kill all of the listeners here, not just the one that triggered the error.\n          // Note that this may need to be scoped to just this listener if we change permissions on filtered children\n          var error = util_2.errorForServerCode(status, query);\n          return _this.removeEventRegistration(query,\n          /*eventRegistration*/\n          null, error);\n        }\n      }\n    };\n  };\n  /**\n   * Given a query, computes a \"queryKey\" suitable for use in our queryToTagMap_.\n   * @private\n   * @param {!Query} query\n   * @return {string}\n   */\n\n\n  SyncTree.makeQueryKey_ = function (query) {\n    return query.path.toString() + '$' + query.queryIdentifier();\n  };\n  /**\n   * Given a queryKey (created by makeQueryKey), parse it back into a path and queryId.\n   * @private\n   * @param {!string} queryKey\n   * @return {{queryId: !string, path: !Path}}\n   */\n\n\n  SyncTree.parseQueryKey_ = function (queryKey) {\n    var splitIndex = queryKey.indexOf('$');\n    util_1.assert(splitIndex !== -1 && splitIndex < queryKey.length - 1, 'Bad queryKey.');\n    return {\n      queryId: queryKey.substr(splitIndex + 1),\n      path: new Path_1.Path(queryKey.substr(0, splitIndex))\n    };\n  };\n  /**\n   * Return the query associated with the given tag, if we have one\n   * @param {!number} tag\n   * @return {?string}\n   * @private\n   */\n\n\n  SyncTree.prototype.queryKeyForTag_ = function (tag) {\n    return this.tagToQueryMap_['_' + tag];\n  };\n  /**\n   * Return the tag associated with the given query.\n   * @param {!Query} query\n   * @return {?number}\n   * @private\n   */\n\n\n  SyncTree.prototype.tagForQuery_ = function (query) {\n    var queryKey = SyncTree.makeQueryKey_(query);\n    return util_3.safeGet(this.queryToTagMap_, queryKey);\n  };\n  /**\n   * Static accessor for query tags.\n   * @return {number}\n   * @private\n   */\n\n\n  SyncTree.getNextQueryTag_ = function () {\n    return SyncTree.nextQueryTag_++;\n  };\n  /**\n   * A helper method to apply tagged operations\n   *\n   * @param {!Path} queryPath\n   * @param {!Operation} operation\n   * @return {!Array.<!Event>}\n   * @private\n   */\n\n\n  SyncTree.prototype.applyTaggedOperation_ = function (queryPath, operation) {\n    var syncPoint = this.syncPointTree_.get(queryPath);\n    util_1.assert(syncPoint, \"Missing sync point for query tag that we're tracking\");\n    var writesCache = this.pendingWriteTree_.childWrites(queryPath);\n    return syncPoint.applyOperation(operation, writesCache,\n    /*serverCache=*/\n    null);\n  };\n  /**\n   * A helper method that visits all descendant and ancestor SyncPoints, applying the operation.\n   *\n   * NOTES:\n   * - Descendant SyncPoints will be visited first (since we raise events depth-first).\n      * - We call applyOperation() on each SyncPoint passing three things:\n   *   1. A version of the Operation that has been made relative to the SyncPoint location.\n   *   2. A WriteTreeRef of any writes we have cached at the SyncPoint location.\n   *   3. A snapshot Node with cached server data, if we have it.\n      * - We concatenate all of the events returned by each SyncPoint and return the result.\n   *\n   * @param {!Operation} operation\n   * @return {!Array.<!Event>}\n   * @private\n   */\n\n\n  SyncTree.prototype.applyOperationToSyncPoints_ = function (operation) {\n    return this.applyOperationHelper_(operation, this.syncPointTree_,\n    /*serverCache=*/\n    null, this.pendingWriteTree_.childWrites(Path_1.Path.Empty));\n  };\n  /**\n   * Recursive helper for applyOperationToSyncPoints_\n   *\n   * @private\n   * @param {!Operation} operation\n   * @param {ImmutableTree.<!SyncPoint>} syncPointTree\n   * @param {?Node} serverCache\n   * @param {!WriteTreeRef} writesCache\n   * @return {!Array.<!Event>}\n   */\n\n\n  SyncTree.prototype.applyOperationHelper_ = function (operation, syncPointTree, serverCache, writesCache) {\n    if (operation.path.isEmpty()) {\n      return this.applyOperationDescendantsHelper_(operation, syncPointTree, serverCache, writesCache);\n    } else {\n      var syncPoint = syncPointTree.get(Path_1.Path.Empty); // If we don't have cached server data, see if we can get it from this SyncPoint.\n\n      if (serverCache == null && syncPoint != null) {\n        serverCache = syncPoint.getCompleteServerCache(Path_1.Path.Empty);\n      }\n\n      var events = [];\n      var childName = operation.path.getFront();\n      var childOperation = operation.operationForChild(childName);\n      var childTree = syncPointTree.children.get(childName);\n\n      if (childTree && childOperation) {\n        var childServerCache = serverCache ? serverCache.getImmediateChild(childName) : null;\n        var childWritesCache = writesCache.child(childName);\n        events = events.concat(this.applyOperationHelper_(childOperation, childTree, childServerCache, childWritesCache));\n      }\n\n      if (syncPoint) {\n        events = events.concat(syncPoint.applyOperation(operation, writesCache, serverCache));\n      }\n\n      return events;\n    }\n  };\n  /**\n   * Recursive helper for applyOperationToSyncPoints_\n   *\n   * @private\n   * @param {!Operation} operation\n   * @param {ImmutableTree.<!SyncPoint>} syncPointTree\n   * @param {?Node} serverCache\n   * @param {!WriteTreeRef} writesCache\n   * @return {!Array.<!Event>}\n   */\n\n\n  SyncTree.prototype.applyOperationDescendantsHelper_ = function (operation, syncPointTree, serverCache, writesCache) {\n    var _this = this;\n\n    var syncPoint = syncPointTree.get(Path_1.Path.Empty); // If we don't have cached server data, see if we can get it from this SyncPoint.\n\n    if (serverCache == null && syncPoint != null) {\n      serverCache = syncPoint.getCompleteServerCache(Path_1.Path.Empty);\n    }\n\n    var events = [];\n    syncPointTree.children.inorderTraversal(function (childName, childTree) {\n      var childServerCache = serverCache ? serverCache.getImmediateChild(childName) : null;\n      var childWritesCache = writesCache.child(childName);\n      var childOperation = operation.operationForChild(childName);\n\n      if (childOperation) {\n        events = events.concat(_this.applyOperationDescendantsHelper_(childOperation, childTree, childServerCache, childWritesCache));\n      }\n    });\n\n    if (syncPoint) {\n      events = events.concat(syncPoint.applyOperation(operation, writesCache, serverCache));\n    }\n\n    return events;\n  };\n  /**\n   * Static tracker for next query tag.\n   * @type {number}\n   * @private\n   */\n\n\n  SyncTree.nextQueryTag_ = 1;\n  return SyncTree;\n}();\n\nexports.SyncTree = SyncTree;","map":{"version":3,"sources":["../src/core/SyncTree.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert } from '@firebase/util';\nimport { errorForServerCode } from './util/util';\nimport { AckUserWrite } from './operation/AckUserWrite';\nimport { ChildrenNode } from './snap/ChildrenNode';\nimport { forEach, safeGet } from '@firebase/util';\nimport { ImmutableTree } from './util/ImmutableTree';\nimport { ListenComplete } from './operation/ListenComplete';\nimport { Merge } from './operation/Merge';\nimport { Operation, OperationSource } from './operation/Operation';\nimport { Overwrite } from './operation/Overwrite';\nimport { Path } from './util/Path';\nimport { SyncPoint } from './SyncPoint';\nimport { WriteTree, WriteTreeRef } from './WriteTree';\nimport { Query } from '../api/Query';\nimport { Node } from './snap/Node';\nimport { Event } from './view/Event';\nimport { EventRegistration } from './view/EventRegistration';\nimport { View } from './view/View';\n\n/**\n * @typedef {{\n *   startListening: function(\n *     !Query,\n *     ?number,\n *     function():string,\n *     function(!string, *):!Array.<!Event>\n *   ):!Array.<!Event>,\n *\n *   stopListening: function(!Query, ?number)\n * }}\n */\nexport interface ListenProvider {\n  startListening(\n    query: Query,\n    tag: number | null,\n    hashFn: () => string,\n    onComplete: (a: string, b?: any) => Event[]\n  ): Event[];\n\n  stopListening(a: Query, b: number | null): void;\n}\n\n/**\n * SyncTree is the central class for managing event callback registration, data caching, views\n * (query processing), and event generation.  There are typically two SyncTree instances for\n * each Repo, one for the normal Firebase data, and one for the .info data.\n *\n * It has a number of responsibilities, including:\n *  - Tracking all user event callbacks (registered via addEventRegistration() and removeEventRegistration()).\n *  - Applying and caching data changes for user set(), transaction(), and update() calls\n *    (applyUserOverwrite(), applyUserMerge()).\n *  - Applying and caching data changes for server data changes (applyServerOverwrite(),\n *    applyServerMerge()).\n *  - Generating user-facing events for server and user changes (all of the apply* methods\n *    return the set of events that need to be raised as a result).\n *  - Maintaining the appropriate set of server listens to ensure we are always subscribed\n *    to the correct set of paths and queries to satisfy the current set of user event\n *    callbacks (listens are started/stopped using the provided listenProvider).\n *\n * NOTE: Although SyncTree tracks event callbacks and calculates events to raise, the actual\n * events are returned to the caller rather than raised synchronously.\n *\n * @constructor\n */\nexport class SyncTree {\n  /**\n   * Tree of SyncPoints.  There's a SyncPoint at any location that has 1 or more views.\n   * @type {!ImmutableTree.<!SyncPoint>}\n   * @private\n   */\n  private syncPointTree_: ImmutableTree<SyncPoint> = ImmutableTree.Empty;\n\n  /**\n   * A tree of all pending user writes (user-initiated set()'s, transaction()'s, update()'s, etc.).\n   * @type {!WriteTree}\n   * @private\n   */\n  private pendingWriteTree_ = new WriteTree();\n\n  private tagToQueryMap_: { [k: string]: string } = {};\n  private queryToTagMap_: { [k: string]: number } = {};\n\n  /**\n   * @param {!ListenProvider} listenProvider_ Used by SyncTree to start / stop listening\n   *   to server data.\n   */\n  constructor(private listenProvider_: ListenProvider) {}\n\n  /**\n   * Apply the data changes for a user-generated set() or transaction() call.\n   *\n   * @param {!Path} path\n   * @param {!Node} newData\n   * @param {number} writeId\n   * @param {boolean=} visible\n   * @return {!Array.<!Event>} Events to raise.\n   */\n  applyUserOverwrite(\n    path: Path,\n    newData: Node,\n    writeId: number,\n    visible?: boolean\n  ): Event[] {\n    // Record pending write.\n    this.pendingWriteTree_.addOverwrite(path, newData, writeId, visible);\n\n    if (!visible) {\n      return [];\n    } else {\n      return this.applyOperationToSyncPoints_(\n        new Overwrite(OperationSource.User, path, newData)\n      );\n    }\n  }\n\n  /**\n   * Apply the data from a user-generated update() call\n   *\n   * @param {!Path} path\n   * @param {!Object.<string, !Node>} changedChildren\n   * @param {!number} writeId\n   * @return {!Array.<!Event>} Events to raise.\n   */\n  applyUserMerge(\n    path: Path,\n    changedChildren: { [k: string]: Node },\n    writeId: number\n  ): Event[] {\n    // Record pending merge.\n    this.pendingWriteTree_.addMerge(path, changedChildren, writeId);\n\n    const changeTree = ImmutableTree.fromObject(changedChildren);\n\n    return this.applyOperationToSyncPoints_(\n      new Merge(OperationSource.User, path, changeTree)\n    );\n  }\n\n  /**\n   * Acknowledge a pending user write that was previously registered with applyUserOverwrite() or applyUserMerge().\n   *\n   * @param {!number} writeId\n   * @param {boolean=} revert True if the given write failed and needs to be reverted\n   * @return {!Array.<!Event>} Events to raise.\n   */\n  ackUserWrite(writeId: number, revert: boolean = false) {\n    const write = this.pendingWriteTree_.getWrite(writeId);\n    const needToReevaluate = this.pendingWriteTree_.removeWrite(writeId);\n    if (!needToReevaluate) {\n      return [];\n    } else {\n      let affectedTree = ImmutableTree.Empty;\n      if (write.snap != null) {\n        // overwrite\n        affectedTree = affectedTree.set(Path.Empty, true);\n      } else {\n        forEach(write.children, function(pathString: string, node: Node) {\n          affectedTree = affectedTree.set(new Path(pathString), node);\n        });\n      }\n      return this.applyOperationToSyncPoints_(\n        new AckUserWrite(write.path, affectedTree, revert)\n      );\n    }\n  }\n\n  /**\n   * Apply new server data for the specified path..\n   *\n   * @param {!Path} path\n   * @param {!Node} newData\n   * @return {!Array.<!Event>} Events to raise.\n   */\n  applyServerOverwrite(path: Path, newData: Node): Event[] {\n    return this.applyOperationToSyncPoints_(\n      new Overwrite(OperationSource.Server, path, newData)\n    );\n  }\n\n  /**\n   * Apply new server data to be merged in at the specified path.\n   *\n   * @param {!Path} path\n   * @param {!Object.<string, !Node>} changedChildren\n   * @return {!Array.<!Event>} Events to raise.\n   */\n  applyServerMerge(\n    path: Path,\n    changedChildren: { [k: string]: Node }\n  ): Event[] {\n    const changeTree = ImmutableTree.fromObject(changedChildren);\n\n    return this.applyOperationToSyncPoints_(\n      new Merge(OperationSource.Server, path, changeTree)\n    );\n  }\n\n  /**\n   * Apply a listen complete for a query\n   *\n   * @param {!Path} path\n   * @return {!Array.<!Event>} Events to raise.\n   */\n  applyListenComplete(path: Path): Event[] {\n    return this.applyOperationToSyncPoints_(\n      new ListenComplete(OperationSource.Server, path)\n    );\n  }\n\n  /**\n   * Apply new server data for the specified tagged query.\n   *\n   * @param {!Path} path\n   * @param {!Node} snap\n   * @param {!number} tag\n   * @return {!Array.<!Event>} Events to raise.\n   */\n  applyTaggedQueryOverwrite(path: Path, snap: Node, tag: number): Event[] {\n    const queryKey = this.queryKeyForTag_(tag);\n    if (queryKey != null) {\n      const r = SyncTree.parseQueryKey_(queryKey);\n      const queryPath = r.path,\n        queryId = r.queryId;\n      const relativePath = Path.relativePath(queryPath, path);\n      const op = new Overwrite(\n        OperationSource.forServerTaggedQuery(queryId),\n        relativePath,\n        snap\n      );\n      return this.applyTaggedOperation_(queryPath, op);\n    } else {\n      // Query must have been removed already\n      return [];\n    }\n  }\n\n  /**\n   * Apply server data to be merged in for the specified tagged query.\n   *\n   * @param {!Path} path\n   * @param {!Object.<string, !Node>} changedChildren\n   * @param {!number} tag\n   * @return {!Array.<!Event>} Events to raise.\n   */\n  applyTaggedQueryMerge(\n    path: Path,\n    changedChildren: { [k: string]: Node },\n    tag: number\n  ): Event[] {\n    const queryKey = this.queryKeyForTag_(tag);\n    if (queryKey) {\n      const r = SyncTree.parseQueryKey_(queryKey);\n      const queryPath = r.path,\n        queryId = r.queryId;\n      const relativePath = Path.relativePath(queryPath, path);\n      const changeTree = ImmutableTree.fromObject(changedChildren);\n      const op = new Merge(\n        OperationSource.forServerTaggedQuery(queryId),\n        relativePath,\n        changeTree\n      );\n      return this.applyTaggedOperation_(queryPath, op);\n    } else {\n      // We've already removed the query. No big deal, ignore the update\n      return [];\n    }\n  }\n\n  /**\n   * Apply a listen complete for a tagged query\n   *\n   * @param {!Path} path\n   * @param {!number} tag\n   * @return {!Array.<!Event>} Events to raise.\n   */\n  applyTaggedListenComplete(path: Path, tag: number): Event[] {\n    const queryKey = this.queryKeyForTag_(tag);\n    if (queryKey) {\n      const r = SyncTree.parseQueryKey_(queryKey);\n      const queryPath = r.path,\n        queryId = r.queryId;\n      const relativePath = Path.relativePath(queryPath, path);\n      const op = new ListenComplete(\n        OperationSource.forServerTaggedQuery(queryId),\n        relativePath\n      );\n      return this.applyTaggedOperation_(queryPath, op);\n    } else {\n      // We've already removed the query. No big deal, ignore the update\n      return [];\n    }\n  }\n\n  /**\n   * Add an event callback for the specified query.\n   *\n   * @param {!Query} query\n   * @param {!EventRegistration} eventRegistration\n   * @return {!Array.<!Event>} Events to raise.\n   */\n  addEventRegistration(\n    query: Query,\n    eventRegistration: EventRegistration\n  ): Event[] {\n    const path = query.path;\n\n    let serverCache: Node | null = null;\n    let foundAncestorDefaultView = false;\n    // Any covering writes will necessarily be at the root, so really all we need to find is the server cache.\n    // Consider optimizing this once there's a better understanding of what actual behavior will be.\n    this.syncPointTree_.foreachOnPath(path, function(pathToSyncPoint, sp) {\n      const relativePath = Path.relativePath(pathToSyncPoint, path);\n      serverCache = serverCache || sp.getCompleteServerCache(relativePath);\n      foundAncestorDefaultView =\n        foundAncestorDefaultView || sp.hasCompleteView();\n    });\n    let syncPoint = this.syncPointTree_.get(path);\n    if (!syncPoint) {\n      syncPoint = new SyncPoint();\n      this.syncPointTree_ = this.syncPointTree_.set(path, syncPoint);\n    } else {\n      foundAncestorDefaultView =\n        foundAncestorDefaultView || syncPoint.hasCompleteView();\n      serverCache = serverCache || syncPoint.getCompleteServerCache(Path.Empty);\n    }\n\n    let serverCacheComplete;\n    if (serverCache != null) {\n      serverCacheComplete = true;\n    } else {\n      serverCacheComplete = false;\n      serverCache = ChildrenNode.EMPTY_NODE;\n      const subtree = this.syncPointTree_.subtree(path);\n      subtree.foreachChild(function(childName, childSyncPoint) {\n        const completeCache = childSyncPoint.getCompleteServerCache(Path.Empty);\n        if (completeCache) {\n          serverCache = serverCache.updateImmediateChild(\n            childName,\n            completeCache\n          );\n        }\n      });\n    }\n\n    const viewAlreadyExists = syncPoint.viewExistsForQuery(query);\n    if (!viewAlreadyExists && !query.getQueryParams().loadsAllData()) {\n      // We need to track a tag for this query\n      const queryKey = SyncTree.makeQueryKey_(query);\n      assert(\n        !(queryKey in this.queryToTagMap_),\n        'View does not exist, but we have a tag'\n      );\n      const tag = SyncTree.getNextQueryTag_();\n      this.queryToTagMap_[queryKey] = tag;\n      // Coerce to string to avoid sparse arrays.\n      this.tagToQueryMap_['_' + tag] = queryKey;\n    }\n    const writesCache = this.pendingWriteTree_.childWrites(path);\n    let events = syncPoint.addEventRegistration(\n      query,\n      eventRegistration,\n      writesCache,\n      serverCache,\n      serverCacheComplete\n    );\n    if (!viewAlreadyExists && !foundAncestorDefaultView) {\n      const view /** @type !View */ = syncPoint.viewForQuery(query);\n      events = events.concat(this.setupListener_(query, view));\n    }\n    return events;\n  }\n\n  /**\n   * Remove event callback(s).\n   *\n   * If query is the default query, we'll check all queries for the specified eventRegistration.\n   * If eventRegistration is null, we'll remove all callbacks for the specified query/queries.\n   *\n   * @param {!Query} query\n   * @param {?EventRegistration} eventRegistration If null, all callbacks are removed.\n   * @param {Error=} cancelError If a cancelError is provided, appropriate cancel events will be returned.\n   * @return {!Array.<!Event>} Cancel events, if cancelError was provided.\n   */\n  removeEventRegistration(\n    query: Query,\n    eventRegistration: EventRegistration | null,\n    cancelError?: Error\n  ): Event[] {\n    // Find the syncPoint first. Then deal with whether or not it has matching listeners\n    const path = query.path;\n    const maybeSyncPoint = this.syncPointTree_.get(path);\n    let cancelEvents: Event[] = [];\n    // A removal on a default query affects all queries at that location. A removal on an indexed query, even one without\n    // other query constraints, does *not* affect all queries at that location. So this check must be for 'default', and\n    // not loadsAllData().\n    if (\n      maybeSyncPoint &&\n      (query.queryIdentifier() === 'default' ||\n        maybeSyncPoint.viewExistsForQuery(query))\n    ) {\n      /**\n       * @type {{removed: !Array.<!Query>, events: !Array.<!Event>}}\n       */\n      const removedAndEvents = maybeSyncPoint.removeEventRegistration(\n        query,\n        eventRegistration,\n        cancelError\n      );\n      if (maybeSyncPoint.isEmpty()) {\n        this.syncPointTree_ = this.syncPointTree_.remove(path);\n      }\n      const removed = removedAndEvents.removed;\n      cancelEvents = removedAndEvents.events;\n      // We may have just removed one of many listeners and can short-circuit this whole process\n      // We may also not have removed a default listener, in which case all of the descendant listeners should already be\n      // properly set up.\n      //\n      // Since indexed queries can shadow if they don't have other query constraints, check for loadsAllData(), instead of\n      // queryId === 'default'\n      const removingDefault =\n        -1 !==\n        removed.findIndex(function(query) {\n          return query.getQueryParams().loadsAllData();\n        });\n      const covered = this.syncPointTree_.findOnPath(path, function(\n        relativePath,\n        parentSyncPoint\n      ) {\n        return parentSyncPoint.hasCompleteView();\n      });\n\n      if (removingDefault && !covered) {\n        const subtree = this.syncPointTree_.subtree(path);\n        // There are potentially child listeners. Determine what if any listens we need to send before executing the\n        // removal\n        if (!subtree.isEmpty()) {\n          // We need to fold over our subtree and collect the listeners to send\n          const newViews = this.collectDistinctViewsForSubTree_(subtree);\n\n          // Ok, we've collected all the listens we need. Set them up.\n          for (let i = 0; i < newViews.length; ++i) {\n            const view = newViews[i],\n              newQuery = view.getQuery();\n            const listener = this.createListenerForView_(view);\n            this.listenProvider_.startListening(\n              SyncTree.queryForListening_(newQuery),\n              this.tagForQuery_(newQuery),\n              listener.hashFn,\n              listener.onComplete\n            );\n          }\n        } else {\n          // There's nothing below us, so nothing we need to start listening on\n        }\n      }\n      // If we removed anything and we're not covered by a higher up listen, we need to stop listening on this query\n      // The above block has us covered in terms of making sure we're set up on listens lower in the tree.\n      // Also, note that if we have a cancelError, it's already been removed at the provider level.\n      if (!covered && removed.length > 0 && !cancelError) {\n        // If we removed a default, then we weren't listening on any of the other queries here. Just cancel the one\n        // default. Otherwise, we need to iterate through and cancel each individual query\n        if (removingDefault) {\n          // We don't tag default listeners\n          const defaultTag: number | null = null;\n          this.listenProvider_.stopListening(\n            SyncTree.queryForListening_(query),\n            defaultTag\n          );\n        } else {\n          removed.forEach((queryToRemove: Query) => {\n            const tagToRemove = this.queryToTagMap_[\n              SyncTree.makeQueryKey_(queryToRemove)\n            ];\n            this.listenProvider_.stopListening(\n              SyncTree.queryForListening_(queryToRemove),\n              tagToRemove\n            );\n          });\n        }\n      }\n      // Now, clear all of the tags we're tracking for the removed listens\n      this.removeTags_(removed);\n    } else {\n      // No-op, this listener must've been already removed\n    }\n    return cancelEvents;\n  }\n\n  /**\n   * Returns a complete cache, if we have one, of the data at a particular path. The location must have a listener above\n   * it, but as this is only used by transaction code, that should always be the case anyways.\n   *\n   * Note: this method will *include* hidden writes from transaction with applyLocally set to false.\n   * @param {!Path} path The path to the data we want\n   * @param {Array.<number>=} writeIdsToExclude A specific set to be excluded\n   * @return {?Node}\n   */\n  calcCompleteEventCache(\n    path: Path,\n    writeIdsToExclude?: number[]\n  ): Node | null {\n    const includeHiddenSets = true;\n    const writeTree = this.pendingWriteTree_;\n    const serverCache = this.syncPointTree_.findOnPath(path, function(\n      pathSoFar,\n      syncPoint\n    ) {\n      const relativePath = Path.relativePath(pathSoFar, path);\n      const serverCache = syncPoint.getCompleteServerCache(relativePath);\n      if (serverCache) {\n        return serverCache;\n      }\n    });\n    return writeTree.calcCompleteEventCache(\n      path,\n      serverCache,\n      writeIdsToExclude,\n      includeHiddenSets\n    );\n  }\n\n  /**\n   * This collapses multiple unfiltered views into a single view, since we only need a single\n   * listener for them.\n   *\n   * @param {!ImmutableTree.<!SyncPoint>} subtree\n   * @return {!Array.<!View>}\n   * @private\n   */\n  private collectDistinctViewsForSubTree_(\n    subtree: ImmutableTree<SyncPoint>\n  ): View[] {\n    return subtree.fold<View[]>(\n      (relativePath, maybeChildSyncPoint, childMap) => {\n        if (maybeChildSyncPoint && maybeChildSyncPoint.hasCompleteView()) {\n          const completeView = maybeChildSyncPoint.getCompleteView();\n          return [completeView];\n        } else {\n          // No complete view here, flatten any deeper listens into an array\n          let views: View[] = [];\n          if (maybeChildSyncPoint) {\n            views = maybeChildSyncPoint.getQueryViews();\n          }\n          forEach(childMap, function(key: string, childViews: View[]) {\n            views = views.concat(childViews);\n          });\n          return views;\n        }\n      }\n    );\n  }\n\n  /**\n   * @param {!Array.<!Query>} queries\n   * @private\n   */\n  private removeTags_(queries: Query[]) {\n    for (let j = 0; j < queries.length; ++j) {\n      const removedQuery = queries[j];\n      if (!removedQuery.getQueryParams().loadsAllData()) {\n        // We should have a tag for this\n        const removedQueryKey = SyncTree.makeQueryKey_(removedQuery);\n        const removedQueryTag = this.queryToTagMap_[removedQueryKey];\n        delete this.queryToTagMap_[removedQueryKey];\n        delete this.tagToQueryMap_['_' + removedQueryTag];\n      }\n    }\n  }\n\n  /**\n   * Normalizes a query to a query we send the server for listening\n   * @param {!Query} query\n   * @return {!Query} The normalized query\n   * @private\n   */\n  private static queryForListening_(query: Query): Query {\n    if (\n      query.getQueryParams().loadsAllData() &&\n      !query.getQueryParams().isDefault()\n    ) {\n      // We treat queries that load all data as default queries\n      // Cast is necessary because ref() technically returns Firebase which is actually fb.api.Firebase which inherits\n      // from Query\n      return /** @type {!Query} */ query.getRef();\n    } else {\n      return query;\n    }\n  }\n\n  /**\n   * For a given new listen, manage the de-duplication of outstanding subscriptions.\n   *\n   * @param {!Query} query\n   * @param {!View} view\n   * @return {!Array.<!Event>} This method can return events to support synchronous data sources\n   * @private\n   */\n  private setupListener_(query: Query, view: View): Event[] {\n    const path = query.path;\n    const tag = this.tagForQuery_(query);\n    const listener = this.createListenerForView_(view);\n\n    const events = this.listenProvider_.startListening(\n      SyncTree.queryForListening_(query),\n      tag,\n      listener.hashFn,\n      listener.onComplete\n    );\n\n    const subtree = this.syncPointTree_.subtree(path);\n    // The root of this subtree has our query. We're here because we definitely need to send a listen for that, but we\n    // may need to shadow other listens as well.\n    if (tag) {\n      assert(\n        !subtree.value.hasCompleteView(),\n        \"If we're adding a query, it shouldn't be shadowed\"\n      );\n    } else {\n      // Shadow everything at or below this location, this is a default listener.\n      const queriesToStop = subtree.fold<Query[]>(function(\n        relativePath,\n        maybeChildSyncPoint,\n        childMap\n      ) {\n        if (\n          !relativePath.isEmpty() &&\n          maybeChildSyncPoint &&\n          maybeChildSyncPoint.hasCompleteView()\n        ) {\n          return [maybeChildSyncPoint.getCompleteView().getQuery()];\n        } else {\n          // No default listener here, flatten any deeper queries into an array\n          let queries: Query[] = [];\n          if (maybeChildSyncPoint) {\n            queries = queries.concat(\n              maybeChildSyncPoint.getQueryViews().map(view => view.getQuery())\n            );\n          }\n          forEach(childMap, function(key: string, childQueries: Query[]) {\n            queries = queries.concat(childQueries);\n          });\n          return queries;\n        }\n      });\n      for (let i = 0; i < queriesToStop.length; ++i) {\n        const queryToStop = queriesToStop[i];\n        this.listenProvider_.stopListening(\n          SyncTree.queryForListening_(queryToStop),\n          this.tagForQuery_(queryToStop)\n        );\n      }\n    }\n    return events;\n  }\n\n  /**\n   *\n   * @param {!View} view\n   * @return {{hashFn: function(), onComplete: function(!string, *)}}\n   * @private\n   */\n  private createListenerForView_(\n    view: View\n  ): { hashFn(): string; onComplete(a: string, b?: any): Event[] } {\n    const query = view.getQuery();\n    const tag = this.tagForQuery_(query);\n\n    return {\n      hashFn: () => {\n        const cache = view.getServerCache() || ChildrenNode.EMPTY_NODE;\n        return cache.hash();\n      },\n      onComplete: (status: string): Event[] => {\n        if (status === 'ok') {\n          if (tag) {\n            return this.applyTaggedListenComplete(query.path, tag);\n          } else {\n            return this.applyListenComplete(query.path);\n          }\n        } else {\n          // If a listen failed, kill all of the listeners here, not just the one that triggered the error.\n          // Note that this may need to be scoped to just this listener if we change permissions on filtered children\n          const error = errorForServerCode(status, query);\n          return this.removeEventRegistration(\n            query,\n            /*eventRegistration*/ null,\n            error\n          );\n        }\n      }\n    };\n  }\n\n  /**\n   * Given a query, computes a \"queryKey\" suitable for use in our queryToTagMap_.\n   * @private\n   * @param {!Query} query\n   * @return {string}\n   */\n  private static makeQueryKey_(query: Query): string {\n    return query.path.toString() + '$' + query.queryIdentifier();\n  }\n\n  /**\n   * Given a queryKey (created by makeQueryKey), parse it back into a path and queryId.\n   * @private\n   * @param {!string} queryKey\n   * @return {{queryId: !string, path: !Path}}\n   */\n  private static parseQueryKey_(\n    queryKey: string\n  ): { queryId: string; path: Path } {\n    const splitIndex = queryKey.indexOf('$');\n    assert(\n      splitIndex !== -1 && splitIndex < queryKey.length - 1,\n      'Bad queryKey.'\n    );\n    return {\n      queryId: queryKey.substr(splitIndex + 1),\n      path: new Path(queryKey.substr(0, splitIndex))\n    };\n  }\n\n  /**\n   * Return the query associated with the given tag, if we have one\n   * @param {!number} tag\n   * @return {?string}\n   * @private\n   */\n  private queryKeyForTag_(tag: number): string | null {\n    return this.tagToQueryMap_['_' + tag];\n  }\n\n  /**\n   * Return the tag associated with the given query.\n   * @param {!Query} query\n   * @return {?number}\n   * @private\n   */\n  private tagForQuery_(query: Query): number | null {\n    const queryKey = SyncTree.makeQueryKey_(query);\n    return safeGet(this.queryToTagMap_, queryKey);\n  }\n\n  /**\n   * Static tracker for next query tag.\n   * @type {number}\n   * @private\n   */\n  private static nextQueryTag_ = 1;\n\n  /**\n   * Static accessor for query tags.\n   * @return {number}\n   * @private\n   */\n  private static getNextQueryTag_(): number {\n    return SyncTree.nextQueryTag_++;\n  }\n\n  /**\n   * A helper method to apply tagged operations\n   *\n   * @param {!Path} queryPath\n   * @param {!Operation} operation\n   * @return {!Array.<!Event>}\n   * @private\n   */\n  private applyTaggedOperation_(\n    queryPath: Path,\n    operation: Operation\n  ): Event[] {\n    const syncPoint = this.syncPointTree_.get(queryPath);\n    assert(syncPoint, \"Missing sync point for query tag that we're tracking\");\n    const writesCache = this.pendingWriteTree_.childWrites(queryPath);\n    return syncPoint.applyOperation(\n      operation,\n      writesCache,\n      /*serverCache=*/ null\n    );\n  }\n\n  /**\n   * A helper method that visits all descendant and ancestor SyncPoints, applying the operation.\n   *\n   * NOTES:\n   * - Descendant SyncPoints will be visited first (since we raise events depth-first).\n\n   * - We call applyOperation() on each SyncPoint passing three things:\n   *   1. A version of the Operation that has been made relative to the SyncPoint location.\n   *   2. A WriteTreeRef of any writes we have cached at the SyncPoint location.\n   *   3. A snapshot Node with cached server data, if we have it.\n\n   * - We concatenate all of the events returned by each SyncPoint and return the result.\n   *\n   * @param {!Operation} operation\n   * @return {!Array.<!Event>}\n   * @private\n   */\n  private applyOperationToSyncPoints_(operation: Operation): Event[] {\n    return this.applyOperationHelper_(\n      operation,\n      this.syncPointTree_,\n      /*serverCache=*/ null,\n      this.pendingWriteTree_.childWrites(Path.Empty)\n    );\n  }\n\n  /**\n   * Recursive helper for applyOperationToSyncPoints_\n   *\n   * @private\n   * @param {!Operation} operation\n   * @param {ImmutableTree.<!SyncPoint>} syncPointTree\n   * @param {?Node} serverCache\n   * @param {!WriteTreeRef} writesCache\n   * @return {!Array.<!Event>}\n   */\n  private applyOperationHelper_(\n    operation: Operation,\n    syncPointTree: ImmutableTree<SyncPoint>,\n    serverCache: Node | null,\n    writesCache: WriteTreeRef\n  ): Event[] {\n    if (operation.path.isEmpty()) {\n      return this.applyOperationDescendantsHelper_(\n        operation,\n        syncPointTree,\n        serverCache,\n        writesCache\n      );\n    } else {\n      const syncPoint = syncPointTree.get(Path.Empty);\n\n      // If we don't have cached server data, see if we can get it from this SyncPoint.\n      if (serverCache == null && syncPoint != null) {\n        serverCache = syncPoint.getCompleteServerCache(Path.Empty);\n      }\n\n      let events: Event[] = [];\n      const childName = operation.path.getFront();\n      const childOperation = operation.operationForChild(childName);\n      const childTree = syncPointTree.children.get(childName);\n      if (childTree && childOperation) {\n        const childServerCache = serverCache\n          ? serverCache.getImmediateChild(childName)\n          : null;\n        const childWritesCache = writesCache.child(childName);\n        events = events.concat(\n          this.applyOperationHelper_(\n            childOperation,\n            childTree,\n            childServerCache,\n            childWritesCache\n          )\n        );\n      }\n\n      if (syncPoint) {\n        events = events.concat(\n          syncPoint.applyOperation(operation, writesCache, serverCache)\n        );\n      }\n\n      return events;\n    }\n  }\n\n  /**\n   * Recursive helper for applyOperationToSyncPoints_\n   *\n   * @private\n   * @param {!Operation} operation\n   * @param {ImmutableTree.<!SyncPoint>} syncPointTree\n   * @param {?Node} serverCache\n   * @param {!WriteTreeRef} writesCache\n   * @return {!Array.<!Event>}\n   */\n  private applyOperationDescendantsHelper_(\n    operation: Operation,\n    syncPointTree: ImmutableTree<SyncPoint>,\n    serverCache: Node | null,\n    writesCache: WriteTreeRef\n  ): Event[] {\n    const syncPoint = syncPointTree.get(Path.Empty);\n\n    // If we don't have cached server data, see if we can get it from this SyncPoint.\n    if (serverCache == null && syncPoint != null) {\n      serverCache = syncPoint.getCompleteServerCache(Path.Empty);\n    }\n\n    let events: Event[] = [];\n    syncPointTree.children.inorderTraversal((childName, childTree) => {\n      const childServerCache = serverCache\n        ? serverCache.getImmediateChild(childName)\n        : null;\n      const childWritesCache = writesCache.child(childName);\n      const childOperation = operation.operationForChild(childName);\n      if (childOperation) {\n        events = events.concat(\n          this.applyOperationDescendantsHelper_(\n            childOperation,\n            childTree,\n            childServerCache,\n            childWritesCache\n          )\n        );\n      }\n    });\n\n    if (syncPoint) {\n      events = events.concat(\n        syncPoint.applyOperation(operation, writesCache, serverCache)\n      );\n    }\n\n    return events;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}