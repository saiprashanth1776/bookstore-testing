{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar tslib_1 = require(\"tslib\");\n\nvar util_1 = require(\"@firebase/util\");\n\nvar util_2 = require(\"./util/util\");\n\nvar util_3 = require(\"@firebase/util\");\n\nvar util_4 = require(\"@firebase/util\");\n\nvar util_5 = require(\"@firebase/util\");\n\nvar ServerActions_1 = require(\"./ServerActions\");\n/**\n * An implementation of ServerActions that communicates with the server via REST requests.\n * This is mostly useful for compatibility with crawlers, where we don't want to spin up a full\n * persistent connection (using WebSockets or long-polling)\n */\n\n\nvar ReadonlyRestClient =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(ReadonlyRestClient, _super);\n  /**\n   * @param {!RepoInfo} repoInfo_ Data about the namespace we are connecting to\n   * @param {function(string, *, boolean, ?number)} onDataUpdate_ A callback for new data from the server\n   * @param {AuthTokenProvider} authTokenProvider_\n   * @implements {ServerActions}\n   */\n\n\n  function ReadonlyRestClient(repoInfo_, onDataUpdate_, authTokenProvider_) {\n    var _this = _super.call(this) || this;\n\n    _this.repoInfo_ = repoInfo_;\n    _this.onDataUpdate_ = onDataUpdate_;\n    _this.authTokenProvider_ = authTokenProvider_;\n    /** @private {function(...[*])} */\n\n    _this.log_ = util_2.logWrapper('p:rest:');\n    /**\n     * We don't actually need to track listens, except to prevent us calling an onComplete for a listen\n     * that's been removed. :-/\n     *\n     * @private {!Object.<string, !Object>}\n     */\n\n    _this.listens_ = {};\n    return _this;\n  }\n\n  ReadonlyRestClient.prototype.reportStats = function (stats) {\n    throw new Error('Method not implemented.');\n  };\n  /**\n   * @param {!Query} query\n   * @param {?number=} tag\n   * @return {string}\n   * @private\n   */\n\n\n  ReadonlyRestClient.getListenId_ = function (query, tag) {\n    if (tag !== undefined) {\n      return 'tag$' + tag;\n    } else {\n      util_1.assert(query.getQueryParams().isDefault(), \"should have a tag if it's not a default query.\");\n      return query.path.toString();\n    }\n  };\n  /** @inheritDoc */\n\n\n  ReadonlyRestClient.prototype.listen = function (query, currentHashFn, tag, onComplete) {\n    var _this = this;\n\n    var pathString = query.path.toString();\n    this.log_('Listen called for ' + pathString + ' ' + query.queryIdentifier()); // Mark this listener so we can tell if it's removed.\n\n    var listenId = ReadonlyRestClient.getListenId_(query, tag);\n    var thisListen = {};\n    this.listens_[listenId] = thisListen;\n    var queryStringParamaters = query.getQueryParams().toRestQueryStringParameters();\n    this.restRequest_(pathString + '.json', queryStringParamaters, function (error, result) {\n      var data = result;\n\n      if (error === 404) {\n        data = null;\n        error = null;\n      }\n\n      if (error === null) {\n        _this.onDataUpdate_(pathString, data,\n        /*isMerge=*/\n        false, tag);\n      }\n\n      if (util_4.safeGet(_this.listens_, listenId) === thisListen) {\n        var status_1;\n\n        if (!error) {\n          status_1 = 'ok';\n        } else if (error == 401) {\n          status_1 = 'permission_denied';\n        } else {\n          status_1 = 'rest_error:' + error;\n        }\n\n        onComplete(status_1, null);\n      }\n    });\n  };\n  /** @inheritDoc */\n\n\n  ReadonlyRestClient.prototype.unlisten = function (query, tag) {\n    var listenId = ReadonlyRestClient.getListenId_(query, tag);\n    delete this.listens_[listenId];\n  };\n  /** @inheritDoc */\n\n\n  ReadonlyRestClient.prototype.refreshAuthToken = function (token) {// no-op since we just always call getToken.\n  };\n  /**\n   * Performs a REST request to the given path, with the provided query string parameters,\n   * and any auth credentials we have.\n   *\n   * @param {!string} pathString\n   * @param {!Object.<string, *>} queryStringParameters\n   * @param {?function(?number, *=)} callback\n   * @private\n   */\n\n\n  ReadonlyRestClient.prototype.restRequest_ = function (pathString, queryStringParameters, callback) {\n    var _this = this;\n\n    if (queryStringParameters === void 0) {\n      queryStringParameters = {};\n    }\n\n    queryStringParameters['format'] = 'export';\n    this.authTokenProvider_.getToken(\n    /*forceRefresh=*/\n    false).then(function (authTokenData) {\n      var authToken = authTokenData && authTokenData.accessToken;\n\n      if (authToken) {\n        queryStringParameters['auth'] = authToken;\n      }\n\n      var url = (_this.repoInfo_.secure ? 'https://' : 'http://') + _this.repoInfo_.host + pathString + '?' + util_5.querystring(queryStringParameters);\n\n      _this.log_('Sending REST request for ' + url);\n\n      var xhr = new XMLHttpRequest();\n\n      xhr.onreadystatechange = function () {\n        if (callback && xhr.readyState === 4) {\n          _this.log_('REST Response for ' + url + ' received. status:', xhr.status, 'response:', xhr.responseText);\n\n          var res = null;\n\n          if (xhr.status >= 200 && xhr.status < 300) {\n            try {\n              res = util_3.jsonEval(xhr.responseText);\n            } catch (e) {\n              util_2.warn('Failed to parse JSON response for ' + url + ': ' + xhr.responseText);\n            }\n\n            callback(null, res);\n          } else {\n            // 401 and 404 are expected.\n            if (xhr.status !== 401 && xhr.status !== 404) {\n              util_2.warn('Got unsuccessful REST response for ' + url + ' Status: ' + xhr.status);\n            }\n\n            callback(xhr.status);\n          }\n\n          callback = null;\n        }\n      };\n\n      xhr.open('GET', url,\n      /*asynchronous=*/\n      true);\n      xhr.send();\n    });\n  };\n\n  return ReadonlyRestClient;\n}(ServerActions_1.ServerActions);\n\nexports.ReadonlyRestClient = ReadonlyRestClient;","map":{"version":3,"sources":["../src/core/ReadonlyRestClient.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert } from '@firebase/util';\nimport { logWrapper, warn } from './util/util';\nimport { jsonEval } from '@firebase/util';\nimport { safeGet } from '@firebase/util';\nimport { querystring } from '@firebase/util';\nimport { ServerActions } from './ServerActions';\nimport { RepoInfo } from './RepoInfo';\nimport { AuthTokenProvider } from './AuthTokenProvider';\nimport { Query } from '../api/Query';\n\n/**\n * An implementation of ServerActions that communicates with the server via REST requests.\n * This is mostly useful for compatibility with crawlers, where we don't want to spin up a full\n * persistent connection (using WebSockets or long-polling)\n */\nexport class ReadonlyRestClient extends ServerActions {\n  reportStats(stats: { [k: string]: any }): void {\n    throw new Error('Method not implemented.');\n  }\n\n  /** @private {function(...[*])} */\n  private log_: (...args: any[]) => void = logWrapper('p:rest:');\n\n  /**\n   * We don't actually need to track listens, except to prevent us calling an onComplete for a listen\n   * that's been removed. :-/\n   *\n   * @private {!Object.<string, !Object>}\n   */\n  private listens_: { [k: string]: Object } = {};\n\n  /**\n   * @param {!Query} query\n   * @param {?number=} tag\n   * @return {string}\n   * @private\n   */\n  static getListenId_(query: Query, tag?: number | null): string {\n    if (tag !== undefined) {\n      return 'tag$' + tag;\n    } else {\n      assert(\n        query.getQueryParams().isDefault(),\n        \"should have a tag if it's not a default query.\"\n      );\n      return query.path.toString();\n    }\n  }\n\n  /**\n   * @param {!RepoInfo} repoInfo_ Data about the namespace we are connecting to\n   * @param {function(string, *, boolean, ?number)} onDataUpdate_ A callback for new data from the server\n   * @param {AuthTokenProvider} authTokenProvider_\n   * @implements {ServerActions}\n   */\n  constructor(\n    private repoInfo_: RepoInfo,\n    private onDataUpdate_: (\n      a: string,\n      b: any,\n      c: boolean,\n      d: number | null\n    ) => void,\n    private authTokenProvider_: AuthTokenProvider\n  ) {\n    super();\n  }\n\n  /** @inheritDoc */\n  listen(\n    query: Query,\n    currentHashFn: () => string,\n    tag: number | null,\n    onComplete: (a: string, b: any) => void\n  ) {\n    const pathString = query.path.toString();\n    this.log_(\n      'Listen called for ' + pathString + ' ' + query.queryIdentifier()\n    );\n\n    // Mark this listener so we can tell if it's removed.\n    const listenId = ReadonlyRestClient.getListenId_(query, tag);\n    const thisListen = {};\n    this.listens_[listenId] = thisListen;\n\n    const queryStringParamaters = query\n      .getQueryParams()\n      .toRestQueryStringParameters();\n\n    this.restRequest_(\n      pathString + '.json',\n      queryStringParamaters,\n      (error, result) => {\n        let data = result;\n\n        if (error === 404) {\n          data = null;\n          error = null;\n        }\n\n        if (error === null) {\n          this.onDataUpdate_(pathString, data, /*isMerge=*/ false, tag);\n        }\n\n        if (safeGet(this.listens_, listenId) === thisListen) {\n          let status;\n          if (!error) {\n            status = 'ok';\n          } else if (error == 401) {\n            status = 'permission_denied';\n          } else {\n            status = 'rest_error:' + error;\n          }\n\n          onComplete(status, null);\n        }\n      }\n    );\n  }\n\n  /** @inheritDoc */\n  unlisten(query: Query, tag: number | null) {\n    const listenId = ReadonlyRestClient.getListenId_(query, tag);\n    delete this.listens_[listenId];\n  }\n\n  /** @inheritDoc */\n  refreshAuthToken(token: string) {\n    // no-op since we just always call getToken.\n  }\n\n  /**\n   * Performs a REST request to the given path, with the provided query string parameters,\n   * and any auth credentials we have.\n   *\n   * @param {!string} pathString\n   * @param {!Object.<string, *>} queryStringParameters\n   * @param {?function(?number, *=)} callback\n   * @private\n   */\n  private restRequest_(\n    pathString: string,\n    queryStringParameters: { [k: string]: any } = {},\n    callback: ((a: number | null, b?: any) => void) | null\n  ) {\n    queryStringParameters['format'] = 'export';\n\n    this.authTokenProvider_\n      .getToken(/*forceRefresh=*/ false)\n      .then(authTokenData => {\n        const authToken = authTokenData && authTokenData.accessToken;\n        if (authToken) {\n          queryStringParameters['auth'] = authToken;\n        }\n\n        const url =\n          (this.repoInfo_.secure ? 'https://' : 'http://') +\n          this.repoInfo_.host +\n          pathString +\n          '?' +\n          querystring(queryStringParameters);\n\n        this.log_('Sending REST request for ' + url);\n        const xhr = new XMLHttpRequest();\n        xhr.onreadystatechange = () => {\n          if (callback && xhr.readyState === 4) {\n            this.log_(\n              'REST Response for ' + url + ' received. status:',\n              xhr.status,\n              'response:',\n              xhr.responseText\n            );\n            let res = null;\n            if (xhr.status >= 200 && xhr.status < 300) {\n              try {\n                res = jsonEval(xhr.responseText);\n              } catch (e) {\n                warn(\n                  'Failed to parse JSON response for ' +\n                    url +\n                    ': ' +\n                    xhr.responseText\n                );\n              }\n              callback(null, res);\n            } else {\n              // 401 and 404 are expected.\n              if (xhr.status !== 401 && xhr.status !== 404) {\n                warn(\n                  'Got unsuccessful REST response for ' +\n                    url +\n                    ' Status: ' +\n                    xhr.status\n                );\n              }\n              callback(xhr.status);\n            }\n            callback = null;\n          }\n        };\n\n        xhr.open('GET', url, /*asynchronous=*/ true);\n        xhr.send();\n      });\n  }\n}\n"]},"metadata":{},"sourceType":"script"}