{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\n\nimport * as tslib_1 from \"tslib\";\nimport ControllerInterface from './controller-interface';\nimport Errors from '../models/errors';\nimport FCMDetails from '../models/fcm-details';\nimport WorkerPageMessage from '../models/worker-page-message';\nvar FCM_MSG = 'FCM_MSG';\n\nvar SWController =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(SWController, _super);\n\n  function SWController(app) {\n    var _this = _super.call(this, app) || this;\n\n    self.addEventListener('push', function (e) {\n      return _this.onPush_(e);\n    }, false);\n    self.addEventListener('pushsubscriptionchange', function (e) {\n      return _this.onSubChange_(e);\n    }, false);\n    self.addEventListener('notificationclick', function (e) {\n      return _this.onNotificationClick_(e);\n    }, false);\n    /**\n     * @private\n     * @type {function(Object)|null}\n     */\n\n    _this.bgMessageHandler_ = null;\n    return _this;\n  }\n  /**\n   * A handler for push events that shows notifications based on the content of\n   * the payload.\n   *\n   * The payload must be a JSON-encoded Object with a `notification` key. The\n   * value of the `notification` property will be used as the NotificationOptions\n   * object passed to showNotification. Additionally, the `title` property of the\n   * notification object will be used as the title.\n   *\n   * If there is no notification data in the payload then no notification will be\n   * shown.\n   * @private\n   */\n\n\n  SWController.prototype.onPush_ = function (event) {\n    var _this = this;\n\n    var msgPayload;\n\n    try {\n      msgPayload = event.data.json();\n    } catch (err) {\n      // Not JSON so not an FCM message\n      return;\n    }\n\n    var handleMsgPromise = this.hasVisibleClients_().then(function (hasVisibleClients) {\n      if (hasVisibleClients) {\n        // Do not need to show a notification.\n        if (msgPayload.notification || _this.bgMessageHandler_) {\n          // Send to page\n          return _this.sendMessageToWindowClients_(msgPayload);\n        }\n\n        return;\n      }\n\n      var notificationDetails = _this.getNotificationData_(msgPayload);\n\n      if (notificationDetails) {\n        var notificationTitle_1 = notificationDetails.title || '';\n        return _this.getSWRegistration_().then(function (reg) {\n          return reg.showNotification(notificationTitle_1, notificationDetails);\n        });\n      } else if (_this.bgMessageHandler_) {\n        return _this.bgMessageHandler_(msgPayload);\n      }\n    });\n    event.waitUntil(handleMsgPromise);\n  };\n  /**\n   * @private\n   */\n\n\n  SWController.prototype.onSubChange_ = function (event) {\n    var _this = this;\n\n    var promiseChain = this.getSWRegistration_().then(function (registration) {\n      return registration.pushManager.getSubscription().then(function (subscription) {// TODO: Check if it's still valid\n        // TODO: If not, then update token\n      }).catch(function (err) {\n        // The best thing we can do is log this to the terminal so\n        // developers might notice the error.\n        var tokenDetailsModel = _this.getTokenDetailsModel();\n\n        return tokenDetailsModel.getTokenDetailsFromSWScope(registration.scope).then(function (tokenDetails) {\n          if (!tokenDetails) {\n            // This should rarely occure, but could if indexedDB\n            // is corrupted or wiped\n            throw err;\n          } // Attempt to delete the token if we know it's bad\n\n\n          return _this.deleteToken(tokenDetails['fcmToken']).then(function () {\n            throw err;\n          });\n        });\n      });\n    }).catch(function (err) {\n      throw _this.errorFactory_.create(Errors.codes.UNABLE_TO_RESUBSCRIBE, {\n        message: err\n      });\n    });\n    event.waitUntil(promiseChain);\n  };\n  /**\n   * @private\n   */\n\n\n  SWController.prototype.onNotificationClick_ = function (event) {\n    var _this = this;\n\n    if (!(event.notification && event.notification.data && event.notification.data[FCM_MSG])) {\n      // Not an FCM notification, do nothing.\n      return;\n    } // Prevent other listeners from receiving the event\n\n\n    event.stopImmediatePropagation();\n    event.notification.close();\n    var msgPayload = event.notification.data[FCM_MSG];\n\n    if (!msgPayload['notification']) {\n      // Nothing to do.\n      return;\n    }\n\n    var clickAction = msgPayload['notification']['click_action'];\n\n    if (!clickAction) {\n      // Nothing to do.\n      return;\n    }\n\n    var promiseChain = this.getWindowClient_(clickAction).then(function (windowClient) {\n      if (!windowClient) {\n        // Unable to find window client so need to open one.\n        return self.clients.openWindow(clickAction);\n      }\n\n      return windowClient.focus();\n    }).then(function (windowClient) {\n      if (!windowClient) {\n        // Window Client will not be returned if it's for a third party origin.\n        return;\n      } // Delete notification data from payload before sending to the page.\n\n\n      var notificationData = msgPayload['notification'];\n      delete msgPayload['notification'];\n      var internalMsg = WorkerPageMessage.createNewMsg(WorkerPageMessage.TYPES_OF_MSG.NOTIFICATION_CLICKED, msgPayload); // Attempt to send a message to the client to handle the data\n      // Is affected by: https://github.com/slightlyoff/ServiceWorker/issues/728\n\n      return _this.attemptToMessageClient_(windowClient, internalMsg);\n    });\n    event.waitUntil(promiseChain);\n  };\n  /**\n   * @private\n   * @param {Object} msgPayload\n   * @return {NotificationOptions|undefined}\n   */\n\n\n  SWController.prototype.getNotificationData_ = function (msgPayload) {\n    if (!msgPayload) {\n      return;\n    }\n\n    if (typeof msgPayload.notification !== 'object') {\n      return;\n    }\n\n    var notificationInformation = Object.assign({}, msgPayload.notification); // Put the message payload under FCM_MSG name so we can identify the\n    // notification as being an FCM notification vs a notification from\n    // somewhere else (i.e. normal web push or developer generated\n    // notification).\n\n    notificationInformation['data'] = (_a = {}, _a[FCM_MSG] = msgPayload, _a);\n    return notificationInformation;\n\n    var _a;\n  };\n  /**\n   * Calling setBackgroundMessageHandler will opt in to some specific\n   * behaviours.\n   * 1.) If a notification doesn't need to be shown due to a window already\n   * being visible, then push messages will be sent to the page.\n   * 2.) If a notification needs to be shown, and the message contains no\n   * notification data this method will be called\n   * and the promise it returns will be passed to event.waitUntil.\n   * If you do not set this callback then all push messages will let and the\n   * developer can handle them in a their own 'push' event callback\n   * @export\n   * @param {function(Object)} callback The callback to be called when a push\n   * message is received and a notification must be shown. The callback will\n   * be given the data from the push message.\n   */\n\n\n  SWController.prototype.setBackgroundMessageHandler = function (callback) {\n    if (!callback || typeof callback !== 'function') {\n      throw this.errorFactory_.create(Errors.codes.BG_HANDLER_FUNCTION_EXPECTED);\n    }\n\n    this.bgMessageHandler_ = callback;\n  };\n  /**\n   * @private\n   * @param {string} url The URL to look for when focusing a client.\n   * @return {Object} Returns an existing window client or a newly opened\n   * WindowClient.\n   */\n\n\n  SWController.prototype.getWindowClient_ = function (url) {\n    // Use URL to normalize the URL when comparing to windowClients.\n    // This at least handles whether to include trailing slashes or not\n    var parsedURL = new URL(url, self.location).href;\n    return self.clients.matchAll({\n      type: 'window',\n      includeUncontrolled: true\n    }).then(function (clientList) {\n      var suitableClient = null;\n\n      for (var i = 0; i < clientList.length; i++) {\n        var parsedClientUrl = new URL(clientList[i].url, self.location).href;\n\n        if (parsedClientUrl === parsedURL) {\n          suitableClient = clientList[i];\n          break;\n        }\n      }\n\n      if (suitableClient) {\n        return suitableClient;\n      }\n\n      return null;\n    });\n  };\n  /**\n   * This message will attempt to send the message to a window client.\n   * @private\n   * @param {Object} client The WindowClient to send the message to.\n   * @param {Object} message The message to send to the client.\n   * @returns {Promise} Returns a promise that resolves after sending the\n   * message. This does not guarantee that the message was successfully\n   * received.\n   */\n\n\n  SWController.prototype.attemptToMessageClient_ = function (client, message) {\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      return tslib_1.__generator(this, function (_a) {\n        // NOTE: This returns a promise in case this API is abstracted later on to\n        // do additional work\n        if (!client) {\n          return [2\n          /*return*/\n          , Promise.reject(this.errorFactory_.create(Errors.codes.NO_WINDOW_CLIENT_TO_MSG))];\n        }\n\n        client.postMessage(message);\n        return [2\n        /*return*/\n        ];\n      });\n    });\n  };\n  /**\n   * @private\n   * @returns {Promise<boolean>} If there is currently a visible WindowClient,\n   * this method will resolve to true, otherwise false.\n   */\n\n\n  SWController.prototype.hasVisibleClients_ = function () {\n    return self.clients.matchAll({\n      type: 'window',\n      includeUncontrolled: true\n    }).then(function (clientList) {\n      return clientList.some(function (client) {\n        return client.visibilityState === 'visible';\n      });\n    });\n  };\n  /**\n   * @private\n   * @param {Object} msgPayload The data from the push event that should be sent\n   * to all available pages.\n   * @returns {Promise} Returns a promise that resolves once the message\n   * has been sent to all WindowClients.\n   */\n\n\n  SWController.prototype.sendMessageToWindowClients_ = function (msgPayload) {\n    var _this = this;\n\n    return self.clients.matchAll({\n      type: 'window',\n      includeUncontrolled: true\n    }).then(function (clientList) {\n      var internalMsg = WorkerPageMessage.createNewMsg(WorkerPageMessage.TYPES_OF_MSG.PUSH_MSG_RECEIVED, msgPayload);\n      return Promise.all(clientList.map(function (client) {\n        return _this.attemptToMessageClient_(client, internalMsg);\n      }));\n    });\n  };\n  /**\n   * This will register the default service worker and return the registration.\n   * @private\n   * @return {Promise<!ServiceWorkerRegistration>} The service worker\n   * registration to be used for the push service.\n   */\n\n\n  SWController.prototype.getSWRegistration_ = function () {\n    return Promise.resolve(self.registration);\n  };\n  /**\n   * This will return the default VAPID key or the uint8array version of the\n   * public VAPID key provided by the developer.\n   */\n\n\n  SWController.prototype.getPublicVapidKey_ = function () {\n    var _this = this;\n\n    return this.getSWRegistration_().then(function (swReg) {\n      return _this.getVapidDetailsModel().getVapidFromSWScope(swReg.scope);\n    }).then(function (vapidKeyFromDatabase) {\n      if (vapidKeyFromDatabase === null) {\n        return FCMDetails.DEFAULT_PUBLIC_VAPID_KEY;\n      }\n\n      return vapidKeyFromDatabase;\n    });\n  };\n\n  return SWController;\n}(ControllerInterface);\n\nexport default SWController;","map":{"version":3,"sources":["../src/controllers/sw-controller.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\n\nimport ControllerInterface from './controller-interface';\nimport Errors from '../models/errors';\nimport FCMDetails from '../models/fcm-details';\nimport WorkerPageMessage from '../models/worker-page-message';\n\nconst FCM_MSG = 'FCM_MSG';\n\nexport default class SWController extends ControllerInterface {\n  private bgMessageHandler_: (input: Object) => Promise<any>;\n\n  constructor(app) {\n    super(app);\n\n    self.addEventListener('push', e => this.onPush_(e), false);\n    self.addEventListener(\n      'pushsubscriptionchange',\n      e => this.onSubChange_(e),\n      false\n    );\n    self.addEventListener(\n      'notificationclick',\n      e => this.onNotificationClick_(e),\n      false\n    );\n\n    /**\n     * @private\n     * @type {function(Object)|null}\n     */\n    this.bgMessageHandler_ = null;\n  }\n\n  /**\n   * A handler for push events that shows notifications based on the content of\n   * the payload.\n   *\n   * The payload must be a JSON-encoded Object with a `notification` key. The\n   * value of the `notification` property will be used as the NotificationOptions\n   * object passed to showNotification. Additionally, the `title` property of the\n   * notification object will be used as the title.\n   *\n   * If there is no notification data in the payload then no notification will be\n   * shown.\n   * @private\n   */\n  onPush_(event) {\n    let msgPayload;\n    try {\n      msgPayload = event.data.json();\n    } catch (err) {\n      // Not JSON so not an FCM message\n      return;\n    }\n\n    const handleMsgPromise = this.hasVisibleClients_().then(\n      hasVisibleClients => {\n        if (hasVisibleClients) {\n          // Do not need to show a notification.\n          if (msgPayload.notification || this.bgMessageHandler_) {\n            // Send to page\n            return this.sendMessageToWindowClients_(msgPayload);\n          }\n          return;\n        }\n\n        const notificationDetails = this.getNotificationData_(msgPayload);\n        if (notificationDetails) {\n          const notificationTitle = notificationDetails.title || '';\n          return (this.getSWRegistration_() as any).then(reg => {\n            return reg.showNotification(notificationTitle, notificationDetails);\n          });\n        } else if (this.bgMessageHandler_) {\n          return this.bgMessageHandler_(msgPayload);\n        }\n      }\n    );\n\n    event.waitUntil(handleMsgPromise);\n  }\n\n  /**\n   * @private\n   */\n  onSubChange_(event) {\n    const promiseChain = this.getSWRegistration_()\n      .then(registration => {\n        return registration.pushManager\n          .getSubscription()\n          .then(subscription => {\n            // TODO: Check if it's still valid\n            // TODO: If not, then update token\n          })\n          .catch(err => {\n            // The best thing we can do is log this to the terminal so\n            // developers might notice the error.\n            const tokenDetailsModel = this.getTokenDetailsModel();\n            return tokenDetailsModel\n              .getTokenDetailsFromSWScope(registration.scope)\n              .then(tokenDetails => {\n                if (!tokenDetails) {\n                  // This should rarely occure, but could if indexedDB\n                  // is corrupted or wiped\n                  throw err;\n                }\n\n                // Attempt to delete the token if we know it's bad\n                return this.deleteToken(tokenDetails['fcmToken']).then(() => {\n                  throw err;\n                });\n              });\n          });\n      })\n      .catch(err => {\n        throw this.errorFactory_.create(Errors.codes.UNABLE_TO_RESUBSCRIBE, {\n          message: err\n        });\n      });\n\n    event.waitUntil(promiseChain);\n  }\n\n  /**\n   * @private\n   */\n  onNotificationClick_(event) {\n    if (\n      !(\n        event.notification &&\n        event.notification.data &&\n        event.notification.data[FCM_MSG]\n      )\n    ) {\n      // Not an FCM notification, do nothing.\n      return;\n    }\n\n    // Prevent other listeners from receiving the event\n    event.stopImmediatePropagation();\n\n    event.notification.close();\n\n    const msgPayload = event.notification.data[FCM_MSG];\n    if (!msgPayload['notification']) {\n      // Nothing to do.\n      return;\n    }\n\n    const clickAction = msgPayload['notification']['click_action'];\n    if (!clickAction) {\n      // Nothing to do.\n      return;\n    }\n\n    const promiseChain = this.getWindowClient_(clickAction)\n      .then(windowClient => {\n        if (!windowClient) {\n          // Unable to find window client so need to open one.\n          return (self as any).clients.openWindow(clickAction);\n        }\n\n        return windowClient.focus();\n      })\n      .then(windowClient => {\n        if (!windowClient) {\n          // Window Client will not be returned if it's for a third party origin.\n          return;\n        }\n\n        // Delete notification data from payload before sending to the page.\n        const notificationData = msgPayload['notification'];\n        delete msgPayload['notification'];\n\n        const internalMsg = WorkerPageMessage.createNewMsg(\n          WorkerPageMessage.TYPES_OF_MSG.NOTIFICATION_CLICKED,\n          msgPayload\n        );\n        // Attempt to send a message to the client to handle the data\n        // Is affected by: https://github.com/slightlyoff/ServiceWorker/issues/728\n        return this.attemptToMessageClient_(windowClient, internalMsg);\n      });\n\n    event.waitUntil(promiseChain);\n  }\n\n  /**\n   * @private\n   * @param {Object} msgPayload\n   * @return {NotificationOptions|undefined}\n   */\n  getNotificationData_(msgPayload) {\n    if (!msgPayload) {\n      return;\n    }\n\n    if (typeof msgPayload.notification !== 'object') {\n      return;\n    }\n\n    const notificationInformation = Object.assign({}, msgPayload.notification);\n    // Put the message payload under FCM_MSG name so we can identify the\n    // notification as being an FCM notification vs a notification from\n    // somewhere else (i.e. normal web push or developer generated\n    // notification).\n    notificationInformation['data'] = {\n      [FCM_MSG]: msgPayload\n    };\n\n    return notificationInformation;\n  }\n\n  /**\n   * Calling setBackgroundMessageHandler will opt in to some specific\n   * behaviours.\n   * 1.) If a notification doesn't need to be shown due to a window already\n   * being visible, then push messages will be sent to the page.\n   * 2.) If a notification needs to be shown, and the message contains no\n   * notification data this method will be called\n   * and the promise it returns will be passed to event.waitUntil.\n   * If you do not set this callback then all push messages will let and the\n   * developer can handle them in a their own 'push' event callback\n   * @export\n   * @param {function(Object)} callback The callback to be called when a push\n   * message is received and a notification must be shown. The callback will\n   * be given the data from the push message.\n   */\n  setBackgroundMessageHandler(callback) {\n    if (!callback || typeof callback !== 'function') {\n      throw this.errorFactory_.create(\n        Errors.codes.BG_HANDLER_FUNCTION_EXPECTED\n      );\n    }\n\n    this.bgMessageHandler_ = callback;\n  }\n\n  /**\n   * @private\n   * @param {string} url The URL to look for when focusing a client.\n   * @return {Object} Returns an existing window client or a newly opened\n   * WindowClient.\n   */\n  getWindowClient_(url) {\n    // Use URL to normalize the URL when comparing to windowClients.\n    // This at least handles whether to include trailing slashes or not\n    const parsedURL = new URL(url, (self as any).location).href;\n\n    return (self as any).clients\n      .matchAll({\n        type: 'window',\n        includeUncontrolled: true\n      })\n      .then(clientList => {\n        let suitableClient = null;\n        for (let i = 0; i < clientList.length; i++) {\n          const parsedClientUrl = new URL(\n            clientList[i].url,\n            (self as any).location\n          ).href;\n          if (parsedClientUrl === parsedURL) {\n            suitableClient = clientList[i];\n            break;\n          }\n        }\n\n        if (suitableClient) {\n          return suitableClient;\n        }\n\n        return null;\n      });\n  }\n\n  /**\n   * This message will attempt to send the message to a window client.\n   * @private\n   * @param {Object} client The WindowClient to send the message to.\n   * @param {Object} message The message to send to the client.\n   * @returns {Promise} Returns a promise that resolves after sending the\n   * message. This does not guarantee that the message was successfully\n   * received.\n   */\n  async attemptToMessageClient_(client, message) {\n    // NOTE: This returns a promise in case this API is abstracted later on to\n    // do additional work\n    if (!client) {\n      return Promise.reject(\n        this.errorFactory_.create(Errors.codes.NO_WINDOW_CLIENT_TO_MSG)\n      );\n    }\n\n    client.postMessage(message);\n  }\n\n  /**\n   * @private\n   * @returns {Promise<boolean>} If there is currently a visible WindowClient,\n   * this method will resolve to true, otherwise false.\n   */\n  hasVisibleClients_() {\n    return (self as any).clients\n      .matchAll({\n        type: 'window',\n        includeUncontrolled: true\n      })\n      .then(clientList => {\n        return clientList.some(client => client.visibilityState === 'visible');\n      });\n  }\n\n  /**\n   * @private\n   * @param {Object} msgPayload The data from the push event that should be sent\n   * to all available pages.\n   * @returns {Promise} Returns a promise that resolves once the message\n   * has been sent to all WindowClients.\n   */\n  sendMessageToWindowClients_(msgPayload) {\n    return (self as any).clients\n      .matchAll({\n        type: 'window',\n        includeUncontrolled: true\n      })\n      .then(clientList => {\n        const internalMsg = WorkerPageMessage.createNewMsg(\n          WorkerPageMessage.TYPES_OF_MSG.PUSH_MSG_RECEIVED,\n          msgPayload\n        );\n\n        return Promise.all(\n          clientList.map(client => {\n            return this.attemptToMessageClient_(client, internalMsg);\n          })\n        );\n      });\n  }\n\n  /**\n   * This will register the default service worker and return the registration.\n   * @private\n   * @return {Promise<!ServiceWorkerRegistration>} The service worker\n   * registration to be used for the push service.\n   */\n  getSWRegistration_() {\n    return Promise.resolve((self as any).registration);\n  }\n\n  /**\n   * This will return the default VAPID key or the uint8array version of the\n   * public VAPID key provided by the developer.\n   */\n  getPublicVapidKey_(): Promise<Uint8Array> {\n    return this.getSWRegistration_()\n      .then(swReg => {\n        return this.getVapidDetailsModel().getVapidFromSWScope(swReg.scope);\n      })\n      .then(vapidKeyFromDatabase => {\n        if (vapidKeyFromDatabase === null) {\n          return FCMDetails.DEFAULT_PUBLIC_VAPID_KEY;\n        }\n        return vapidKeyFromDatabase;\n      });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}