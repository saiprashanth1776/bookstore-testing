{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar ServerValues_1 = require(\"./util/ServerValues\");\n\nvar nodeFromJSON_1 = require(\"./snap/nodeFromJSON\");\n\nvar Path_1 = require(\"./util/Path\");\n\nvar SparseSnapshotTree_1 = require(\"./SparseSnapshotTree\");\n\nvar SyncTree_1 = require(\"./SyncTree\");\n\nvar SnapshotHolder_1 = require(\"./SnapshotHolder\");\n\nvar util_1 = require(\"@firebase/util\");\n\nvar util_2 = require(\"./util/util\");\n\nvar util_3 = require(\"@firebase/util\");\n\nvar AuthTokenProvider_1 = require(\"./AuthTokenProvider\");\n\nvar StatsManager_1 = require(\"./stats/StatsManager\");\n\nvar StatsReporter_1 = require(\"./stats/StatsReporter\");\n\nvar StatsListener_1 = require(\"./stats/StatsListener\");\n\nvar EventQueue_1 = require(\"./view/EventQueue\");\n\nvar PersistentConnection_1 = require(\"./PersistentConnection\");\n\nvar ReadonlyRestClient_1 = require(\"./ReadonlyRestClient\");\n\nvar Database_1 = require(\"../api/Database\");\n\nvar INTERRUPT_REASON = 'repo_interrupt';\n/**\n * A connection to a single data repository.\n */\n\nvar Repo =\n/** @class */\nfunction () {\n  /**\n   * @param {!RepoInfo} repoInfo_\n   * @param {boolean} forceRestClient\n   * @param {!FirebaseApp} app\n   */\n  function Repo(repoInfo_, forceRestClient, app) {\n    var _this = this;\n\n    this.repoInfo_ = repoInfo_;\n    this.app = app;\n    this.dataUpdateCount = 0;\n    this.statsListener_ = null;\n    this.eventQueue_ = new EventQueue_1.EventQueue();\n    this.nextWriteId_ = 1;\n    this.interceptServerDataCallback_ = null; // A list of data pieces and paths to be set when this client disconnects.\n\n    this.onDisconnect_ = new SparseSnapshotTree_1.SparseSnapshotTree();\n    /**\n     * TODO: This should be @private but it's used by test_access.js and internal.js\n     * @type {?PersistentConnection}\n     */\n\n    this.persistentConnection_ = null;\n    /** @type {!AuthTokenProvider} */\n\n    var authTokenProvider = new AuthTokenProvider_1.AuthTokenProvider(app);\n    this.stats_ = StatsManager_1.StatsManager.getCollection(repoInfo_);\n\n    if (forceRestClient || util_2.beingCrawled()) {\n      this.server_ = new ReadonlyRestClient_1.ReadonlyRestClient(this.repoInfo_, this.onDataUpdate_.bind(this), authTokenProvider); // Minor hack: Fire onConnect immediately, since there's no actual connection.\n\n      setTimeout(this.onConnectStatus_.bind(this, true), 0);\n    } else {\n      var authOverride = app.options['databaseAuthVariableOverride']; // Validate authOverride\n\n      if (typeof authOverride !== 'undefined' && authOverride !== null) {\n        if (typeof authOverride !== 'object') {\n          throw new Error('Only objects are supported for option databaseAuthVariableOverride');\n        }\n\n        try {\n          util_1.stringify(authOverride);\n        } catch (e) {\n          throw new Error('Invalid authOverride provided: ' + e);\n        }\n      }\n\n      this.persistentConnection_ = new PersistentConnection_1.PersistentConnection(this.repoInfo_, this.onDataUpdate_.bind(this), this.onConnectStatus_.bind(this), this.onServerInfoUpdate_.bind(this), authTokenProvider, authOverride);\n      this.server_ = this.persistentConnection_;\n    }\n\n    authTokenProvider.addTokenChangeListener(function (token) {\n      _this.server_.refreshAuthToken(token);\n    }); // In the case of multiple Repos for the same repoInfo (i.e. there are multiple Firebase.Contexts being used),\n    // we only want to create one StatsReporter.  As such, we'll report stats over the first Repo created.\n\n    this.statsReporter_ = StatsManager_1.StatsManager.getOrCreateReporter(repoInfo_, function () {\n      return new StatsReporter_1.StatsReporter(_this.stats_, _this.server_);\n    });\n    this.transactions_init_(); // Used for .info.\n\n    this.infoData_ = new SnapshotHolder_1.SnapshotHolder();\n    this.infoSyncTree_ = new SyncTree_1.SyncTree({\n      startListening: function (query, tag, currentHashFn, onComplete) {\n        var infoEvents = [];\n\n        var node = _this.infoData_.getNode(query.path); // This is possibly a hack, but we have different semantics for .info endpoints. We don't raise null events\n        // on initial data...\n\n\n        if (!node.isEmpty()) {\n          infoEvents = _this.infoSyncTree_.applyServerOverwrite(query.path, node);\n          setTimeout(function () {\n            onComplete('ok');\n          }, 0);\n        }\n\n        return infoEvents;\n      },\n      stopListening: function () {}\n    });\n    this.updateInfo_('connected', false);\n    this.serverSyncTree_ = new SyncTree_1.SyncTree({\n      startListening: function (query, tag, currentHashFn, onComplete) {\n        _this.server_.listen(query, currentHashFn, tag, function (status, data) {\n          var events = onComplete(status, data);\n\n          _this.eventQueue_.raiseEventsForChangedPath(query.path, events);\n        }); // No synchronous events for network-backed sync trees\n\n\n        return [];\n      },\n      stopListening: function (query, tag) {\n        _this.server_.unlisten(query, tag);\n      }\n    });\n  }\n  /**\n   * @return {string}  The URL corresponding to the root of this Firebase.\n   */\n\n\n  Repo.prototype.toString = function () {\n    return (this.repoInfo_.secure ? 'https://' : 'http://') + this.repoInfo_.host;\n  };\n  /**\n   * @return {!string} The namespace represented by the repo.\n   */\n\n\n  Repo.prototype.name = function () {\n    return this.repoInfo_.namespace;\n  };\n  /**\n   * @return {!number} The time in milliseconds, taking the server offset into account if we have one.\n   */\n\n\n  Repo.prototype.serverTime = function () {\n    var offsetNode = this.infoData_.getNode(new Path_1.Path('.info/serverTimeOffset'));\n    var offset = offsetNode.val() || 0;\n    return new Date().getTime() + offset;\n  };\n  /**\n   * Generate ServerValues using some variables from the repo object.\n   * @return {!Object}\n   */\n\n\n  Repo.prototype.generateServerValues = function () {\n    return ServerValues_1.generateWithValues({\n      timestamp: this.serverTime()\n    });\n  };\n  /**\n   * Called by realtime when we get new messages from the server.\n   *\n   * @private\n   * @param {string} pathString\n   * @param {*} data\n   * @param {boolean} isMerge\n   * @param {?number} tag\n   */\n\n\n  Repo.prototype.onDataUpdate_ = function (pathString, data, isMerge, tag) {\n    // For testing.\n    this.dataUpdateCount++;\n    var path = new Path_1.Path(pathString);\n    data = this.interceptServerDataCallback_ ? this.interceptServerDataCallback_(pathString, data) : data;\n    var events = [];\n\n    if (tag) {\n      if (isMerge) {\n        var taggedChildren = util_3.map(data, function (raw) {\n          return nodeFromJSON_1.nodeFromJSON(raw);\n        });\n        events = this.serverSyncTree_.applyTaggedQueryMerge(path, taggedChildren, tag);\n      } else {\n        var taggedSnap = nodeFromJSON_1.nodeFromJSON(data);\n        events = this.serverSyncTree_.applyTaggedQueryOverwrite(path, taggedSnap, tag);\n      }\n    } else if (isMerge) {\n      var changedChildren = util_3.map(data, function (raw) {\n        return nodeFromJSON_1.nodeFromJSON(raw);\n      });\n      events = this.serverSyncTree_.applyServerMerge(path, changedChildren);\n    } else {\n      var snap = nodeFromJSON_1.nodeFromJSON(data);\n      events = this.serverSyncTree_.applyServerOverwrite(path, snap);\n    }\n\n    var affectedPath = path;\n\n    if (events.length > 0) {\n      // Since we have a listener outstanding for each transaction, receiving any events\n      // is a proxy for some change having occurred.\n      affectedPath = this.rerunTransactions_(path);\n    }\n\n    this.eventQueue_.raiseEventsForChangedPath(affectedPath, events);\n  };\n  /**\n   * TODO: This should be @private but it's used by test_access.js and internal.js\n   * @param {?function(!string, *):*} callback\n   * @private\n   */\n\n\n  Repo.prototype.interceptServerData_ = function (callback) {\n    this.interceptServerDataCallback_ = callback;\n  };\n  /**\n   * @param {!boolean} connectStatus\n   * @private\n   */\n\n\n  Repo.prototype.onConnectStatus_ = function (connectStatus) {\n    this.updateInfo_('connected', connectStatus);\n\n    if (connectStatus === false) {\n      this.runOnDisconnectEvents_();\n    }\n  };\n  /**\n   * @param {!Object} updates\n   * @private\n   */\n\n\n  Repo.prototype.onServerInfoUpdate_ = function (updates) {\n    var _this = this;\n\n    util_2.each(updates, function (value, key) {\n      _this.updateInfo_(key, value);\n    });\n  };\n  /**\n   *\n   * @param {!string} pathString\n   * @param {*} value\n   * @private\n   */\n\n\n  Repo.prototype.updateInfo_ = function (pathString, value) {\n    var path = new Path_1.Path('/.info/' + pathString);\n    var newNode = nodeFromJSON_1.nodeFromJSON(value);\n    this.infoData_.updateSnapshot(path, newNode);\n    var events = this.infoSyncTree_.applyServerOverwrite(path, newNode);\n    this.eventQueue_.raiseEventsForChangedPath(path, events);\n  };\n  /**\n   * @return {!number}\n   * @private\n   */\n\n\n  Repo.prototype.getNextWriteId_ = function () {\n    return this.nextWriteId_++;\n  };\n  /**\n   * @param {!Path} path\n   * @param {*} newVal\n   * @param {number|string|null} newPriority\n   * @param {?function(?Error, *=)} onComplete\n   */\n\n\n  Repo.prototype.setWithPriority = function (path, newVal, newPriority, onComplete) {\n    var _this = this;\n\n    this.log_('set', {\n      path: path.toString(),\n      value: newVal,\n      priority: newPriority\n    }); // TODO: Optimize this behavior to either (a) store flag to skip resolving where possible and / or\n    // (b) store unresolved paths on JSON parse\n\n    var serverValues = this.generateServerValues();\n    var newNodeUnresolved = nodeFromJSON_1.nodeFromJSON(newVal, newPriority);\n    var newNode = ServerValues_1.resolveDeferredValueSnapshot(newNodeUnresolved, serverValues);\n    var writeId = this.getNextWriteId_();\n    var events = this.serverSyncTree_.applyUserOverwrite(path, newNode, writeId, true);\n    this.eventQueue_.queueEvents(events);\n    this.server_.put(path.toString(), newNodeUnresolved.val(\n    /*export=*/\n    true), function (status, errorReason) {\n      var success = status === 'ok';\n\n      if (!success) {\n        util_2.warn('set at ' + path + ' failed: ' + status);\n      }\n\n      var clearEvents = _this.serverSyncTree_.ackUserWrite(writeId, !success);\n\n      _this.eventQueue_.raiseEventsForChangedPath(path, clearEvents);\n\n      _this.callOnCompleteCallback(onComplete, status, errorReason);\n    });\n    var affectedPath = this.abortTransactions_(path);\n    this.rerunTransactions_(affectedPath); // We queued the events above, so just flush the queue here\n\n    this.eventQueue_.raiseEventsForChangedPath(affectedPath, []);\n  };\n  /**\n   * @param {!Path} path\n   * @param {!Object} childrenToMerge\n   * @param {?function(?Error, *=)} onComplete\n   */\n\n\n  Repo.prototype.update = function (path, childrenToMerge, onComplete) {\n    var _this = this;\n\n    this.log_('update', {\n      path: path.toString(),\n      value: childrenToMerge\n    }); // Start with our existing data and merge each child into it.\n\n    var empty = true;\n    var serverValues = this.generateServerValues();\n    var changedChildren = {};\n    util_3.forEach(childrenToMerge, function (changedKey, changedValue) {\n      empty = false;\n      var newNodeUnresolved = nodeFromJSON_1.nodeFromJSON(changedValue);\n      changedChildren[changedKey] = ServerValues_1.resolveDeferredValueSnapshot(newNodeUnresolved, serverValues);\n    });\n\n    if (!empty) {\n      var writeId_1 = this.getNextWriteId_();\n      var events = this.serverSyncTree_.applyUserMerge(path, changedChildren, writeId_1);\n      this.eventQueue_.queueEvents(events);\n      this.server_.merge(path.toString(), childrenToMerge, function (status, errorReason) {\n        var success = status === 'ok';\n\n        if (!success) {\n          util_2.warn('update at ' + path + ' failed: ' + status);\n        }\n\n        var clearEvents = _this.serverSyncTree_.ackUserWrite(writeId_1, !success);\n\n        var affectedPath = clearEvents.length > 0 ? _this.rerunTransactions_(path) : path;\n\n        _this.eventQueue_.raiseEventsForChangedPath(affectedPath, clearEvents);\n\n        _this.callOnCompleteCallback(onComplete, status, errorReason);\n      });\n      util_3.forEach(childrenToMerge, function (changedPath) {\n        var affectedPath = _this.abortTransactions_(path.child(changedPath));\n\n        _this.rerunTransactions_(affectedPath);\n      }); // We queued the events above, so just flush the queue here\n\n      this.eventQueue_.raiseEventsForChangedPath(path, []);\n    } else {\n      util_2.log(\"update() called with empty data.  Don't do anything.\");\n      this.callOnCompleteCallback(onComplete, 'ok');\n    }\n  };\n  /**\n   * Applies all of the changes stored up in the onDisconnect_ tree.\n   * @private\n   */\n\n\n  Repo.prototype.runOnDisconnectEvents_ = function () {\n    var _this = this;\n\n    this.log_('onDisconnectEvents');\n    var serverValues = this.generateServerValues();\n    var resolvedOnDisconnectTree = ServerValues_1.resolveDeferredValueTree(this.onDisconnect_, serverValues);\n    var events = [];\n    resolvedOnDisconnectTree.forEachTree(Path_1.Path.Empty, function (path, snap) {\n      events = events.concat(_this.serverSyncTree_.applyServerOverwrite(path, snap));\n\n      var affectedPath = _this.abortTransactions_(path);\n\n      _this.rerunTransactions_(affectedPath);\n    });\n    this.onDisconnect_ = new SparseSnapshotTree_1.SparseSnapshotTree();\n    this.eventQueue_.raiseEventsForChangedPath(Path_1.Path.Empty, events);\n  };\n  /**\n   * @param {!Path} path\n   * @param {?function(?Error, *=)} onComplete\n   */\n\n\n  Repo.prototype.onDisconnectCancel = function (path, onComplete) {\n    var _this = this;\n\n    this.server_.onDisconnectCancel(path.toString(), function (status, errorReason) {\n      if (status === 'ok') {\n        _this.onDisconnect_.forget(path);\n      }\n\n      _this.callOnCompleteCallback(onComplete, status, errorReason);\n    });\n  };\n  /**\n   * @param {!Path} path\n   * @param {*} value\n   * @param {?function(?Error, *=)} onComplete\n   */\n\n\n  Repo.prototype.onDisconnectSet = function (path, value, onComplete) {\n    var _this = this;\n\n    var newNode = nodeFromJSON_1.nodeFromJSON(value);\n    this.server_.onDisconnectPut(path.toString(), newNode.val(\n    /*export=*/\n    true), function (status, errorReason) {\n      if (status === 'ok') {\n        _this.onDisconnect_.remember(path, newNode);\n      }\n\n      _this.callOnCompleteCallback(onComplete, status, errorReason);\n    });\n  };\n  /**\n   * @param {!Path} path\n   * @param {*} value\n   * @param {*} priority\n   * @param {?function(?Error, *=)} onComplete\n   */\n\n\n  Repo.prototype.onDisconnectSetWithPriority = function (path, value, priority, onComplete) {\n    var _this = this;\n\n    var newNode = nodeFromJSON_1.nodeFromJSON(value, priority);\n    this.server_.onDisconnectPut(path.toString(), newNode.val(\n    /*export=*/\n    true), function (status, errorReason) {\n      if (status === 'ok') {\n        _this.onDisconnect_.remember(path, newNode);\n      }\n\n      _this.callOnCompleteCallback(onComplete, status, errorReason);\n    });\n  };\n  /**\n   * @param {!Path} path\n   * @param {*} childrenToMerge\n   * @param {?function(?Error, *=)} onComplete\n   */\n\n\n  Repo.prototype.onDisconnectUpdate = function (path, childrenToMerge, onComplete) {\n    var _this = this;\n\n    if (util_3.isEmpty(childrenToMerge)) {\n      util_2.log(\"onDisconnect().update() called with empty data.  Don't do anything.\");\n      this.callOnCompleteCallback(onComplete, 'ok');\n      return;\n    }\n\n    this.server_.onDisconnectMerge(path.toString(), childrenToMerge, function (status, errorReason) {\n      if (status === 'ok') {\n        util_3.forEach(childrenToMerge, function (childName, childNode) {\n          var newChildNode = nodeFromJSON_1.nodeFromJSON(childNode);\n\n          _this.onDisconnect_.remember(path.child(childName), newChildNode);\n        });\n      }\n\n      _this.callOnCompleteCallback(onComplete, status, errorReason);\n    });\n  };\n  /**\n   * @param {!Query} query\n   * @param {!EventRegistration} eventRegistration\n   */\n\n\n  Repo.prototype.addEventCallbackForQuery = function (query, eventRegistration) {\n    var events;\n\n    if (query.path.getFront() === '.info') {\n      events = this.infoSyncTree_.addEventRegistration(query, eventRegistration);\n    } else {\n      events = this.serverSyncTree_.addEventRegistration(query, eventRegistration);\n    }\n\n    this.eventQueue_.raiseEventsAtPath(query.path, events);\n  };\n  /**\n   * @param {!Query} query\n   * @param {?EventRegistration} eventRegistration\n   */\n\n\n  Repo.prototype.removeEventCallbackForQuery = function (query, eventRegistration) {\n    // These are guaranteed not to raise events, since we're not passing in a cancelError. However, we can future-proof\n    // a little bit by handling the return values anyways.\n    var events;\n\n    if (query.path.getFront() === '.info') {\n      events = this.infoSyncTree_.removeEventRegistration(query, eventRegistration);\n    } else {\n      events = this.serverSyncTree_.removeEventRegistration(query, eventRegistration);\n    }\n\n    this.eventQueue_.raiseEventsAtPath(query.path, events);\n  };\n\n  Repo.prototype.interrupt = function () {\n    if (this.persistentConnection_) {\n      this.persistentConnection_.interrupt(INTERRUPT_REASON);\n    }\n  };\n\n  Repo.prototype.resume = function () {\n    if (this.persistentConnection_) {\n      this.persistentConnection_.resume(INTERRUPT_REASON);\n    }\n  };\n\n  Repo.prototype.stats = function (showDelta) {\n    if (showDelta === void 0) {\n      showDelta = false;\n    }\n\n    if (typeof console === 'undefined') return;\n    var stats;\n\n    if (showDelta) {\n      if (!this.statsListener_) this.statsListener_ = new StatsListener_1.StatsListener(this.stats_);\n      stats = this.statsListener_.get();\n    } else {\n      stats = this.stats_.get();\n    }\n\n    var longestName = Object.keys(stats).reduce(function (previousValue, currentValue) {\n      return Math.max(currentValue.length, previousValue);\n    }, 0);\n    util_3.forEach(stats, function (stat, value) {\n      // pad stat names to be the same length (plus 2 extra spaces).\n      for (var i = stat.length; i < longestName + 2; i++) stat += ' ';\n\n      console.log(stat + value);\n    });\n  };\n\n  Repo.prototype.statsIncrementCounter = function (metric) {\n    this.stats_.incrementCounter(metric);\n    this.statsReporter_.includeStat(metric);\n  };\n  /**\n   * @param {...*} var_args\n   * @private\n   */\n\n\n  Repo.prototype.log_ = function () {\n    var var_args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      var_args[_i] = arguments[_i];\n    }\n\n    var prefix = '';\n\n    if (this.persistentConnection_) {\n      prefix = this.persistentConnection_.id + ':';\n    }\n\n    util_2.log.apply(void 0, [prefix].concat(var_args));\n  };\n  /**\n   * @param {?function(?Error, *=)} callback\n   * @param {!string} status\n   * @param {?string=} errorReason\n   */\n\n\n  Repo.prototype.callOnCompleteCallback = function (callback, status, errorReason) {\n    if (callback) {\n      util_2.exceptionGuard(function () {\n        if (status == 'ok') {\n          callback(null);\n        } else {\n          var code = (status || 'error').toUpperCase();\n          var message = code;\n          if (errorReason) message += ': ' + errorReason;\n          var error = new Error(message);\n          error.code = code;\n          callback(error);\n        }\n      });\n    }\n  };\n\n  Object.defineProperty(Repo.prototype, \"database\", {\n    get: function () {\n      return this.__database || (this.__database = new Database_1.Database(this));\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return Repo;\n}();\n\nexports.Repo = Repo;","map":{"version":3,"sources":["../src/core/Repo.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  generateWithValues,\n  resolveDeferredValueSnapshot,\n  resolveDeferredValueTree\n} from './util/ServerValues';\nimport { nodeFromJSON } from './snap/nodeFromJSON';\nimport { Path } from './util/Path';\nimport { SparseSnapshotTree } from './SparseSnapshotTree';\nimport { SyncTree } from './SyncTree';\nimport { SnapshotHolder } from './SnapshotHolder';\nimport { stringify } from '@firebase/util';\nimport { beingCrawled, each, exceptionGuard, warn, log } from './util/util';\nimport { map, forEach, isEmpty } from '@firebase/util';\nimport { AuthTokenProvider } from './AuthTokenProvider';\nimport { StatsManager } from './stats/StatsManager';\nimport { StatsReporter } from './stats/StatsReporter';\nimport { StatsListener } from './stats/StatsListener';\nimport { EventQueue } from './view/EventQueue';\nimport { PersistentConnection } from './PersistentConnection';\nimport { ReadonlyRestClient } from './ReadonlyRestClient';\nimport { FirebaseApp } from '@firebase/app-types';\nimport { RepoInfo } from './RepoInfo';\nimport { Database } from '../api/Database';\nimport { ServerActions } from './ServerActions';\nimport { Query } from '../api/Query';\nimport { EventRegistration } from './view/EventRegistration';\nimport { StatsCollection } from './stats/StatsCollection';\nimport { Event } from './view/Event';\nimport { Node } from './snap/Node';\n\nconst INTERRUPT_REASON = 'repo_interrupt';\n\n/**\n * A connection to a single data repository.\n */\nexport class Repo {\n  dataUpdateCount = 0;\n  private infoSyncTree_: SyncTree;\n  private serverSyncTree_: SyncTree;\n\n  private stats_: StatsCollection;\n  private statsListener_: StatsListener | null = null;\n  private eventQueue_ = new EventQueue();\n  private nextWriteId_ = 1;\n  private server_: ServerActions;\n  private statsReporter_: StatsReporter;\n  private transactions_init_: () => void;\n  private infoData_: SnapshotHolder;\n  private abortTransactions_: (path: Path) => Path;\n  private rerunTransactions_: (changedPath: Path) => Path;\n  private interceptServerDataCallback_:\n    | ((a: string, b: any) => void)\n    | null = null;\n  private __database: Database;\n\n  // A list of data pieces and paths to be set when this client disconnects.\n  private onDisconnect_ = new SparseSnapshotTree();\n\n  /**\n   * TODO: This should be @private but it's used by test_access.js and internal.js\n   * @type {?PersistentConnection}\n   */\n  persistentConnection_: PersistentConnection | null = null;\n\n  /**\n   * @param {!RepoInfo} repoInfo_\n   * @param {boolean} forceRestClient\n   * @param {!FirebaseApp} app\n   */\n  constructor(\n    public repoInfo_: RepoInfo,\n    forceRestClient: boolean,\n    public app: FirebaseApp\n  ) {\n    /** @type {!AuthTokenProvider} */\n    const authTokenProvider = new AuthTokenProvider(app);\n\n    this.stats_ = StatsManager.getCollection(repoInfo_);\n\n    if (forceRestClient || beingCrawled()) {\n      this.server_ = new ReadonlyRestClient(\n        this.repoInfo_,\n        this.onDataUpdate_.bind(this),\n        authTokenProvider\n      );\n\n      // Minor hack: Fire onConnect immediately, since there's no actual connection.\n      setTimeout(this.onConnectStatus_.bind(this, true), 0);\n    } else {\n      const authOverride = app.options['databaseAuthVariableOverride'];\n      // Validate authOverride\n      if (typeof authOverride !== 'undefined' && authOverride !== null) {\n        if (typeof authOverride !== 'object') {\n          throw new Error(\n            'Only objects are supported for option databaseAuthVariableOverride'\n          );\n        }\n        try {\n          stringify(authOverride);\n        } catch (e) {\n          throw new Error('Invalid authOverride provided: ' + e);\n        }\n      }\n\n      this.persistentConnection_ = new PersistentConnection(\n        this.repoInfo_,\n        this.onDataUpdate_.bind(this),\n        this.onConnectStatus_.bind(this),\n        this.onServerInfoUpdate_.bind(this),\n        authTokenProvider,\n        authOverride\n      );\n\n      this.server_ = this.persistentConnection_;\n    }\n\n    authTokenProvider.addTokenChangeListener(token => {\n      this.server_.refreshAuthToken(token);\n    });\n\n    // In the case of multiple Repos for the same repoInfo (i.e. there are multiple Firebase.Contexts being used),\n    // we only want to create one StatsReporter.  As such, we'll report stats over the first Repo created.\n    this.statsReporter_ = StatsManager.getOrCreateReporter(\n      repoInfo_,\n      () => new StatsReporter(this.stats_, this.server_)\n    );\n\n    this.transactions_init_();\n\n    // Used for .info.\n    this.infoData_ = new SnapshotHolder();\n    this.infoSyncTree_ = new SyncTree({\n      startListening: (query, tag, currentHashFn, onComplete) => {\n        let infoEvents: Event[] = [];\n        const node = this.infoData_.getNode(query.path);\n        // This is possibly a hack, but we have different semantics for .info endpoints. We don't raise null events\n        // on initial data...\n        if (!node.isEmpty()) {\n          infoEvents = this.infoSyncTree_.applyServerOverwrite(\n            query.path,\n            node\n          );\n          setTimeout(() => {\n            onComplete('ok');\n          }, 0);\n        }\n        return infoEvents;\n      },\n      stopListening: () => {}\n    });\n    this.updateInfo_('connected', false);\n\n    this.serverSyncTree_ = new SyncTree({\n      startListening: (query, tag, currentHashFn, onComplete) => {\n        this.server_.listen(query, currentHashFn, tag, (status, data) => {\n          const events = onComplete(status, data);\n          this.eventQueue_.raiseEventsForChangedPath(query.path, events);\n        });\n        // No synchronous events for network-backed sync trees\n        return [];\n      },\n      stopListening: (query, tag) => {\n        this.server_.unlisten(query, tag);\n      }\n    });\n  }\n\n  /**\n   * @return {string}  The URL corresponding to the root of this Firebase.\n   */\n  toString(): string {\n    return (\n      (this.repoInfo_.secure ? 'https://' : 'http://') + this.repoInfo_.host\n    );\n  }\n\n  /**\n   * @return {!string} The namespace represented by the repo.\n   */\n  name(): string {\n    return this.repoInfo_.namespace;\n  }\n\n  /**\n   * @return {!number} The time in milliseconds, taking the server offset into account if we have one.\n   */\n  serverTime(): number {\n    const offsetNode = this.infoData_.getNode(\n      new Path('.info/serverTimeOffset')\n    );\n    const offset = (offsetNode.val() as number) || 0;\n    return new Date().getTime() + offset;\n  }\n\n  /**\n   * Generate ServerValues using some variables from the repo object.\n   * @return {!Object}\n   */\n  generateServerValues(): Object {\n    return generateWithValues({\n      timestamp: this.serverTime()\n    });\n  }\n\n  /**\n   * Called by realtime when we get new messages from the server.\n   *\n   * @private\n   * @param {string} pathString\n   * @param {*} data\n   * @param {boolean} isMerge\n   * @param {?number} tag\n   */\n  private onDataUpdate_(\n    pathString: string,\n    data: any,\n    isMerge: boolean,\n    tag: number | null\n  ) {\n    // For testing.\n    this.dataUpdateCount++;\n    const path = new Path(pathString);\n    data = this.interceptServerDataCallback_\n      ? this.interceptServerDataCallback_(pathString, data)\n      : data;\n    let events = [];\n    if (tag) {\n      if (isMerge) {\n        const taggedChildren = map(data as { [k: string]: any }, (raw: any) =>\n          nodeFromJSON(raw)\n        );\n        events = this.serverSyncTree_.applyTaggedQueryMerge(\n          path,\n          taggedChildren,\n          tag\n        );\n      } else {\n        const taggedSnap = nodeFromJSON(data);\n        events = this.serverSyncTree_.applyTaggedQueryOverwrite(\n          path,\n          taggedSnap,\n          tag\n        );\n      }\n    } else if (isMerge) {\n      const changedChildren = map(data as { [k: string]: any }, (raw: any) =>\n        nodeFromJSON(raw)\n      );\n      events = this.serverSyncTree_.applyServerMerge(path, changedChildren);\n    } else {\n      const snap = nodeFromJSON(data);\n      events = this.serverSyncTree_.applyServerOverwrite(path, snap);\n    }\n    let affectedPath = path;\n    if (events.length > 0) {\n      // Since we have a listener outstanding for each transaction, receiving any events\n      // is a proxy for some change having occurred.\n      affectedPath = this.rerunTransactions_(path);\n    }\n    this.eventQueue_.raiseEventsForChangedPath(affectedPath, events);\n  }\n\n  /**\n   * TODO: This should be @private but it's used by test_access.js and internal.js\n   * @param {?function(!string, *):*} callback\n   * @private\n   */\n  interceptServerData_(callback: ((a: string, b: any) => any) | null) {\n    this.interceptServerDataCallback_ = callback;\n  }\n\n  /**\n   * @param {!boolean} connectStatus\n   * @private\n   */\n  private onConnectStatus_(connectStatus: boolean) {\n    this.updateInfo_('connected', connectStatus);\n    if (connectStatus === false) {\n      this.runOnDisconnectEvents_();\n    }\n  }\n\n  /**\n   * @param {!Object} updates\n   * @private\n   */\n  private onServerInfoUpdate_(updates: Object) {\n    each(updates, (value: any, key: string) => {\n      this.updateInfo_(key, value);\n    });\n  }\n\n  /**\n   *\n   * @param {!string} pathString\n   * @param {*} value\n   * @private\n   */\n  private updateInfo_(pathString: string, value: any) {\n    const path = new Path('/.info/' + pathString);\n    const newNode = nodeFromJSON(value);\n    this.infoData_.updateSnapshot(path, newNode);\n    const events = this.infoSyncTree_.applyServerOverwrite(path, newNode);\n    this.eventQueue_.raiseEventsForChangedPath(path, events);\n  }\n\n  /**\n   * @return {!number}\n   * @private\n   */\n  private getNextWriteId_(): number {\n    return this.nextWriteId_++;\n  }\n\n  /**\n   * @param {!Path} path\n   * @param {*} newVal\n   * @param {number|string|null} newPriority\n   * @param {?function(?Error, *=)} onComplete\n   */\n  setWithPriority(\n    path: Path,\n    newVal: any,\n    newPriority: number | string | null,\n    onComplete: ((status: Error | null, errorReason?: string) => void) | null\n  ) {\n    this.log_('set', {\n      path: path.toString(),\n      value: newVal,\n      priority: newPriority\n    });\n\n    // TODO: Optimize this behavior to either (a) store flag to skip resolving where possible and / or\n    // (b) store unresolved paths on JSON parse\n    const serverValues = this.generateServerValues();\n    const newNodeUnresolved = nodeFromJSON(newVal, newPriority);\n    const newNode = resolveDeferredValueSnapshot(\n      newNodeUnresolved,\n      serverValues\n    );\n\n    const writeId = this.getNextWriteId_();\n    const events = this.serverSyncTree_.applyUserOverwrite(\n      path,\n      newNode,\n      writeId,\n      true\n    );\n    this.eventQueue_.queueEvents(events);\n    this.server_.put(\n      path.toString(),\n      newNodeUnresolved.val(/*export=*/ true),\n      (status, errorReason) => {\n        const success = status === 'ok';\n        if (!success) {\n          warn('set at ' + path + ' failed: ' + status);\n        }\n\n        const clearEvents = this.serverSyncTree_.ackUserWrite(\n          writeId,\n          !success\n        );\n        this.eventQueue_.raiseEventsForChangedPath(path, clearEvents);\n        this.callOnCompleteCallback(onComplete, status, errorReason);\n      }\n    );\n    const affectedPath = this.abortTransactions_(path);\n    this.rerunTransactions_(affectedPath);\n    // We queued the events above, so just flush the queue here\n    this.eventQueue_.raiseEventsForChangedPath(affectedPath, []);\n  }\n\n  /**\n   * @param {!Path} path\n   * @param {!Object} childrenToMerge\n   * @param {?function(?Error, *=)} onComplete\n   */\n  update(\n    path: Path,\n    childrenToMerge: { [k: string]: any },\n    onComplete: ((status: Error | null, errorReason?: string) => void) | null\n  ) {\n    this.log_('update', { path: path.toString(), value: childrenToMerge });\n\n    // Start with our existing data and merge each child into it.\n    let empty = true;\n    const serverValues = this.generateServerValues();\n    const changedChildren: { [k: string]: Node } = {};\n    forEach(childrenToMerge, (changedKey: string, changedValue: any) => {\n      empty = false;\n      const newNodeUnresolved = nodeFromJSON(changedValue);\n      changedChildren[changedKey] = resolveDeferredValueSnapshot(\n        newNodeUnresolved,\n        serverValues\n      );\n    });\n\n    if (!empty) {\n      const writeId = this.getNextWriteId_();\n      const events = this.serverSyncTree_.applyUserMerge(\n        path,\n        changedChildren,\n        writeId\n      );\n      this.eventQueue_.queueEvents(events);\n      this.server_.merge(\n        path.toString(),\n        childrenToMerge,\n        (status, errorReason) => {\n          const success = status === 'ok';\n          if (!success) {\n            warn('update at ' + path + ' failed: ' + status);\n          }\n\n          const clearEvents = this.serverSyncTree_.ackUserWrite(\n            writeId,\n            !success\n          );\n          const affectedPath =\n            clearEvents.length > 0 ? this.rerunTransactions_(path) : path;\n          this.eventQueue_.raiseEventsForChangedPath(affectedPath, clearEvents);\n          this.callOnCompleteCallback(onComplete, status, errorReason);\n        }\n      );\n\n      forEach(childrenToMerge, (changedPath: string) => {\n        const affectedPath = this.abortTransactions_(path.child(changedPath));\n        this.rerunTransactions_(affectedPath);\n      });\n\n      // We queued the events above, so just flush the queue here\n      this.eventQueue_.raiseEventsForChangedPath(path, []);\n    } else {\n      log(\"update() called with empty data.  Don't do anything.\");\n      this.callOnCompleteCallback(onComplete, 'ok');\n    }\n  }\n\n  /**\n   * Applies all of the changes stored up in the onDisconnect_ tree.\n   * @private\n   */\n  private runOnDisconnectEvents_() {\n    this.log_('onDisconnectEvents');\n\n    const serverValues = this.generateServerValues();\n    const resolvedOnDisconnectTree = resolveDeferredValueTree(\n      this.onDisconnect_,\n      serverValues\n    );\n    let events: Event[] = [];\n\n    resolvedOnDisconnectTree.forEachTree(Path.Empty, (path, snap) => {\n      events = events.concat(\n        this.serverSyncTree_.applyServerOverwrite(path, snap)\n      );\n      const affectedPath = this.abortTransactions_(path);\n      this.rerunTransactions_(affectedPath);\n    });\n\n    this.onDisconnect_ = new SparseSnapshotTree();\n    this.eventQueue_.raiseEventsForChangedPath(Path.Empty, events);\n  }\n\n  /**\n   * @param {!Path} path\n   * @param {?function(?Error, *=)} onComplete\n   */\n  onDisconnectCancel(\n    path: Path,\n    onComplete: ((status: Error | null, errorReason?: string) => void) | null\n  ) {\n    this.server_.onDisconnectCancel(path.toString(), (status, errorReason) => {\n      if (status === 'ok') {\n        this.onDisconnect_.forget(path);\n      }\n      this.callOnCompleteCallback(onComplete, status, errorReason);\n    });\n  }\n\n  /**\n   * @param {!Path} path\n   * @param {*} value\n   * @param {?function(?Error, *=)} onComplete\n   */\n  onDisconnectSet(\n    path: Path,\n    value: any,\n    onComplete: ((status: Error | null, errorReason?: string) => void) | null\n  ) {\n    const newNode = nodeFromJSON(value);\n    this.server_.onDisconnectPut(\n      path.toString(),\n      newNode.val(/*export=*/ true),\n      (status, errorReason) => {\n        if (status === 'ok') {\n          this.onDisconnect_.remember(path, newNode);\n        }\n        this.callOnCompleteCallback(onComplete, status, errorReason);\n      }\n    );\n  }\n\n  /**\n   * @param {!Path} path\n   * @param {*} value\n   * @param {*} priority\n   * @param {?function(?Error, *=)} onComplete\n   */\n  onDisconnectSetWithPriority(\n    path: Path,\n    value: any,\n    priority: any,\n    onComplete: ((status: Error | null, errorReason?: string) => void) | null\n  ) {\n    const newNode = nodeFromJSON(value, priority);\n    this.server_.onDisconnectPut(\n      path.toString(),\n      newNode.val(/*export=*/ true),\n      (status, errorReason) => {\n        if (status === 'ok') {\n          this.onDisconnect_.remember(path, newNode);\n        }\n        this.callOnCompleteCallback(onComplete, status, errorReason);\n      }\n    );\n  }\n\n  /**\n   * @param {!Path} path\n   * @param {*} childrenToMerge\n   * @param {?function(?Error, *=)} onComplete\n   */\n  onDisconnectUpdate(\n    path: Path,\n    childrenToMerge: { [k: string]: any },\n    onComplete: ((status: Error | null, errorReason?: string) => void) | null\n  ) {\n    if (isEmpty(childrenToMerge)) {\n      log(\n        \"onDisconnect().update() called with empty data.  Don't do anything.\"\n      );\n      this.callOnCompleteCallback(onComplete, 'ok');\n      return;\n    }\n\n    this.server_.onDisconnectMerge(\n      path.toString(),\n      childrenToMerge,\n      (status, errorReason) => {\n        if (status === 'ok') {\n          forEach(childrenToMerge, (childName: string, childNode: any) => {\n            const newChildNode = nodeFromJSON(childNode);\n            this.onDisconnect_.remember(path.child(childName), newChildNode);\n          });\n        }\n        this.callOnCompleteCallback(onComplete, status, errorReason);\n      }\n    );\n  }\n\n  /**\n   * @param {!Query} query\n   * @param {!EventRegistration} eventRegistration\n   */\n  addEventCallbackForQuery(query: Query, eventRegistration: EventRegistration) {\n    let events;\n    if (query.path.getFront() === '.info') {\n      events = this.infoSyncTree_.addEventRegistration(\n        query,\n        eventRegistration\n      );\n    } else {\n      events = this.serverSyncTree_.addEventRegistration(\n        query,\n        eventRegistration\n      );\n    }\n    this.eventQueue_.raiseEventsAtPath(query.path, events);\n  }\n\n  /**\n   * @param {!Query} query\n   * @param {?EventRegistration} eventRegistration\n   */\n  removeEventCallbackForQuery(\n    query: Query,\n    eventRegistration: EventRegistration\n  ) {\n    // These are guaranteed not to raise events, since we're not passing in a cancelError. However, we can future-proof\n    // a little bit by handling the return values anyways.\n    let events;\n    if (query.path.getFront() === '.info') {\n      events = this.infoSyncTree_.removeEventRegistration(\n        query,\n        eventRegistration\n      );\n    } else {\n      events = this.serverSyncTree_.removeEventRegistration(\n        query,\n        eventRegistration\n      );\n    }\n    this.eventQueue_.raiseEventsAtPath(query.path, events);\n  }\n\n  interrupt() {\n    if (this.persistentConnection_) {\n      this.persistentConnection_.interrupt(INTERRUPT_REASON);\n    }\n  }\n\n  resume() {\n    if (this.persistentConnection_) {\n      this.persistentConnection_.resume(INTERRUPT_REASON);\n    }\n  }\n\n  stats(showDelta: boolean = false) {\n    if (typeof console === 'undefined') return;\n\n    let stats: { [k: string]: any };\n    if (showDelta) {\n      if (!this.statsListener_)\n        this.statsListener_ = new StatsListener(this.stats_);\n      stats = this.statsListener_.get();\n    } else {\n      stats = this.stats_.get();\n    }\n\n    const longestName = Object.keys(stats).reduce(\n      (previousValue, currentValue) =>\n        Math.max(currentValue.length, previousValue),\n      0\n    );\n\n    forEach(stats, (stat: string, value: any) => {\n      // pad stat names to be the same length (plus 2 extra spaces).\n      for (let i = stat.length; i < longestName + 2; i++) stat += ' ';\n      console.log(stat + value);\n    });\n  }\n\n  statsIncrementCounter(metric: string) {\n    this.stats_.incrementCounter(metric);\n    this.statsReporter_.includeStat(metric);\n  }\n\n  /**\n   * @param {...*} var_args\n   * @private\n   */\n  private log_(...var_args: any[]) {\n    let prefix = '';\n    if (this.persistentConnection_) {\n      prefix = this.persistentConnection_.id + ':';\n    }\n    log(prefix, ...var_args);\n  }\n\n  /**\n   * @param {?function(?Error, *=)} callback\n   * @param {!string} status\n   * @param {?string=} errorReason\n   */\n  callOnCompleteCallback(\n    callback: ((status: Error | null, errorReason?: string) => void) | null,\n    status: string,\n    errorReason?: string | null\n  ) {\n    if (callback) {\n      exceptionGuard(function() {\n        if (status == 'ok') {\n          callback(null);\n        } else {\n          const code = (status || 'error').toUpperCase();\n          let message = code;\n          if (errorReason) message += ': ' + errorReason;\n\n          const error = new Error(message);\n          (error as any).code = code;\n          callback(error);\n        }\n      });\n    }\n  }\n\n  get database(): Database {\n    return this.__database || (this.__database = new Database(this));\n  }\n}\n"]},"metadata":{},"sourceType":"script"}