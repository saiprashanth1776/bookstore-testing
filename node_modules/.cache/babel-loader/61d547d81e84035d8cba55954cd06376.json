{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar tslib_1 = require(\"tslib\");\n\nvar util_1 = require(\"@firebase/util\");\n\nvar util_2 = require(\"../util/util\");\n\nvar SortedMap_1 = require(\"../util/SortedMap\");\n\nvar Node_1 = require(\"./Node\");\n\nvar snap_1 = require(\"./snap\");\n\nvar PriorityIndex_1 = require(\"./indexes/PriorityIndex\");\n\nvar KeyIndex_1 = require(\"./indexes/KeyIndex\");\n\nvar IndexMap_1 = require(\"./IndexMap\");\n\nvar LeafNode_1 = require(\"./LeafNode\");\n\nvar comparators_1 = require(\"./comparators\"); // TODO: For memory savings, don't store priorityNode_ if it's empty.\n\n\nvar EMPTY_NODE;\n/**\n * ChildrenNode is a class for storing internal nodes in a DataSnapshot\n * (i.e. nodes with children).  It implements Node and stores the\n * list of children in the children property, sorted by child name.\n *\n * @constructor\n * @implements {Node}\n */\n\nvar ChildrenNode =\n/** @class */\nfunction () {\n  /**\n   *\n   * @param {!SortedMap.<string, !Node>} children_ List of children\n   * of this node..\n   * @param {?Node} priorityNode_ The priority of this node (as a snapshot node).\n   * @param {!IndexMap} indexMap_\n   */\n  function ChildrenNode(children_, priorityNode_, indexMap_) {\n    this.children_ = children_;\n    this.priorityNode_ = priorityNode_;\n    this.indexMap_ = indexMap_;\n    this.lazyHash_ = null;\n    /**\n     * Note: The only reason we allow null priority is for EMPTY_NODE, since we can't use\n     * EMPTY_NODE as the priority of EMPTY_NODE.  We might want to consider making EMPTY_NODE its own\n     * class instead of an empty ChildrenNode.\n     */\n\n    if (this.priorityNode_) {\n      snap_1.validatePriorityNode(this.priorityNode_);\n    }\n\n    if (this.children_.isEmpty()) {\n      util_1.assert(!this.priorityNode_ || this.priorityNode_.isEmpty(), 'An empty node cannot have a priority');\n    }\n  }\n\n  Object.defineProperty(ChildrenNode, \"EMPTY_NODE\", {\n    get: function () {\n      return EMPTY_NODE || (EMPTY_NODE = new ChildrenNode(new SortedMap_1.SortedMap(comparators_1.NAME_COMPARATOR), null, IndexMap_1.IndexMap.Default));\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /** @inheritDoc */\n\n  ChildrenNode.prototype.isLeafNode = function () {\n    return false;\n  };\n  /** @inheritDoc */\n\n\n  ChildrenNode.prototype.getPriority = function () {\n    return this.priorityNode_ || EMPTY_NODE;\n  };\n  /** @inheritDoc */\n\n\n  ChildrenNode.prototype.updatePriority = function (newPriorityNode) {\n    if (this.children_.isEmpty()) {\n      // Don't allow priorities on empty nodes\n      return this;\n    } else {\n      return new ChildrenNode(this.children_, newPriorityNode, this.indexMap_);\n    }\n  };\n  /** @inheritDoc */\n\n\n  ChildrenNode.prototype.getImmediateChild = function (childName) {\n    // Hack to treat priority as a regular child\n    if (childName === '.priority') {\n      return this.getPriority();\n    } else {\n      var child = this.children_.get(childName);\n      return child === null ? EMPTY_NODE : child;\n    }\n  };\n  /** @inheritDoc */\n\n\n  ChildrenNode.prototype.getChild = function (path) {\n    var front = path.getFront();\n    if (front === null) return this;\n    return this.getImmediateChild(front).getChild(path.popFront());\n  };\n  /** @inheritDoc */\n\n\n  ChildrenNode.prototype.hasChild = function (childName) {\n    return this.children_.get(childName) !== null;\n  };\n  /** @inheritDoc */\n\n\n  ChildrenNode.prototype.updateImmediateChild = function (childName, newChildNode) {\n    util_1.assert(newChildNode, 'We should always be passing snapshot nodes');\n\n    if (childName === '.priority') {\n      return this.updatePriority(newChildNode);\n    } else {\n      var namedNode = new Node_1.NamedNode(childName, newChildNode);\n      var newChildren = void 0,\n          newIndexMap = void 0,\n          newPriority = void 0;\n\n      if (newChildNode.isEmpty()) {\n        newChildren = this.children_.remove(childName);\n        newIndexMap = this.indexMap_.removeFromIndexes(namedNode, this.children_);\n      } else {\n        newChildren = this.children_.insert(childName, newChildNode);\n        newIndexMap = this.indexMap_.addToIndexes(namedNode, this.children_);\n      }\n\n      newPriority = newChildren.isEmpty() ? EMPTY_NODE : this.priorityNode_;\n      return new ChildrenNode(newChildren, newPriority, newIndexMap);\n    }\n  };\n  /** @inheritDoc */\n\n\n  ChildrenNode.prototype.updateChild = function (path, newChildNode) {\n    var front = path.getFront();\n\n    if (front === null) {\n      return newChildNode;\n    } else {\n      util_1.assert(path.getFront() !== '.priority' || path.getLength() === 1, '.priority must be the last token in a path');\n      var newImmediateChild = this.getImmediateChild(front).updateChild(path.popFront(), newChildNode);\n      return this.updateImmediateChild(front, newImmediateChild);\n    }\n  };\n  /** @inheritDoc */\n\n\n  ChildrenNode.prototype.isEmpty = function () {\n    return this.children_.isEmpty();\n  };\n  /** @inheritDoc */\n\n\n  ChildrenNode.prototype.numChildren = function () {\n    return this.children_.count();\n  };\n  /** @inheritDoc */\n\n\n  ChildrenNode.prototype.val = function (exportFormat) {\n    if (this.isEmpty()) return null;\n    var obj = {};\n    var numKeys = 0,\n        maxKey = 0,\n        allIntegerKeys = true;\n    this.forEachChild(PriorityIndex_1.PRIORITY_INDEX, function (key, childNode) {\n      obj[key] = childNode.val(exportFormat);\n      numKeys++;\n\n      if (allIntegerKeys && ChildrenNode.INTEGER_REGEXP_.test(key)) {\n        maxKey = Math.max(maxKey, Number(key));\n      } else {\n        allIntegerKeys = false;\n      }\n    });\n\n    if (!exportFormat && allIntegerKeys && maxKey < 2 * numKeys) {\n      // convert to array.\n      var array = [];\n\n      for (var key in obj) array[key] = obj[key];\n\n      return array;\n    } else {\n      if (exportFormat && !this.getPriority().isEmpty()) {\n        obj['.priority'] = this.getPriority().val();\n      }\n\n      return obj;\n    }\n  };\n  /** @inheritDoc */\n\n\n  ChildrenNode.prototype.hash = function () {\n    if (this.lazyHash_ === null) {\n      var toHash_1 = '';\n      if (!this.getPriority().isEmpty()) toHash_1 += 'priority:' + snap_1.priorityHashText(this.getPriority().val()) + ':';\n      this.forEachChild(PriorityIndex_1.PRIORITY_INDEX, function (key, childNode) {\n        var childHash = childNode.hash();\n        if (childHash !== '') toHash_1 += ':' + key + ':' + childHash;\n      });\n      this.lazyHash_ = toHash_1 === '' ? '' : util_2.sha1(toHash_1);\n    }\n\n    return this.lazyHash_;\n  };\n  /** @inheritDoc */\n\n\n  ChildrenNode.prototype.getPredecessorChildName = function (childName, childNode, index) {\n    var idx = this.resolveIndex_(index);\n\n    if (idx) {\n      var predecessor = idx.getPredecessorKey(new Node_1.NamedNode(childName, childNode));\n      return predecessor ? predecessor.name : null;\n    } else {\n      return this.children_.getPredecessorKey(childName);\n    }\n  };\n  /**\n   * @param {!Index} indexDefinition\n   * @return {?string}\n   */\n\n\n  ChildrenNode.prototype.getFirstChildName = function (indexDefinition) {\n    var idx = this.resolveIndex_(indexDefinition);\n\n    if (idx) {\n      var minKey = idx.minKey();\n      return minKey && minKey.name;\n    } else {\n      return this.children_.minKey();\n    }\n  };\n  /**\n   * @param {!Index} indexDefinition\n   * @return {?NamedNode}\n   */\n\n\n  ChildrenNode.prototype.getFirstChild = function (indexDefinition) {\n    var minKey = this.getFirstChildName(indexDefinition);\n\n    if (minKey) {\n      return new Node_1.NamedNode(minKey, this.children_.get(minKey));\n    } else {\n      return null;\n    }\n  };\n  /**\n   * Given an index, return the key name of the largest value we have, according to that index\n   * @param {!Index} indexDefinition\n   * @return {?string}\n   */\n\n\n  ChildrenNode.prototype.getLastChildName = function (indexDefinition) {\n    var idx = this.resolveIndex_(indexDefinition);\n\n    if (idx) {\n      var maxKey = idx.maxKey();\n      return maxKey && maxKey.name;\n    } else {\n      return this.children_.maxKey();\n    }\n  };\n  /**\n   * @param {!Index} indexDefinition\n   * @return {?NamedNode}\n   */\n\n\n  ChildrenNode.prototype.getLastChild = function (indexDefinition) {\n    var maxKey = this.getLastChildName(indexDefinition);\n\n    if (maxKey) {\n      return new Node_1.NamedNode(maxKey, this.children_.get(maxKey));\n    } else {\n      return null;\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  ChildrenNode.prototype.forEachChild = function (index, action) {\n    var idx = this.resolveIndex_(index);\n\n    if (idx) {\n      return idx.inorderTraversal(function (wrappedNode) {\n        return action(wrappedNode.name, wrappedNode.node);\n      });\n    } else {\n      return this.children_.inorderTraversal(action);\n    }\n  };\n  /**\n   * @param {!Index} indexDefinition\n   * @return {SortedMapIterator}\n   */\n\n\n  ChildrenNode.prototype.getIterator = function (indexDefinition) {\n    return this.getIteratorFrom(indexDefinition.minPost(), indexDefinition);\n  };\n  /**\n   *\n   * @param {!NamedNode} startPost\n   * @param {!Index} indexDefinition\n   * @return {!SortedMapIterator}\n   */\n\n\n  ChildrenNode.prototype.getIteratorFrom = function (startPost, indexDefinition) {\n    var idx = this.resolveIndex_(indexDefinition);\n\n    if (idx) {\n      return idx.getIteratorFrom(startPost, function (key) {\n        return key;\n      });\n    } else {\n      var iterator = this.children_.getIteratorFrom(startPost.name, Node_1.NamedNode.Wrap);\n      var next = iterator.peek();\n\n      while (next != null && indexDefinition.compare(next, startPost) < 0) {\n        iterator.getNext();\n        next = iterator.peek();\n      }\n\n      return iterator;\n    }\n  };\n  /**\n   * @param {!Index} indexDefinition\n   * @return {!SortedMapIterator}\n   */\n\n\n  ChildrenNode.prototype.getReverseIterator = function (indexDefinition) {\n    return this.getReverseIteratorFrom(indexDefinition.maxPost(), indexDefinition);\n  };\n  /**\n   * @param {!NamedNode} endPost\n   * @param {!Index} indexDefinition\n   * @return {!SortedMapIterator}\n   */\n\n\n  ChildrenNode.prototype.getReverseIteratorFrom = function (endPost, indexDefinition) {\n    var idx = this.resolveIndex_(indexDefinition);\n\n    if (idx) {\n      return idx.getReverseIteratorFrom(endPost, function (key) {\n        return key;\n      });\n    } else {\n      var iterator = this.children_.getReverseIteratorFrom(endPost.name, Node_1.NamedNode.Wrap);\n      var next = iterator.peek();\n\n      while (next != null && indexDefinition.compare(next, endPost) > 0) {\n        iterator.getNext();\n        next = iterator.peek();\n      }\n\n      return iterator;\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  ChildrenNode.prototype.compareTo = function (other) {\n    if (this.isEmpty()) {\n      if (other.isEmpty()) {\n        return 0;\n      } else {\n        return -1;\n      }\n    } else if (other.isLeafNode() || other.isEmpty()) {\n      return 1;\n    } else if (other === exports.MAX_NODE) {\n      return -1;\n    } else {\n      // Must be another node with children.\n      return 0;\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  ChildrenNode.prototype.withIndex = function (indexDefinition) {\n    if (indexDefinition === KeyIndex_1.KEY_INDEX || this.indexMap_.hasIndex(indexDefinition)) {\n      return this;\n    } else {\n      var newIndexMap = this.indexMap_.addIndex(indexDefinition, this.children_);\n      return new ChildrenNode(this.children_, this.priorityNode_, newIndexMap);\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  ChildrenNode.prototype.isIndexed = function (index) {\n    return index === KeyIndex_1.KEY_INDEX || this.indexMap_.hasIndex(index);\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  ChildrenNode.prototype.equals = function (other) {\n    if (other === this) {\n      return true;\n    } else if (other.isLeafNode()) {\n      return false;\n    } else {\n      var otherChildrenNode = other;\n\n      if (!this.getPriority().equals(otherChildrenNode.getPriority())) {\n        return false;\n      } else if (this.children_.count() === otherChildrenNode.children_.count()) {\n        var thisIter = this.getIterator(PriorityIndex_1.PRIORITY_INDEX);\n        var otherIter = otherChildrenNode.getIterator(PriorityIndex_1.PRIORITY_INDEX);\n        var thisCurrent = thisIter.getNext();\n        var otherCurrent = otherIter.getNext();\n\n        while (thisCurrent && otherCurrent) {\n          if (thisCurrent.name !== otherCurrent.name || !thisCurrent.node.equals(otherCurrent.node)) {\n            return false;\n          }\n\n          thisCurrent = thisIter.getNext();\n          otherCurrent = otherIter.getNext();\n        }\n\n        return thisCurrent === null && otherCurrent === null;\n      } else {\n        return false;\n      }\n    }\n  };\n  /**\n   * Returns a SortedMap ordered by index, or null if the default (by-key) ordering can be used\n   * instead.\n   *\n   * @private\n   * @param {!Index} indexDefinition\n   * @return {?SortedMap.<NamedNode, Node>}\n   */\n\n\n  ChildrenNode.prototype.resolveIndex_ = function (indexDefinition) {\n    if (indexDefinition === KeyIndex_1.KEY_INDEX) {\n      return null;\n    } else {\n      return this.indexMap_.get(indexDefinition.toString());\n    }\n  };\n  /**\n   * @private\n   * @type {RegExp}\n   */\n\n\n  ChildrenNode.INTEGER_REGEXP_ = /^(0|[1-9]\\d*)$/;\n  return ChildrenNode;\n}();\n\nexports.ChildrenNode = ChildrenNode;\n/**\n * @constructor\n * @extends {ChildrenNode}\n * @private\n */\n\nvar MaxNode =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(MaxNode, _super);\n\n  function MaxNode() {\n    return _super.call(this, new SortedMap_1.SortedMap(comparators_1.NAME_COMPARATOR), ChildrenNode.EMPTY_NODE, IndexMap_1.IndexMap.Default) || this;\n  }\n\n  MaxNode.prototype.compareTo = function (other) {\n    if (other === this) {\n      return 0;\n    } else {\n      return 1;\n    }\n  };\n\n  MaxNode.prototype.equals = function (other) {\n    // Not that we every compare it, but MAX_NODE is only ever equal to itself\n    return other === this;\n  };\n\n  MaxNode.prototype.getPriority = function () {\n    return this;\n  };\n\n  MaxNode.prototype.getImmediateChild = function (childName) {\n    return ChildrenNode.EMPTY_NODE;\n  };\n\n  MaxNode.prototype.isEmpty = function () {\n    return false;\n  };\n\n  return MaxNode;\n}(ChildrenNode);\n\nexports.MaxNode = MaxNode;\n/**\n * Marker that will sort higher than any other snapshot.\n * @type {!MAX_NODE}\n * @const\n */\n\nexports.MAX_NODE = new MaxNode();\nObject.defineProperties(Node_1.NamedNode, {\n  MIN: {\n    value: new Node_1.NamedNode(util_2.MIN_NAME, ChildrenNode.EMPTY_NODE)\n  },\n  MAX: {\n    value: new Node_1.NamedNode(util_2.MAX_NAME, exports.MAX_NODE)\n  }\n});\n/**\n * Reference Extensions\n */\n\nKeyIndex_1.KeyIndex.__EMPTY_NODE = ChildrenNode.EMPTY_NODE;\nLeafNode_1.LeafNode.__childrenNodeConstructor = ChildrenNode;\nsnap_1.setMaxNode(exports.MAX_NODE);\nPriorityIndex_1.setMaxNode(exports.MAX_NODE);","map":{"version":3,"sources":["../src/core/snap/ChildrenNode.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert } from '@firebase/util';\nimport { sha1, MAX_NAME, MIN_NAME } from '../util/util';\nimport { SortedMap, SortedMapIterator } from '../util/SortedMap';\nimport { Node, NamedNode } from './Node';\nimport { validatePriorityNode, priorityHashText, setMaxNode } from './snap';\nimport {\n  PRIORITY_INDEX,\n  setMaxNode as setPriorityMaxNode\n} from './indexes/PriorityIndex';\nimport { KEY_INDEX, KeyIndex } from './indexes/KeyIndex';\nimport { IndexMap } from './IndexMap';\nimport { LeafNode } from './LeafNode';\nimport { NAME_COMPARATOR } from './comparators';\nimport { Index } from './indexes/Index';\nimport { Path } from '../util/Path';\n\nexport interface ChildrenNodeConstructor {\n  new (\n    children_: SortedMap<string, Node>,\n    priorityNode_: Node | null,\n    indexMap_: IndexMap\n  ): ChildrenNode;\n  EMPTY_NODE: ChildrenNode;\n}\n\n// TODO: For memory savings, don't store priorityNode_ if it's empty.\n\nlet EMPTY_NODE: ChildrenNode;\n\n/**\n * ChildrenNode is a class for storing internal nodes in a DataSnapshot\n * (i.e. nodes with children).  It implements Node and stores the\n * list of children in the children property, sorted by child name.\n *\n * @constructor\n * @implements {Node}\n */\nexport class ChildrenNode implements Node {\n  private lazyHash_: string | null = null;\n\n  static get EMPTY_NODE(): ChildrenNode {\n    return (\n      EMPTY_NODE ||\n      (EMPTY_NODE = new ChildrenNode(\n        new SortedMap<string, Node>(NAME_COMPARATOR),\n        null,\n        IndexMap.Default\n      ))\n    );\n  }\n\n  /**\n   *\n   * @param {!SortedMap.<string, !Node>} children_ List of children\n   * of this node..\n   * @param {?Node} priorityNode_ The priority of this node (as a snapshot node).\n   * @param {!IndexMap} indexMap_\n   */\n  constructor(\n    private readonly children_: SortedMap<string, Node>,\n    private readonly priorityNode_: Node | null,\n    private indexMap_: IndexMap\n  ) {\n    /**\n     * Note: The only reason we allow null priority is for EMPTY_NODE, since we can't use\n     * EMPTY_NODE as the priority of EMPTY_NODE.  We might want to consider making EMPTY_NODE its own\n     * class instead of an empty ChildrenNode.\n     */\n    if (this.priorityNode_) {\n      validatePriorityNode(this.priorityNode_);\n    }\n\n    if (this.children_.isEmpty()) {\n      assert(\n        !this.priorityNode_ || this.priorityNode_.isEmpty(),\n        'An empty node cannot have a priority'\n      );\n    }\n  }\n\n  /** @inheritDoc */\n  isLeafNode(): boolean {\n    return false;\n  }\n\n  /** @inheritDoc */\n  getPriority(): Node {\n    return this.priorityNode_ || EMPTY_NODE;\n  }\n\n  /** @inheritDoc */\n  updatePriority(newPriorityNode: Node): Node {\n    if (this.children_.isEmpty()) {\n      // Don't allow priorities on empty nodes\n      return this;\n    } else {\n      return new ChildrenNode(this.children_, newPriorityNode, this.indexMap_);\n    }\n  }\n\n  /** @inheritDoc */\n  getImmediateChild(childName: string): Node {\n    // Hack to treat priority as a regular child\n    if (childName === '.priority') {\n      return this.getPriority();\n    } else {\n      const child = this.children_.get(childName);\n      return child === null ? EMPTY_NODE : child;\n    }\n  }\n\n  /** @inheritDoc */\n  getChild(path: Path): Node {\n    const front = path.getFront();\n    if (front === null) return this;\n\n    return this.getImmediateChild(front).getChild(path.popFront());\n  }\n\n  /** @inheritDoc */\n  hasChild(childName: string): boolean {\n    return this.children_.get(childName) !== null;\n  }\n\n  /** @inheritDoc */\n  updateImmediateChild(childName: string, newChildNode: Node): Node {\n    assert(newChildNode, 'We should always be passing snapshot nodes');\n    if (childName === '.priority') {\n      return this.updatePriority(newChildNode);\n    } else {\n      const namedNode = new NamedNode(childName, newChildNode);\n      let newChildren, newIndexMap, newPriority;\n      if (newChildNode.isEmpty()) {\n        newChildren = this.children_.remove(childName);\n        newIndexMap = this.indexMap_.removeFromIndexes(\n          namedNode,\n          this.children_\n        );\n      } else {\n        newChildren = this.children_.insert(childName, newChildNode);\n        newIndexMap = this.indexMap_.addToIndexes(namedNode, this.children_);\n      }\n\n      newPriority = newChildren.isEmpty() ? EMPTY_NODE : this.priorityNode_;\n      return new ChildrenNode(newChildren, newPriority, newIndexMap);\n    }\n  }\n\n  /** @inheritDoc */\n  updateChild(path: Path, newChildNode: Node): Node {\n    const front = path.getFront();\n    if (front === null) {\n      return newChildNode;\n    } else {\n      assert(\n        path.getFront() !== '.priority' || path.getLength() === 1,\n        '.priority must be the last token in a path'\n      );\n      const newImmediateChild = this.getImmediateChild(front).updateChild(\n        path.popFront(),\n        newChildNode\n      );\n      return this.updateImmediateChild(front, newImmediateChild);\n    }\n  }\n\n  /** @inheritDoc */\n  isEmpty(): boolean {\n    return this.children_.isEmpty();\n  }\n\n  /** @inheritDoc */\n  numChildren(): number {\n    return this.children_.count();\n  }\n\n  /**\n   * @private\n   * @type {RegExp}\n   */\n  private static INTEGER_REGEXP_ = /^(0|[1-9]\\d*)$/;\n\n  /** @inheritDoc */\n  val(exportFormat?: boolean): object {\n    if (this.isEmpty()) return null;\n\n    const obj: { [k: string]: Object } = {};\n    let numKeys = 0,\n      maxKey = 0,\n      allIntegerKeys = true;\n    this.forEachChild(PRIORITY_INDEX, function(key: string, childNode: Node) {\n      obj[key] = childNode.val(exportFormat);\n\n      numKeys++;\n      if (allIntegerKeys && ChildrenNode.INTEGER_REGEXP_.test(key)) {\n        maxKey = Math.max(maxKey, Number(key));\n      } else {\n        allIntegerKeys = false;\n      }\n    });\n\n    if (!exportFormat && allIntegerKeys && maxKey < 2 * numKeys) {\n      // convert to array.\n      const array: Object[] = [];\n      for (let key in obj) array[(key as any) as number] = obj[key];\n\n      return array;\n    } else {\n      if (exportFormat && !this.getPriority().isEmpty()) {\n        obj['.priority'] = this.getPriority().val();\n      }\n      return obj;\n    }\n  }\n\n  /** @inheritDoc */\n  hash(): string {\n    if (this.lazyHash_ === null) {\n      let toHash = '';\n      if (!this.getPriority().isEmpty())\n        toHash +=\n          'priority:' +\n          priorityHashText(this.getPriority().val() as string | number) +\n          ':';\n\n      this.forEachChild(PRIORITY_INDEX, function(key, childNode) {\n        const childHash = childNode.hash();\n        if (childHash !== '') toHash += ':' + key + ':' + childHash;\n      });\n\n      this.lazyHash_ = toHash === '' ? '' : sha1(toHash);\n    }\n    return this.lazyHash_;\n  }\n\n  /** @inheritDoc */\n  getPredecessorChildName(\n    childName: string,\n    childNode: Node,\n    index: Index\n  ): string {\n    const idx = this.resolveIndex_(index);\n    if (idx) {\n      const predecessor = idx.getPredecessorKey(\n        new NamedNode(childName, childNode)\n      );\n      return predecessor ? predecessor.name : null;\n    } else {\n      return this.children_.getPredecessorKey(childName);\n    }\n  }\n\n  /**\n   * @param {!Index} indexDefinition\n   * @return {?string}\n   */\n  getFirstChildName(indexDefinition: Index): string | null {\n    const idx = this.resolveIndex_(indexDefinition);\n    if (idx) {\n      const minKey = idx.minKey();\n      return minKey && minKey.name;\n    } else {\n      return this.children_.minKey();\n    }\n  }\n\n  /**\n   * @param {!Index} indexDefinition\n   * @return {?NamedNode}\n   */\n  getFirstChild(indexDefinition: Index): NamedNode | null {\n    const minKey = this.getFirstChildName(indexDefinition);\n    if (minKey) {\n      return new NamedNode(minKey, this.children_.get(minKey));\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Given an index, return the key name of the largest value we have, according to that index\n   * @param {!Index} indexDefinition\n   * @return {?string}\n   */\n  getLastChildName(indexDefinition: Index): string | null {\n    const idx = this.resolveIndex_(indexDefinition);\n    if (idx) {\n      const maxKey = idx.maxKey();\n      return maxKey && maxKey.name;\n    } else {\n      return this.children_.maxKey();\n    }\n  }\n\n  /**\n   * @param {!Index} indexDefinition\n   * @return {?NamedNode}\n   */\n  getLastChild(indexDefinition: Index): NamedNode | null {\n    const maxKey = this.getLastChildName(indexDefinition);\n    if (maxKey) {\n      return new NamedNode(maxKey, this.children_.get(maxKey));\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  forEachChild(index: Index, action: (key: string, node: Node) => void): any {\n    const idx = this.resolveIndex_(index);\n    if (idx) {\n      return idx.inorderTraversal(function(wrappedNode) {\n        return action(wrappedNode.name, wrappedNode.node);\n      });\n    } else {\n      return this.children_.inorderTraversal(action);\n    }\n  }\n\n  /**\n   * @param {!Index} indexDefinition\n   * @return {SortedMapIterator}\n   */\n  getIterator(\n    indexDefinition: Index\n  ): SortedMapIterator<string | NamedNode, Node, NamedNode> {\n    return this.getIteratorFrom(indexDefinition.minPost(), indexDefinition);\n  }\n\n  /**\n   *\n   * @param {!NamedNode} startPost\n   * @param {!Index} indexDefinition\n   * @return {!SortedMapIterator}\n   */\n  getIteratorFrom(\n    startPost: NamedNode,\n    indexDefinition: Index\n  ): SortedMapIterator<string | NamedNode, Node, NamedNode> {\n    const idx = this.resolveIndex_(indexDefinition);\n    if (idx) {\n      return idx.getIteratorFrom(startPost, key => key);\n    } else {\n      const iterator = this.children_.getIteratorFrom(\n        startPost.name,\n        NamedNode.Wrap\n      );\n      let next = iterator.peek();\n      while (next != null && indexDefinition.compare(next, startPost) < 0) {\n        iterator.getNext();\n        next = iterator.peek();\n      }\n      return iterator;\n    }\n  }\n\n  /**\n   * @param {!Index} indexDefinition\n   * @return {!SortedMapIterator}\n   */\n  getReverseIterator(\n    indexDefinition: Index\n  ): SortedMapIterator<string | NamedNode, Node, NamedNode> {\n    return this.getReverseIteratorFrom(\n      indexDefinition.maxPost(),\n      indexDefinition\n    );\n  }\n\n  /**\n   * @param {!NamedNode} endPost\n   * @param {!Index} indexDefinition\n   * @return {!SortedMapIterator}\n   */\n  getReverseIteratorFrom(\n    endPost: NamedNode,\n    indexDefinition: Index\n  ): SortedMapIterator<string | NamedNode, Node, NamedNode> {\n    const idx = this.resolveIndex_(indexDefinition);\n    if (idx) {\n      return idx.getReverseIteratorFrom(endPost, function(key) {\n        return key;\n      });\n    } else {\n      const iterator = this.children_.getReverseIteratorFrom(\n        endPost.name,\n        NamedNode.Wrap\n      );\n      let next = iterator.peek();\n      while (next != null && indexDefinition.compare(next, endPost) > 0) {\n        iterator.getNext();\n        next = iterator.peek();\n      }\n      return iterator;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  compareTo(other: ChildrenNode): number {\n    if (this.isEmpty()) {\n      if (other.isEmpty()) {\n        return 0;\n      } else {\n        return -1;\n      }\n    } else if (other.isLeafNode() || other.isEmpty()) {\n      return 1;\n    } else if (other === MAX_NODE) {\n      return -1;\n    } else {\n      // Must be another node with children.\n      return 0;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  withIndex(indexDefinition: Index): Node {\n    if (\n      indexDefinition === KEY_INDEX ||\n      this.indexMap_.hasIndex(indexDefinition)\n    ) {\n      return this;\n    } else {\n      const newIndexMap = this.indexMap_.addIndex(\n        indexDefinition,\n        this.children_\n      );\n      return new ChildrenNode(this.children_, this.priorityNode_, newIndexMap);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  isIndexed(index: Index): boolean {\n    return index === KEY_INDEX || this.indexMap_.hasIndex(index);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  equals(other: Node): boolean {\n    if (other === this) {\n      return true;\n    } else if (other.isLeafNode()) {\n      return false;\n    } else {\n      const otherChildrenNode = other as ChildrenNode;\n      if (!this.getPriority().equals(otherChildrenNode.getPriority())) {\n        return false;\n      } else if (\n        this.children_.count() === otherChildrenNode.children_.count()\n      ) {\n        const thisIter = this.getIterator(PRIORITY_INDEX);\n        const otherIter = otherChildrenNode.getIterator(PRIORITY_INDEX);\n        let thisCurrent = thisIter.getNext();\n        let otherCurrent = otherIter.getNext();\n        while (thisCurrent && otherCurrent) {\n          if (\n            thisCurrent.name !== otherCurrent.name ||\n            !thisCurrent.node.equals(otherCurrent.node)\n          ) {\n            return false;\n          }\n          thisCurrent = thisIter.getNext();\n          otherCurrent = otherIter.getNext();\n        }\n        return thisCurrent === null && otherCurrent === null;\n      } else {\n        return false;\n      }\n    }\n  }\n\n  /**\n   * Returns a SortedMap ordered by index, or null if the default (by-key) ordering can be used\n   * instead.\n   *\n   * @private\n   * @param {!Index} indexDefinition\n   * @return {?SortedMap.<NamedNode, Node>}\n   */\n  private resolveIndex_(\n    indexDefinition: Index\n  ): SortedMap<NamedNode, Node> | null {\n    if (indexDefinition === KEY_INDEX) {\n      return null;\n    } else {\n      return this.indexMap_.get(indexDefinition.toString());\n    }\n  }\n}\n\n/**\n * @constructor\n * @extends {ChildrenNode}\n * @private\n */\nexport class MaxNode extends ChildrenNode {\n  constructor() {\n    super(\n      new SortedMap<string, Node>(NAME_COMPARATOR),\n      ChildrenNode.EMPTY_NODE,\n      IndexMap.Default\n    );\n  }\n\n  compareTo(other: Node): number {\n    if (other === this) {\n      return 0;\n    } else {\n      return 1;\n    }\n  }\n\n  equals(other: Node): boolean {\n    // Not that we every compare it, but MAX_NODE is only ever equal to itself\n    return other === this;\n  }\n\n  getPriority(): MaxNode {\n    return this;\n  }\n\n  getImmediateChild(childName: string): ChildrenNode {\n    return ChildrenNode.EMPTY_NODE;\n  }\n\n  isEmpty(): boolean {\n    return false;\n  }\n}\n\n/**\n * Marker that will sort higher than any other snapshot.\n * @type {!MAX_NODE}\n * @const\n */\nexport const MAX_NODE = new MaxNode();\n\n/**\n * Document NamedNode extensions\n */\ndeclare module './Node' {\n  interface NamedNode {\n    MIN: NamedNode;\n    MAX: NamedNode;\n  }\n}\n\nObject.defineProperties(NamedNode, {\n  MIN: {\n    value: new NamedNode(MIN_NAME, ChildrenNode.EMPTY_NODE)\n  },\n  MAX: {\n    value: new NamedNode(MAX_NAME, MAX_NODE)\n  }\n});\n\n/**\n * Reference Extensions\n */\nKeyIndex.__EMPTY_NODE = ChildrenNode.EMPTY_NODE;\nLeafNode.__childrenNodeConstructor = ChildrenNode;\nsetMaxNode(MAX_NODE);\nsetPriorityMaxNode(MAX_NODE);\n"]},"metadata":{},"sourceType":"script"}