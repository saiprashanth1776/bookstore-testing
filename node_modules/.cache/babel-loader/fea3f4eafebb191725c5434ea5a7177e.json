{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar util_1 = require(\"@firebase/util\");\n\nvar Reference_1 = require(\"../api/Reference\");\n\nvar DataSnapshot_1 = require(\"../api/DataSnapshot\");\n\nvar Path_1 = require(\"./util/Path\");\n\nvar Tree_1 = require(\"./util/Tree\");\n\nvar PriorityIndex_1 = require(\"./snap/indexes/PriorityIndex\");\n\nvar util_2 = require(\"./util/util\");\n\nvar ServerValues_1 = require(\"./util/ServerValues\");\n\nvar validation_1 = require(\"./util/validation\");\n\nvar util_3 = require(\"@firebase/util\");\n\nvar nodeFromJSON_1 = require(\"./snap/nodeFromJSON\");\n\nvar ChildrenNode_1 = require(\"./snap/ChildrenNode\");\n\nvar Repo_1 = require(\"./Repo\"); // TODO: This is pretty messy.  Ideally, a lot of this would move into FirebaseData, or a transaction-specific\n// component used by FirebaseData, but it has ties to user callbacks (transaction update and onComplete) as well\n// as the realtime connection (to send transactions to the server).  So that all needs to be decoupled first.\n// For now it's part of Repo, but in its own file.\n\n/**\n * @enum {number}\n */\n\n\nvar TransactionStatus;\n\n(function (TransactionStatus) {\n  // We've run the transaction and updated transactionResultData_ with the result, but it isn't currently sent to the\n  // server. A transaction will go from RUN -> SENT -> RUN if it comes back from the server as rejected due to\n  // mismatched hash.\n  TransactionStatus[TransactionStatus[\"RUN\"] = 0] = \"RUN\"; // We've run the transaction and sent it to the server and it's currently outstanding (hasn't come back as accepted\n  // or rejected yet).\n\n  TransactionStatus[TransactionStatus[\"SENT\"] = 1] = \"SENT\"; // Temporary state used to mark completed transactions (whether successful or aborted).  The transaction will be\n  // removed when we get a chance to prune completed ones.\n\n  TransactionStatus[TransactionStatus[\"COMPLETED\"] = 2] = \"COMPLETED\"; // Used when an already-sent transaction needs to be aborted (e.g. due to a conflicting set() call that was made).\n  // If it comes back as unsuccessful, we'll abort it.\n\n  TransactionStatus[TransactionStatus[\"SENT_NEEDS_ABORT\"] = 3] = \"SENT_NEEDS_ABORT\"; // Temporary state used to mark transactions that need to be aborted.\n\n  TransactionStatus[TransactionStatus[\"NEEDS_ABORT\"] = 4] = \"NEEDS_ABORT\";\n})(TransactionStatus = exports.TransactionStatus || (exports.TransactionStatus = {}));\n/**\n * If a transaction does not succeed after 25 retries, we abort it.  Among other things this ensure that if there's\n * ever a bug causing a mismatch between client / server hashes for some data, we won't retry indefinitely.\n * @type {number}\n * @const\n * @private\n */\n\n\nRepo_1.Repo.MAX_TRANSACTION_RETRIES_ = 25;\n/**\n * Setup the transaction data structures\n * @private\n */\n\nRepo_1.Repo.prototype.transactions_init_ = function () {\n  /**\n   * Stores queues of outstanding transactions for Firebase locations.\n   *\n   * @type {!Tree.<Array.<!Transaction>>}\n   * @private\n   */\n  this.transactionQueueTree_ = new Tree_1.Tree();\n};\n/**\n * Creates a new transaction, adds it to the transactions we're tracking, and sends it to the server if possible.\n *\n * @param {!Path} path Path at which to do transaction.\n * @param {function(*):*} transactionUpdate Update callback.\n * @param {?function(?Error, boolean, ?DataSnapshot)} onComplete Completion callback.\n * @param {boolean} applyLocally Whether or not to make intermediate results visible\n */\n\n\nRepo_1.Repo.prototype.startTransaction = function (path, transactionUpdate, onComplete, applyLocally) {\n  this.log_('transaction on ' + path); // Add a watch to make sure we get server updates.\n\n  var valueCallback = function () {};\n\n  var watchRef = new Reference_1.Reference(this, path);\n  watchRef.on('value', valueCallback);\n\n  var unwatcher = function () {\n    watchRef.off('value', valueCallback);\n  }; // Initialize transaction.\n\n\n  var transaction = {\n    path: path,\n    update: transactionUpdate,\n    onComplete: onComplete,\n    // One of TransactionStatus enums.\n    status: null,\n    // Used when combining transactions at different locations to figure out which one goes first.\n    order: util_2.LUIDGenerator(),\n    // Whether to raise local events for this transaction.\n    applyLocally: applyLocally,\n    // Count of how many times we've retried the transaction.\n    retryCount: 0,\n    // Function to call to clean up our .on() listener.\n    unwatcher: unwatcher,\n    // Stores why a transaction was aborted.\n    abortReason: null,\n    currentWriteId: null,\n    currentInputSnapshot: null,\n    currentOutputSnapshotRaw: null,\n    currentOutputSnapshotResolved: null\n  }; // Run transaction initially.\n\n  var currentState = this.getLatestState_(path);\n  transaction.currentInputSnapshot = currentState;\n  var newVal = transaction.update(currentState.val());\n\n  if (newVal === undefined) {\n    // Abort transaction.\n    transaction.unwatcher();\n    transaction.currentOutputSnapshotRaw = null;\n    transaction.currentOutputSnapshotResolved = null;\n\n    if (transaction.onComplete) {\n      // We just set the input snapshot, so this cast should be safe\n      var snapshot = new DataSnapshot_1.DataSnapshot(transaction.currentInputSnapshot, new Reference_1.Reference(this, transaction.path), PriorityIndex_1.PRIORITY_INDEX);\n      transaction.onComplete(null, false, snapshot);\n    }\n  } else {\n    validation_1.validateFirebaseData('transaction failed: Data returned ', newVal, transaction.path); // Mark as run and add to our queue.\n\n    transaction.status = TransactionStatus.RUN;\n    var queueNode = this.transactionQueueTree_.subTree(path);\n    var nodeQueue = queueNode.getValue() || [];\n    nodeQueue.push(transaction);\n    queueNode.setValue(nodeQueue); // Update visibleData and raise events\n    // Note: We intentionally raise events after updating all of our transaction state, since the user could\n    // start new transactions from the event callbacks.\n\n    var priorityForNode = void 0;\n\n    if (typeof newVal === 'object' && newVal !== null && util_3.contains(newVal, '.priority')) {\n      priorityForNode = util_3.safeGet(newVal, '.priority');\n      util_1.assert(validation_1.isValidPriority(priorityForNode), 'Invalid priority returned by transaction. ' + 'Priority must be a valid string, finite number, server value, or null.');\n    } else {\n      var currentNode = this.serverSyncTree_.calcCompleteEventCache(path) || ChildrenNode_1.ChildrenNode.EMPTY_NODE;\n      priorityForNode = currentNode.getPriority().val();\n    }\n\n    priorityForNode\n    /** @type {null|number|string} */\n    = priorityForNode;\n    var serverValues = this.generateServerValues();\n    var newNodeUnresolved = nodeFromJSON_1.nodeFromJSON(newVal, priorityForNode);\n    var newNode = ServerValues_1.resolveDeferredValueSnapshot(newNodeUnresolved, serverValues);\n    transaction.currentOutputSnapshotRaw = newNodeUnresolved;\n    transaction.currentOutputSnapshotResolved = newNode;\n    transaction.currentWriteId = this.getNextWriteId_();\n    var events = this.serverSyncTree_.applyUserOverwrite(path, newNode, transaction.currentWriteId, transaction.applyLocally);\n    this.eventQueue_.raiseEventsForChangedPath(path, events);\n    this.sendReadyTransactions_();\n  }\n};\n/**\n * @param {!Path} path\n * @param {Array.<number>=} excludeSets A specific set to exclude\n * @return {Node}\n * @private\n */\n\n\nRepo_1.Repo.prototype.getLatestState_ = function (path, excludeSets) {\n  return this.serverSyncTree_.calcCompleteEventCache(path, excludeSets) || ChildrenNode_1.ChildrenNode.EMPTY_NODE;\n};\n/**\n * Sends any already-run transactions that aren't waiting for outstanding transactions to\n * complete.\n *\n * Externally it's called with no arguments, but it calls itself recursively with a particular\n * transactionQueueTree node to recurse through the tree.\n *\n * @param {Tree.<Array.<Transaction>>=} node  transactionQueueTree node to start at.\n * @private\n */\n\n\nRepo_1.Repo.prototype.sendReadyTransactions_ = function (node) {\n  var _this = this;\n\n  if (node === void 0) {\n    node = this.transactionQueueTree_;\n  } // Before recursing, make sure any completed transactions are removed.\n\n\n  if (!node) {\n    this.pruneCompletedTransactionsBelowNode_(node);\n  }\n\n  if (node.getValue() !== null) {\n    var queue = this.buildTransactionQueue_(node);\n    util_1.assert(queue.length > 0, 'Sending zero length transaction queue');\n    var allRun = queue.every(function (transaction) {\n      return transaction.status === TransactionStatus.RUN;\n    }); // If they're all run (and not sent), we can send them.  Else, we must wait.\n\n    if (allRun) {\n      this.sendTransactionQueue_(node.path(), queue);\n    }\n  } else if (node.hasChildren()) {\n    node.forEachChild(function (childNode) {\n      _this.sendReadyTransactions_(childNode);\n    });\n  }\n};\n/**\n * Given a list of run transactions, send them to the server and then handle the result (success or failure).\n *\n * @param {!Path} path The location of the queue.\n * @param {!Array.<Transaction>} queue Queue of transactions under the specified location.\n * @private\n */\n\n\nRepo_1.Repo.prototype.sendTransactionQueue_ = function (path, queue) {\n  var _this = this; // Mark transactions as sent and increment retry count!\n\n\n  var setsToIgnore = queue.map(function (txn) {\n    return txn.currentWriteId;\n  });\n  var latestState = this.getLatestState_(path, setsToIgnore);\n  var snapToSend = latestState;\n  var latestHash = latestState.hash();\n\n  for (var i = 0; i < queue.length; i++) {\n    var txn = queue[i];\n    util_1.assert(txn.status === TransactionStatus.RUN, 'tryToSendTransactionQueue_: items in queue should all be run.');\n    txn.status = TransactionStatus.SENT;\n    txn.retryCount++;\n    var relativePath = Path_1.Path.relativePath(path, txn.path); // If we've gotten to this point, the output snapshot must be defined.\n\n    snapToSend = snapToSend.updateChild(relativePath\n    /**@type {!Node} */\n    , txn.currentOutputSnapshotRaw);\n  }\n\n  var dataToSend = snapToSend.val(true);\n  var pathToSend = path; // Send the put.\n\n  this.server_.put(pathToSend.toString(), dataToSend, function (status) {\n    _this.log_('transaction put response', {\n      path: pathToSend.toString(),\n      status: status\n    });\n\n    var events = [];\n\n    if (status === 'ok') {\n      // Queue up the callbacks and fire them after cleaning up all of our transaction state, since\n      // the callback could trigger more transactions or sets.\n      var callbacks = [];\n\n      for (var i = 0; i < queue.length; i++) {\n        queue[i].status = TransactionStatus.COMPLETED;\n        events = events.concat(_this.serverSyncTree_.ackUserWrite(queue[i].currentWriteId));\n\n        if (queue[i].onComplete) {\n          // We never unset the output snapshot, and given that this transaction is complete, it should be set\n          var node = queue[i].currentOutputSnapshotResolved;\n          var ref = new Reference_1.Reference(_this, queue[i].path);\n          var snapshot = new DataSnapshot_1.DataSnapshot(node, ref, PriorityIndex_1.PRIORITY_INDEX);\n          callbacks.push(queue[i].onComplete.bind(null, null, true, snapshot));\n        }\n\n        queue[i].unwatcher();\n      } // Now remove the completed transactions.\n\n\n      _this.pruneCompletedTransactionsBelowNode_(_this.transactionQueueTree_.subTree(path)); // There may be pending transactions that we can now send.\n\n\n      _this.sendReadyTransactions_();\n\n      _this.eventQueue_.raiseEventsForChangedPath(path, events); // Finally, trigger onComplete callbacks.\n\n\n      for (var i = 0; i < callbacks.length; i++) {\n        util_2.exceptionGuard(callbacks[i]);\n      }\n    } else {\n      // transactions are no longer sent.  Update their status appropriately.\n      if (status === 'datastale') {\n        for (var i = 0; i < queue.length; i++) {\n          if (queue[i].status === TransactionStatus.SENT_NEEDS_ABORT) queue[i].status = TransactionStatus.NEEDS_ABORT;else queue[i].status = TransactionStatus.RUN;\n        }\n      } else {\n        util_2.warn('transaction at ' + pathToSend.toString() + ' failed: ' + status);\n\n        for (var i = 0; i < queue.length; i++) {\n          queue[i].status = TransactionStatus.NEEDS_ABORT;\n          queue[i].abortReason = status;\n        }\n      }\n\n      _this.rerunTransactions_(path);\n    }\n  }, latestHash);\n};\n/**\n * Finds all transactions dependent on the data at changedPath and reruns them.\n *\n * Should be called any time cached data changes.\n *\n * Return the highest path that was affected by rerunning transactions.  This is the path at which events need to\n * be raised for.\n *\n * @param {!Path} changedPath The path in mergedData that changed.\n * @return {!Path} The rootmost path that was affected by rerunning transactions.\n * @private\n */\n\n\nRepo_1.Repo.prototype.rerunTransactions_ = function (changedPath) {\n  var rootMostTransactionNode = this.getAncestorTransactionNode_(changedPath);\n  var path = rootMostTransactionNode.path();\n  var queue = this.buildTransactionQueue_(rootMostTransactionNode);\n  this.rerunTransactionQueue_(queue, path);\n  return path;\n};\n/**\n * Does all the work of rerunning transactions (as well as cleans up aborted transactions and whatnot).\n *\n * @param {Array.<Transaction>} queue The queue of transactions to run.\n * @param {!Path} path The path the queue is for.\n * @private\n */\n\n\nRepo_1.Repo.prototype.rerunTransactionQueue_ = function (queue, path) {\n  if (queue.length === 0) {\n    return; // Nothing to do!\n  } // Queue up the callbacks and fire them after cleaning up all of our transaction state, since\n  // the callback could trigger more transactions or sets.\n\n\n  var callbacks = [];\n  var events = []; // Ignore all of the sets we're going to re-run.\n\n  var txnsToRerun = queue.filter(function (q) {\n    return q.status === TransactionStatus.RUN;\n  });\n  var setsToIgnore = txnsToRerun.map(function (q) {\n    return q.currentWriteId;\n  });\n\n  for (var i = 0; i < queue.length; i++) {\n    var transaction = queue[i];\n    var relativePath = Path_1.Path.relativePath(path, transaction.path);\n    var abortTransaction = false,\n        abortReason = void 0;\n    util_1.assert(relativePath !== null, 'rerunTransactionsUnderNode_: relativePath should not be null.');\n\n    if (transaction.status === TransactionStatus.NEEDS_ABORT) {\n      abortTransaction = true;\n      abortReason = transaction.abortReason;\n      events = events.concat(this.serverSyncTree_.ackUserWrite(transaction.currentWriteId, true));\n    } else if (transaction.status === TransactionStatus.RUN) {\n      if (transaction.retryCount >= Repo_1.Repo.MAX_TRANSACTION_RETRIES_) {\n        abortTransaction = true;\n        abortReason = 'maxretry';\n        events = events.concat(this.serverSyncTree_.ackUserWrite(transaction.currentWriteId, true));\n      } else {\n        // This code reruns a transaction\n        var currentNode = this.getLatestState_(transaction.path, setsToIgnore);\n        transaction.currentInputSnapshot = currentNode;\n        var newData = queue[i].update(currentNode.val());\n\n        if (newData !== undefined) {\n          validation_1.validateFirebaseData('transaction failed: Data returned ', newData, transaction.path);\n          var newDataNode = nodeFromJSON_1.nodeFromJSON(newData);\n          var hasExplicitPriority = typeof newData === 'object' && newData != null && util_3.contains(newData, '.priority');\n\n          if (!hasExplicitPriority) {\n            // Keep the old priority if there wasn't a priority explicitly specified.\n            newDataNode = newDataNode.updatePriority(currentNode.getPriority());\n          }\n\n          var oldWriteId = transaction.currentWriteId;\n          var serverValues = this.generateServerValues();\n          var newNodeResolved = ServerValues_1.resolveDeferredValueSnapshot(newDataNode, serverValues);\n          transaction.currentOutputSnapshotRaw = newDataNode;\n          transaction.currentOutputSnapshotResolved = newNodeResolved;\n          transaction.currentWriteId = this.getNextWriteId_(); // Mutates setsToIgnore in place\n\n          setsToIgnore.splice(setsToIgnore.indexOf(oldWriteId), 1);\n          events = events.concat(this.serverSyncTree_.applyUserOverwrite(transaction.path, newNodeResolved, transaction.currentWriteId, transaction.applyLocally));\n          events = events.concat(this.serverSyncTree_.ackUserWrite(oldWriteId, true));\n        } else {\n          abortTransaction = true;\n          abortReason = 'nodata';\n          events = events.concat(this.serverSyncTree_.ackUserWrite(transaction.currentWriteId, true));\n        }\n      }\n    }\n\n    this.eventQueue_.raiseEventsForChangedPath(path, events);\n    events = [];\n\n    if (abortTransaction) {\n      // Abort.\n      queue[i].status = TransactionStatus.COMPLETED; // Removing a listener can trigger pruning which can muck with mergedData/visibleData (as it prunes data).\n      // So defer the unwatcher until we're done.\n\n      (function (unwatcher) {\n        setTimeout(unwatcher, Math.floor(0));\n      })(queue[i].unwatcher);\n\n      if (queue[i].onComplete) {\n        if (abortReason === 'nodata') {\n          var ref = new Reference_1.Reference(this, queue[i].path); // We set this field immediately, so it's safe to cast to an actual snapshot\n\n          var lastInput\n          /** @type {!Node} */\n          = queue[i].currentInputSnapshot;\n          var snapshot = new DataSnapshot_1.DataSnapshot(lastInput, ref, PriorityIndex_1.PRIORITY_INDEX);\n          callbacks.push(queue[i].onComplete.bind(null, null, false, snapshot));\n        } else {\n          callbacks.push(queue[i].onComplete.bind(null, new Error(abortReason), false, null));\n        }\n      }\n    }\n  } // Clean up completed transactions.\n\n\n  this.pruneCompletedTransactionsBelowNode_(this.transactionQueueTree_); // Now fire callbacks, now that we're in a good, known state.\n\n  for (var i = 0; i < callbacks.length; i++) {\n    util_2.exceptionGuard(callbacks[i]);\n  } // Try to send the transaction result to the server.\n\n\n  this.sendReadyTransactions_();\n};\n/**\n * Returns the rootmost ancestor node of the specified path that has a pending transaction on it, or just returns\n * the node for the given path if there are no pending transactions on any ancestor.\n *\n * @param {!Path} path The location to start at.\n * @return {!Tree.<Array.<!Transaction>>} The rootmost node with a transaction.\n * @private\n */\n\n\nRepo_1.Repo.prototype.getAncestorTransactionNode_ = function (path) {\n  var front; // Start at the root and walk deeper into the tree towards path until we find a node with pending transactions.\n\n  var transactionNode = this.transactionQueueTree_;\n\n  while ((front = path.getFront()) !== null && transactionNode.getValue() === null) {\n    transactionNode = transactionNode.subTree(front);\n    path = path.popFront();\n  }\n\n  return transactionNode;\n};\n/**\n * Builds the queue of all transactions at or below the specified transactionNode.\n *\n * @param {!Tree.<Array.<Transaction>>} transactionNode\n * @return {Array.<Transaction>} The generated queue.\n * @private\n */\n\n\nRepo_1.Repo.prototype.buildTransactionQueue_ = function (transactionNode) {\n  // Walk any child transaction queues and aggregate them into a single queue.\n  var transactionQueue = [];\n  this.aggregateTransactionQueuesForNode_(transactionNode, transactionQueue); // Sort them by the order the transactions were created.\n\n  transactionQueue.sort(function (a, b) {\n    return a.order - b.order;\n  });\n  return transactionQueue;\n};\n/**\n * @param {!Tree.<Array.<Transaction>>} node\n * @param {Array.<Transaction>} queue\n * @private\n */\n\n\nRepo_1.Repo.prototype.aggregateTransactionQueuesForNode_ = function (node, queue) {\n  var _this = this;\n\n  var nodeQueue = node.getValue();\n\n  if (nodeQueue !== null) {\n    for (var i = 0; i < nodeQueue.length; i++) {\n      queue.push(nodeQueue[i]);\n    }\n  }\n\n  node.forEachChild(function (child) {\n    _this.aggregateTransactionQueuesForNode_(child, queue);\n  });\n};\n/**\n * Remove COMPLETED transactions at or below this node in the transactionQueueTree_.\n *\n * @param {!Tree.<Array.<!Transaction>>} node\n * @private\n */\n\n\nRepo_1.Repo.prototype.pruneCompletedTransactionsBelowNode_ = function (node) {\n  var _this = this;\n\n  var queue = node.getValue();\n\n  if (queue) {\n    var to = 0;\n\n    for (var from = 0; from < queue.length; from++) {\n      if (queue[from].status !== TransactionStatus.COMPLETED) {\n        queue[to] = queue[from];\n        to++;\n      }\n    }\n\n    queue.length = to;\n    node.setValue(queue.length > 0 ? queue : null);\n  }\n\n  node.forEachChild(function (childNode) {\n    _this.pruneCompletedTransactionsBelowNode_(childNode);\n  });\n};\n/**\n * Aborts all transactions on ancestors or descendants of the specified path.  Called when doing a set() or update()\n * since we consider them incompatible with transactions.\n *\n * @param {!Path} path Path for which we want to abort related transactions.\n * @return {!Path}\n * @private\n */\n\n\nRepo_1.Repo.prototype.abortTransactions_ = function (path) {\n  var _this = this;\n\n  var affectedPath = this.getAncestorTransactionNode_(path).path();\n  var transactionNode = this.transactionQueueTree_.subTree(path);\n  transactionNode.forEachAncestor(function (node) {\n    _this.abortTransactionsOnNode_(node);\n  });\n  this.abortTransactionsOnNode_(transactionNode);\n  transactionNode.forEachDescendant(function (node) {\n    _this.abortTransactionsOnNode_(node);\n  });\n  return affectedPath;\n};\n/**\n * Abort transactions stored in this transaction queue node.\n *\n * @param {!Tree.<Array.<Transaction>>} node Node to abort transactions for.\n * @private\n */\n\n\nRepo_1.Repo.prototype.abortTransactionsOnNode_ = function (node) {\n  var queue = node.getValue();\n\n  if (queue !== null) {\n    // Queue up the callbacks and fire them after cleaning up all of our transaction state, since\n    // the callback could trigger more transactions or sets.\n    var callbacks = []; // Go through queue.  Any already-sent transactions must be marked for abort, while the unsent ones\n    // can be immediately aborted and removed.\n\n    var events = [];\n    var lastSent = -1;\n\n    for (var i = 0; i < queue.length; i++) {\n      if (queue[i].status === TransactionStatus.SENT_NEEDS_ABORT) {// Already marked.  No action needed.\n      } else if (queue[i].status === TransactionStatus.SENT) {\n        util_1.assert(lastSent === i - 1, 'All SENT items should be at beginning of queue.');\n        lastSent = i; // Mark transaction for abort when it comes back.\n\n        queue[i].status = TransactionStatus.SENT_NEEDS_ABORT;\n        queue[i].abortReason = 'set';\n      } else {\n        util_1.assert(queue[i].status === TransactionStatus.RUN, 'Unexpected transaction status in abort'); // We can abort it immediately.\n\n        queue[i].unwatcher();\n        events = events.concat(this.serverSyncTree_.ackUserWrite(queue[i].currentWriteId, true));\n\n        if (queue[i].onComplete) {\n          var snapshot = null;\n          callbacks.push(queue[i].onComplete.bind(null, new Error('set'), false, snapshot));\n        }\n      }\n    }\n\n    if (lastSent === -1) {\n      // We're not waiting for any sent transactions.  We can clear the queue.\n      node.setValue(null);\n    } else {\n      // Remove the transactions we aborted.\n      queue.length = lastSent + 1;\n    } // Now fire the callbacks.\n\n\n    this.eventQueue_.raiseEventsForChangedPath(node.path(), events);\n\n    for (var i = 0; i < callbacks.length; i++) {\n      util_2.exceptionGuard(callbacks[i]);\n    }\n  }\n};","map":{"version":3,"sources":["../src/core/Repo_transaction.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert } from '@firebase/util';\nimport { Reference } from '../api/Reference';\nimport { DataSnapshot } from '../api/DataSnapshot';\nimport { Path } from './util/Path';\nimport { Tree } from './util/Tree';\nimport { PRIORITY_INDEX } from './snap/indexes/PriorityIndex';\nimport { Node } from './snap/Node';\nimport { LUIDGenerator, warn, exceptionGuard } from './util/util';\nimport { resolveDeferredValueSnapshot } from './util/ServerValues';\nimport { isValidPriority, validateFirebaseData } from './util/validation';\nimport { contains, safeGet } from '@firebase/util';\nimport { nodeFromJSON } from './snap/nodeFromJSON';\nimport { ChildrenNode } from './snap/ChildrenNode';\nimport { Repo } from './Repo';\nimport { Event } from './view/Event';\n\n// TODO: This is pretty messy.  Ideally, a lot of this would move into FirebaseData, or a transaction-specific\n// component used by FirebaseData, but it has ties to user callbacks (transaction update and onComplete) as well\n// as the realtime connection (to send transactions to the server).  So that all needs to be decoupled first.\n// For now it's part of Repo, but in its own file.\n\n/**\n * @enum {number}\n */\nexport enum TransactionStatus {\n  // We've run the transaction and updated transactionResultData_ with the result, but it isn't currently sent to the\n  // server. A transaction will go from RUN -> SENT -> RUN if it comes back from the server as rejected due to\n  // mismatched hash.\n  RUN,\n\n  // We've run the transaction and sent it to the server and it's currently outstanding (hasn't come back as accepted\n  // or rejected yet).\n  SENT,\n\n  // Temporary state used to mark completed transactions (whether successful or aborted).  The transaction will be\n  // removed when we get a chance to prune completed ones.\n  COMPLETED,\n\n  // Used when an already-sent transaction needs to be aborted (e.g. due to a conflicting set() call that was made).\n  // If it comes back as unsuccessful, we'll abort it.\n  SENT_NEEDS_ABORT,\n\n  // Temporary state used to mark transactions that need to be aborted.\n  NEEDS_ABORT\n}\n\n/**\n * If a transaction does not succeed after 25 retries, we abort it.  Among other things this ensure that if there's\n * ever a bug causing a mismatch between client / server hashes for some data, we won't retry indefinitely.\n * @type {number}\n * @const\n * @private\n */\n(Repo as any).MAX_TRANSACTION_RETRIES_ = 25;\n\n/**\n * @typedef {{\n *   path: !Path,\n *   update: function(*):*,\n *   onComplete: ?function(?Error, boolean, ?DataSnapshot),\n *   status: ?TransactionStatus,\n *   order: !number,\n *   applyLocally: boolean,\n *   retryCount: !number,\n *   unwatcher: function(),\n *   abortReason: ?string,\n *   currentWriteId: !number,\n *   currentInputSnapshot: ?Node,\n *   currentOutputSnapshotRaw: ?Node,\n *   currentOutputSnapshotResolved: ?Node\n * }}\n */\ntype Transaction = {\n  path: Path;\n  update: (a: any) => any;\n  onComplete: (a: Error | null, b: boolean, c: DataSnapshot | null) => void;\n  status: TransactionStatus;\n  order: number;\n  applyLocally: boolean;\n  retryCount: number;\n  unwatcher: () => void;\n  abortReason: string | null;\n  currentWriteId: number;\n  currentInputSnapshot: Node | null;\n  currentOutputSnapshotRaw: Node | null;\n  currentOutputSnapshotResolved: Node | null;\n};\n\n/**\n * Setup the transaction data structures\n * @private\n */\n(Repo.prototype as any).transactions_init_ = function() {\n  /**\n   * Stores queues of outstanding transactions for Firebase locations.\n   *\n   * @type {!Tree.<Array.<!Transaction>>}\n   * @private\n   */\n  this.transactionQueueTree_ = new Tree<Transaction[]>();\n};\n\ndeclare module './Repo' {\n  interface Repo {\n    startTransaction(\n      path: Path,\n      transactionUpdate: (a: any) => void,\n      onComplete: ((a: Error, b: boolean, c: DataSnapshot) => void) | null,\n      applyLocally: boolean\n    ): void;\n  }\n}\n\n/**\n * Creates a new transaction, adds it to the transactions we're tracking, and sends it to the server if possible.\n *\n * @param {!Path} path Path at which to do transaction.\n * @param {function(*):*} transactionUpdate Update callback.\n * @param {?function(?Error, boolean, ?DataSnapshot)} onComplete Completion callback.\n * @param {boolean} applyLocally Whether or not to make intermediate results visible\n */\nRepo.prototype.startTransaction = function(\n  path: Path,\n  transactionUpdate: (a: any) => any,\n  onComplete: ((a: Error, b: boolean, c: DataSnapshot) => void) | null,\n  applyLocally: boolean\n) {\n  this.log_('transaction on ' + path);\n\n  // Add a watch to make sure we get server updates.\n  const valueCallback = function() {};\n  const watchRef = new Reference(this, path);\n  watchRef.on('value', valueCallback);\n  const unwatcher = function() {\n    watchRef.off('value', valueCallback);\n  };\n\n  // Initialize transaction.\n  const transaction: Transaction = {\n    path,\n    update: transactionUpdate,\n    onComplete,\n\n    // One of TransactionStatus enums.\n    status: null,\n\n    // Used when combining transactions at different locations to figure out which one goes first.\n    order: LUIDGenerator(),\n\n    // Whether to raise local events for this transaction.\n    applyLocally: applyLocally,\n\n    // Count of how many times we've retried the transaction.\n    retryCount: 0,\n\n    // Function to call to clean up our .on() listener.\n    unwatcher,\n\n    // Stores why a transaction was aborted.\n    abortReason: null,\n\n    currentWriteId: null,\n\n    currentInputSnapshot: null,\n\n    currentOutputSnapshotRaw: null,\n\n    currentOutputSnapshotResolved: null\n  };\n\n  // Run transaction initially.\n  const currentState = this.getLatestState_(path);\n  transaction.currentInputSnapshot = currentState;\n  const newVal = transaction.update(currentState.val());\n  if (newVal === undefined) {\n    // Abort transaction.\n    transaction.unwatcher();\n    transaction.currentOutputSnapshotRaw = null;\n    transaction.currentOutputSnapshotResolved = null;\n    if (transaction.onComplete) {\n      // We just set the input snapshot, so this cast should be safe\n      const snapshot = new DataSnapshot(\n        transaction.currentInputSnapshot,\n        new Reference(this, transaction.path),\n        PRIORITY_INDEX\n      );\n      transaction.onComplete(null, false, snapshot);\n    }\n  } else {\n    validateFirebaseData(\n      'transaction failed: Data returned ',\n      newVal,\n      transaction.path\n    );\n\n    // Mark as run and add to our queue.\n    transaction.status = TransactionStatus.RUN;\n    const queueNode = this.transactionQueueTree_.subTree(path);\n    const nodeQueue = queueNode.getValue() || [];\n    nodeQueue.push(transaction);\n\n    queueNode.setValue(nodeQueue);\n\n    // Update visibleData and raise events\n    // Note: We intentionally raise events after updating all of our transaction state, since the user could\n    // start new transactions from the event callbacks.\n    let priorityForNode;\n    if (\n      typeof newVal === 'object' &&\n      newVal !== null &&\n      contains(newVal, '.priority')\n    ) {\n      priorityForNode = safeGet(newVal, '.priority');\n      assert(\n        isValidPriority(priorityForNode),\n        'Invalid priority returned by transaction. ' +\n          'Priority must be a valid string, finite number, server value, or null.'\n      );\n    } else {\n      const currentNode =\n        this.serverSyncTree_.calcCompleteEventCache(path) ||\n        ChildrenNode.EMPTY_NODE;\n      priorityForNode = currentNode.getPriority().val();\n    }\n    priorityForNode /** @type {null|number|string} */ = priorityForNode;\n\n    const serverValues = this.generateServerValues();\n    const newNodeUnresolved = nodeFromJSON(newVal, priorityForNode);\n    const newNode = resolveDeferredValueSnapshot(\n      newNodeUnresolved,\n      serverValues\n    );\n    transaction.currentOutputSnapshotRaw = newNodeUnresolved;\n    transaction.currentOutputSnapshotResolved = newNode;\n    transaction.currentWriteId = this.getNextWriteId_();\n\n    const events = this.serverSyncTree_.applyUserOverwrite(\n      path,\n      newNode,\n      transaction.currentWriteId,\n      transaction.applyLocally\n    );\n    this.eventQueue_.raiseEventsForChangedPath(path, events);\n\n    this.sendReadyTransactions_();\n  }\n};\n\n/**\n * @param {!Path} path\n * @param {Array.<number>=} excludeSets A specific set to exclude\n * @return {Node}\n * @private\n */\n(Repo.prototype as any).getLatestState_ = function(\n  path: Path,\n  excludeSets?: number[]\n): Node {\n  return (\n    this.serverSyncTree_.calcCompleteEventCache(path, excludeSets) ||\n    ChildrenNode.EMPTY_NODE\n  );\n};\n\n/**\n * Sends any already-run transactions that aren't waiting for outstanding transactions to\n * complete.\n *\n * Externally it's called with no arguments, but it calls itself recursively with a particular\n * transactionQueueTree node to recurse through the tree.\n *\n * @param {Tree.<Array.<Transaction>>=} node  transactionQueueTree node to start at.\n * @private\n */\n(Repo.prototype as any).sendReadyTransactions_ = function(\n  node: Tree<Transaction[]> = this.transactionQueueTree_\n) {\n  // Before recursing, make sure any completed transactions are removed.\n  if (!node) {\n    this.pruneCompletedTransactionsBelowNode_(node);\n  }\n\n  if (node.getValue() !== null) {\n    const queue = this.buildTransactionQueue_(node);\n    assert(queue.length > 0, 'Sending zero length transaction queue');\n\n    const allRun = queue.every(\n      (transaction: Transaction) => transaction.status === TransactionStatus.RUN\n    );\n\n    // If they're all run (and not sent), we can send them.  Else, we must wait.\n    if (allRun) {\n      this.sendTransactionQueue_(node.path(), queue);\n    }\n  } else if (node.hasChildren()) {\n    node.forEachChild(childNode => {\n      this.sendReadyTransactions_(childNode);\n    });\n  }\n};\n\n/**\n * Given a list of run transactions, send them to the server and then handle the result (success or failure).\n *\n * @param {!Path} path The location of the queue.\n * @param {!Array.<Transaction>} queue Queue of transactions under the specified location.\n * @private\n */\n(Repo.prototype as any).sendTransactionQueue_ = function(\n  path: Path,\n  queue: Array<Transaction>\n) {\n  // Mark transactions as sent and increment retry count!\n  const setsToIgnore = queue.map(function(txn) {\n    return txn.currentWriteId;\n  });\n  const latestState = this.getLatestState_(path, setsToIgnore);\n  let snapToSend = latestState;\n  const latestHash = latestState.hash();\n  for (let i = 0; i < queue.length; i++) {\n    const txn = queue[i];\n    assert(\n      txn.status === TransactionStatus.RUN,\n      'tryToSendTransactionQueue_: items in queue should all be run.'\n    );\n    txn.status = TransactionStatus.SENT;\n    txn.retryCount++;\n    const relativePath = Path.relativePath(path, txn.path);\n    // If we've gotten to this point, the output snapshot must be defined.\n    snapToSend = snapToSend.updateChild(\n      relativePath /**@type {!Node} */,\n      txn.currentOutputSnapshotRaw\n    );\n  }\n\n  const dataToSend = snapToSend.val(true);\n  const pathToSend = path;\n\n  // Send the put.\n  this.server_.put(\n    pathToSend.toString(),\n    dataToSend,\n    (status: string) => {\n      this.log_('transaction put response', {\n        path: pathToSend.toString(),\n        status\n      });\n\n      let events: Event[] = [];\n      if (status === 'ok') {\n        // Queue up the callbacks and fire them after cleaning up all of our transaction state, since\n        // the callback could trigger more transactions or sets.\n        const callbacks = [];\n        for (let i = 0; i < queue.length; i++) {\n          queue[i].status = TransactionStatus.COMPLETED;\n          events = events.concat(\n            this.serverSyncTree_.ackUserWrite(queue[i].currentWriteId)\n          );\n          if (queue[i].onComplete) {\n            // We never unset the output snapshot, and given that this transaction is complete, it should be set\n            const node = queue[i].currentOutputSnapshotResolved as Node;\n            const ref = new Reference(this, queue[i].path);\n            const snapshot = new DataSnapshot(node, ref, PRIORITY_INDEX);\n            callbacks.push(\n              queue[i].onComplete.bind(null, null, true, snapshot)\n            );\n          }\n          queue[i].unwatcher();\n        }\n\n        // Now remove the completed transactions.\n        this.pruneCompletedTransactionsBelowNode_(\n          this.transactionQueueTree_.subTree(path)\n        );\n        // There may be pending transactions that we can now send.\n        this.sendReadyTransactions_();\n\n        this.eventQueue_.raiseEventsForChangedPath(path, events);\n\n        // Finally, trigger onComplete callbacks.\n        for (let i = 0; i < callbacks.length; i++) {\n          exceptionGuard(callbacks[i]);\n        }\n      } else {\n        // transactions are no longer sent.  Update their status appropriately.\n        if (status === 'datastale') {\n          for (let i = 0; i < queue.length; i++) {\n            if (queue[i].status === TransactionStatus.SENT_NEEDS_ABORT)\n              queue[i].status = TransactionStatus.NEEDS_ABORT;\n            else queue[i].status = TransactionStatus.RUN;\n          }\n        } else {\n          warn(\n            'transaction at ' + pathToSend.toString() + ' failed: ' + status\n          );\n          for (let i = 0; i < queue.length; i++) {\n            queue[i].status = TransactionStatus.NEEDS_ABORT;\n            queue[i].abortReason = status;\n          }\n        }\n\n        this.rerunTransactions_(path);\n      }\n    },\n    latestHash\n  );\n};\n\n/**\n * Finds all transactions dependent on the data at changedPath and reruns them.\n *\n * Should be called any time cached data changes.\n *\n * Return the highest path that was affected by rerunning transactions.  This is the path at which events need to\n * be raised for.\n *\n * @param {!Path} changedPath The path in mergedData that changed.\n * @return {!Path} The rootmost path that was affected by rerunning transactions.\n * @private\n */\n(Repo.prototype as any).rerunTransactions_ = function(changedPath: Path): Path {\n  const rootMostTransactionNode = this.getAncestorTransactionNode_(changedPath);\n  const path = rootMostTransactionNode.path();\n\n  const queue = this.buildTransactionQueue_(rootMostTransactionNode);\n  this.rerunTransactionQueue_(queue, path);\n\n  return path;\n};\n\n/**\n * Does all the work of rerunning transactions (as well as cleans up aborted transactions and whatnot).\n *\n * @param {Array.<Transaction>} queue The queue of transactions to run.\n * @param {!Path} path The path the queue is for.\n * @private\n */\n(Repo.prototype as any).rerunTransactionQueue_ = function(\n  queue: Array<Transaction>,\n  path: Path\n) {\n  if (queue.length === 0) {\n    return; // Nothing to do!\n  }\n\n  // Queue up the callbacks and fire them after cleaning up all of our transaction state, since\n  // the callback could trigger more transactions or sets.\n  const callbacks = [];\n  let events: Event[] = [];\n  // Ignore all of the sets we're going to re-run.\n  const txnsToRerun = queue.filter(function(q) {\n    return q.status === TransactionStatus.RUN;\n  });\n  const setsToIgnore = txnsToRerun.map(function(q) {\n    return q.currentWriteId;\n  });\n  for (let i = 0; i < queue.length; i++) {\n    const transaction = queue[i];\n    const relativePath = Path.relativePath(path, transaction.path);\n    let abortTransaction = false,\n      abortReason;\n    assert(\n      relativePath !== null,\n      'rerunTransactionsUnderNode_: relativePath should not be null.'\n    );\n\n    if (transaction.status === TransactionStatus.NEEDS_ABORT) {\n      abortTransaction = true;\n      abortReason = transaction.abortReason;\n      events = events.concat(\n        this.serverSyncTree_.ackUserWrite(transaction.currentWriteId, true)\n      );\n    } else if (transaction.status === TransactionStatus.RUN) {\n      if (transaction.retryCount >= (Repo as any).MAX_TRANSACTION_RETRIES_) {\n        abortTransaction = true;\n        abortReason = 'maxretry';\n        events = events.concat(\n          this.serverSyncTree_.ackUserWrite(transaction.currentWriteId, true)\n        );\n      } else {\n        // This code reruns a transaction\n        const currentNode = this.getLatestState_(\n          transaction.path,\n          setsToIgnore\n        );\n        transaction.currentInputSnapshot = currentNode;\n        const newData = queue[i].update(currentNode.val());\n        if (newData !== undefined) {\n          validateFirebaseData(\n            'transaction failed: Data returned ',\n            newData,\n            transaction.path\n          );\n          let newDataNode = nodeFromJSON(newData);\n          const hasExplicitPriority =\n            typeof newData === 'object' &&\n            newData != null &&\n            contains(newData, '.priority');\n          if (!hasExplicitPriority) {\n            // Keep the old priority if there wasn't a priority explicitly specified.\n            newDataNode = newDataNode.updatePriority(currentNode.getPriority());\n          }\n\n          const oldWriteId = transaction.currentWriteId;\n          const serverValues = this.generateServerValues();\n          const newNodeResolved = resolveDeferredValueSnapshot(\n            newDataNode,\n            serverValues\n          );\n\n          transaction.currentOutputSnapshotRaw = newDataNode;\n          transaction.currentOutputSnapshotResolved = newNodeResolved;\n          transaction.currentWriteId = this.getNextWriteId_();\n          // Mutates setsToIgnore in place\n          setsToIgnore.splice(setsToIgnore.indexOf(oldWriteId), 1);\n          events = events.concat(\n            this.serverSyncTree_.applyUserOverwrite(\n              transaction.path,\n              newNodeResolved,\n              transaction.currentWriteId,\n              transaction.applyLocally\n            )\n          );\n          events = events.concat(\n            this.serverSyncTree_.ackUserWrite(oldWriteId, true)\n          );\n        } else {\n          abortTransaction = true;\n          abortReason = 'nodata';\n          events = events.concat(\n            this.serverSyncTree_.ackUserWrite(transaction.currentWriteId, true)\n          );\n        }\n      }\n    }\n    this.eventQueue_.raiseEventsForChangedPath(path, events);\n    events = [];\n    if (abortTransaction) {\n      // Abort.\n      queue[i].status = TransactionStatus.COMPLETED;\n\n      // Removing a listener can trigger pruning which can muck with mergedData/visibleData (as it prunes data).\n      // So defer the unwatcher until we're done.\n      (function(unwatcher) {\n        setTimeout(unwatcher, Math.floor(0));\n      })(queue[i].unwatcher);\n\n      if (queue[i].onComplete) {\n        if (abortReason === 'nodata') {\n          const ref = new Reference(this, queue[i].path);\n          // We set this field immediately, so it's safe to cast to an actual snapshot\n          const lastInput /** @type {!Node} */ = queue[i].currentInputSnapshot;\n          const snapshot = new DataSnapshot(lastInput, ref, PRIORITY_INDEX);\n          callbacks.push(queue[i].onComplete.bind(null, null, false, snapshot));\n        } else {\n          callbacks.push(\n            queue[i].onComplete.bind(null, new Error(abortReason), false, null)\n          );\n        }\n      }\n    }\n  }\n\n  // Clean up completed transactions.\n  this.pruneCompletedTransactionsBelowNode_(this.transactionQueueTree_);\n\n  // Now fire callbacks, now that we're in a good, known state.\n  for (let i = 0; i < callbacks.length; i++) {\n    exceptionGuard(callbacks[i]);\n  }\n\n  // Try to send the transaction result to the server.\n  this.sendReadyTransactions_();\n};\n\n/**\n * Returns the rootmost ancestor node of the specified path that has a pending transaction on it, or just returns\n * the node for the given path if there are no pending transactions on any ancestor.\n *\n * @param {!Path} path The location to start at.\n * @return {!Tree.<Array.<!Transaction>>} The rootmost node with a transaction.\n * @private\n */\n(Repo.prototype as any).getAncestorTransactionNode_ = function(\n  path: Path\n): Tree<Transaction[]> {\n  let front;\n\n  // Start at the root and walk deeper into the tree towards path until we find a node with pending transactions.\n  let transactionNode = this.transactionQueueTree_;\n  while (\n    (front = path.getFront()) !== null &&\n    transactionNode.getValue() === null\n  ) {\n    transactionNode = transactionNode.subTree(front);\n    path = path.popFront();\n  }\n\n  return transactionNode;\n};\n\n/**\n * Builds the queue of all transactions at or below the specified transactionNode.\n *\n * @param {!Tree.<Array.<Transaction>>} transactionNode\n * @return {Array.<Transaction>} The generated queue.\n * @private\n */\n(Repo.prototype as any).buildTransactionQueue_ = function(\n  transactionNode: Tree<Transaction[]>\n): Array<Transaction> {\n  // Walk any child transaction queues and aggregate them into a single queue.\n  const transactionQueue: Transaction[] = [];\n  this.aggregateTransactionQueuesForNode_(transactionNode, transactionQueue);\n\n  // Sort them by the order the transactions were created.\n  transactionQueue.sort(function(a, b) {\n    return a.order - b.order;\n  });\n\n  return transactionQueue;\n};\n\n/**\n * @param {!Tree.<Array.<Transaction>>} node\n * @param {Array.<Transaction>} queue\n * @private\n */\n(Repo.prototype as any).aggregateTransactionQueuesForNode_ = function(\n  node: Tree<Transaction[]>,\n  queue: Array<Transaction>\n) {\n  const nodeQueue = node.getValue();\n  if (nodeQueue !== null) {\n    for (let i = 0; i < nodeQueue.length; i++) {\n      queue.push(nodeQueue[i]);\n    }\n  }\n\n  node.forEachChild(child => {\n    this.aggregateTransactionQueuesForNode_(child, queue);\n  });\n};\n\n/**\n * Remove COMPLETED transactions at or below this node in the transactionQueueTree_.\n *\n * @param {!Tree.<Array.<!Transaction>>} node\n * @private\n */\n(Repo.prototype as any).pruneCompletedTransactionsBelowNode_ = function(\n  node: Tree<Transaction[]>\n) {\n  const queue = node.getValue();\n  if (queue) {\n    let to = 0;\n    for (let from = 0; from < queue.length; from++) {\n      if (queue[from].status !== TransactionStatus.COMPLETED) {\n        queue[to] = queue[from];\n        to++;\n      }\n    }\n    queue.length = to;\n    node.setValue(queue.length > 0 ? queue : null);\n  }\n\n  node.forEachChild(childNode => {\n    this.pruneCompletedTransactionsBelowNode_(childNode);\n  });\n};\n\n/**\n * Aborts all transactions on ancestors or descendants of the specified path.  Called when doing a set() or update()\n * since we consider them incompatible with transactions.\n *\n * @param {!Path} path Path for which we want to abort related transactions.\n * @return {!Path}\n * @private\n */\n(Repo.prototype as any).abortTransactions_ = function(path: Path): Path {\n  const affectedPath = this.getAncestorTransactionNode_(path).path();\n\n  const transactionNode = this.transactionQueueTree_.subTree(path);\n\n  transactionNode.forEachAncestor((node: Tree<Transaction[]>) => {\n    this.abortTransactionsOnNode_(node);\n  });\n\n  this.abortTransactionsOnNode_(transactionNode);\n\n  transactionNode.forEachDescendant((node: Tree<Transaction[]>) => {\n    this.abortTransactionsOnNode_(node);\n  });\n\n  return affectedPath;\n};\n\n/**\n * Abort transactions stored in this transaction queue node.\n *\n * @param {!Tree.<Array.<Transaction>>} node Node to abort transactions for.\n * @private\n */\n(Repo.prototype as any).abortTransactionsOnNode_ = function(\n  node: Tree<Transaction[]>\n) {\n  const queue = node.getValue();\n  if (queue !== null) {\n    // Queue up the callbacks and fire them after cleaning up all of our transaction state, since\n    // the callback could trigger more transactions or sets.\n    const callbacks = [];\n\n    // Go through queue.  Any already-sent transactions must be marked for abort, while the unsent ones\n    // can be immediately aborted and removed.\n    let events: Event[] = [];\n    let lastSent = -1;\n    for (let i = 0; i < queue.length; i++) {\n      if (queue[i].status === TransactionStatus.SENT_NEEDS_ABORT) {\n        // Already marked.  No action needed.\n      } else if (queue[i].status === TransactionStatus.SENT) {\n        assert(\n          lastSent === i - 1,\n          'All SENT items should be at beginning of queue.'\n        );\n        lastSent = i;\n        // Mark transaction for abort when it comes back.\n        queue[i].status = TransactionStatus.SENT_NEEDS_ABORT;\n        queue[i].abortReason = 'set';\n      } else {\n        assert(\n          queue[i].status === TransactionStatus.RUN,\n          'Unexpected transaction status in abort'\n        );\n        // We can abort it immediately.\n        queue[i].unwatcher();\n        events = events.concat(\n          this.serverSyncTree_.ackUserWrite(queue[i].currentWriteId, true)\n        );\n        if (queue[i].onComplete) {\n          const snapshot: DataSnapshot | null = null;\n          callbacks.push(\n            queue[i].onComplete.bind(null, new Error('set'), false, snapshot)\n          );\n        }\n      }\n    }\n    if (lastSent === -1) {\n      // We're not waiting for any sent transactions.  We can clear the queue.\n      node.setValue(null);\n    } else {\n      // Remove the transactions we aborted.\n      queue.length = lastSent + 1;\n    }\n\n    // Now fire the callbacks.\n    this.eventQueue_.raiseEventsForChangedPath(node.path(), events);\n    for (let i = 0; i < callbacks.length; i++) {\n      exceptionGuard(callbacks[i]);\n    }\n  }\n};\n"]},"metadata":{},"sourceType":"script"}