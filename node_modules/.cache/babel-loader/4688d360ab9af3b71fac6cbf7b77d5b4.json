{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar util_1 = require(\"@firebase/util\");\n\nvar validation_1 = require(\"../core/util/validation\");\n\nvar Path_1 = require(\"../core/util/Path\");\n\nvar PriorityIndex_1 = require(\"../core/snap/indexes/PriorityIndex\");\n/**\n * Class representing a firebase data snapshot.  It wraps a SnapshotNode and\n * surfaces the public methods (val, forEach, etc.) we want to expose.\n */\n\n\nvar DataSnapshot =\n/** @class */\nfunction () {\n  /**\n   * @param {!Node} node_ A SnapshotNode to wrap.\n   * @param {!Reference} ref_ The ref of the location this snapshot came from.\n   * @param {!Index} index_ The iteration order for this snapshot\n   */\n  function DataSnapshot(node_, ref_, index_) {\n    this.node_ = node_;\n    this.ref_ = ref_;\n    this.index_ = index_;\n  }\n  /**\n   * Retrieves the snapshot contents as JSON.  Returns null if the snapshot is\n   * empty.\n   *\n   * @return {*} JSON representation of the DataSnapshot contents, or null if empty.\n   */\n\n\n  DataSnapshot.prototype.val = function () {\n    util_1.validateArgCount('DataSnapshot.val', 0, 0, arguments.length);\n    return this.node_.val();\n  };\n  /**\n   * Returns the snapshot contents as JSON, including priorities of node.  Suitable for exporting\n   * the entire node contents.\n   * @return {*} JSON representation of the DataSnapshot contents, or null if empty.\n   */\n\n\n  DataSnapshot.prototype.exportVal = function () {\n    util_1.validateArgCount('DataSnapshot.exportVal', 0, 0, arguments.length);\n    return this.node_.val(true);\n  }; // Do not create public documentation. This is intended to make JSON serialization work but is otherwise unnecessary\n  // for end-users\n\n\n  DataSnapshot.prototype.toJSON = function () {\n    // Optional spacer argument is unnecessary because we're depending on recursion rather than stringifying the content\n    util_1.validateArgCount('DataSnapshot.toJSON', 0, 1, arguments.length);\n    return this.exportVal();\n  };\n  /**\n   * Returns whether the snapshot contains a non-null value.\n   *\n   * @return {boolean} Whether the snapshot contains a non-null value, or is empty.\n   */\n\n\n  DataSnapshot.prototype.exists = function () {\n    util_1.validateArgCount('DataSnapshot.exists', 0, 0, arguments.length);\n    return !this.node_.isEmpty();\n  };\n  /**\n   * Returns a DataSnapshot of the specified child node's contents.\n   *\n   * @param {!string} childPathString Path to a child.\n   * @return {!DataSnapshot} DataSnapshot for child node.\n   */\n\n\n  DataSnapshot.prototype.child = function (childPathString) {\n    util_1.validateArgCount('DataSnapshot.child', 0, 1, arguments.length); // Ensure the childPath is a string (can be a number)\n\n    childPathString = String(childPathString);\n    validation_1.validatePathString('DataSnapshot.child', 1, childPathString, false);\n    var childPath = new Path_1.Path(childPathString);\n    var childRef = this.ref_.child(childPath);\n    return new DataSnapshot(this.node_.getChild(childPath), childRef, PriorityIndex_1.PRIORITY_INDEX);\n  };\n  /**\n   * Returns whether the snapshot contains a child at the specified path.\n   *\n   * @param {!string} childPathString Path to a child.\n   * @return {boolean} Whether the child exists.\n   */\n\n\n  DataSnapshot.prototype.hasChild = function (childPathString) {\n    util_1.validateArgCount('DataSnapshot.hasChild', 1, 1, arguments.length);\n    validation_1.validatePathString('DataSnapshot.hasChild', 1, childPathString, false);\n    var childPath = new Path_1.Path(childPathString);\n    return !this.node_.getChild(childPath).isEmpty();\n  };\n  /**\n   * Returns the priority of the object, or null if no priority was set.\n   *\n   * @return {string|number|null} The priority.\n   */\n\n\n  DataSnapshot.prototype.getPriority = function () {\n    util_1.validateArgCount('DataSnapshot.getPriority', 0, 0, arguments.length); // typecast here because we never return deferred values or internal priorities (MAX_PRIORITY)\n\n    return this.node_.getPriority().val();\n  };\n  /**\n   * Iterates through child nodes and calls the specified action for each one.\n   *\n   * @param {function(!DataSnapshot)} action Callback function to be called\n   * for each child.\n   * @return {boolean} True if forEach was canceled by action returning true for\n   * one of the child nodes.\n   */\n\n\n  DataSnapshot.prototype.forEach = function (action) {\n    var _this = this;\n\n    util_1.validateArgCount('DataSnapshot.forEach', 1, 1, arguments.length);\n    util_1.validateCallback('DataSnapshot.forEach', 1, action, false);\n    if (this.node_.isLeafNode()) return false;\n    var childrenNode = this.node_; // Sanitize the return value to a boolean. ChildrenNode.forEachChild has a weird return type...\n\n    return !!childrenNode.forEachChild(this.index_, function (key, node) {\n      return action(new DataSnapshot(node, _this.ref_.child(key), PriorityIndex_1.PRIORITY_INDEX));\n    });\n  };\n  /**\n   * Returns whether this DataSnapshot has children.\n   * @return {boolean} True if the DataSnapshot contains 1 or more child nodes.\n   */\n\n\n  DataSnapshot.prototype.hasChildren = function () {\n    util_1.validateArgCount('DataSnapshot.hasChildren', 0, 0, arguments.length);\n    if (this.node_.isLeafNode()) return false;else return !this.node_.isEmpty();\n  };\n\n  Object.defineProperty(DataSnapshot.prototype, \"key\", {\n    get: function () {\n      return this.ref_.getKey();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Returns the number of children for this DataSnapshot.\n   * @return {number} The number of children that this DataSnapshot contains.\n   */\n\n  DataSnapshot.prototype.numChildren = function () {\n    util_1.validateArgCount('DataSnapshot.numChildren', 0, 0, arguments.length);\n    return this.node_.numChildren();\n  };\n  /**\n   * @return {Reference} The Firebase reference for the location this snapshot's data came from.\n   */\n\n\n  DataSnapshot.prototype.getRef = function () {\n    util_1.validateArgCount('DataSnapshot.ref', 0, 0, arguments.length);\n    return this.ref_;\n  };\n\n  Object.defineProperty(DataSnapshot.prototype, \"ref\", {\n    get: function () {\n      return this.getRef();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return DataSnapshot;\n}();\n\nexports.DataSnapshot = DataSnapshot;","map":{"version":3,"sources":["../src/api/DataSnapshot.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { validateArgCount, validateCallback } from '@firebase/util';\nimport { validatePathString } from '../core/util/validation';\nimport { Path } from '../core/util/Path';\nimport { PRIORITY_INDEX } from '../core/snap/indexes/PriorityIndex';\nimport { Node } from '../core/snap/Node';\nimport { Reference } from './Reference';\nimport { Index } from '../core/snap/indexes/Index';\nimport { ChildrenNode } from '../core/snap/ChildrenNode';\n\n/**\n * Class representing a firebase data snapshot.  It wraps a SnapshotNode and\n * surfaces the public methods (val, forEach, etc.) we want to expose.\n */\nexport class DataSnapshot {\n  /**\n   * @param {!Node} node_ A SnapshotNode to wrap.\n   * @param {!Reference} ref_ The ref of the location this snapshot came from.\n   * @param {!Index} index_ The iteration order for this snapshot\n   */\n  constructor(\n    private readonly node_: Node,\n    private readonly ref_: Reference,\n    private readonly index_: Index\n  ) {}\n\n  /**\n   * Retrieves the snapshot contents as JSON.  Returns null if the snapshot is\n   * empty.\n   *\n   * @return {*} JSON representation of the DataSnapshot contents, or null if empty.\n   */\n  val(): any {\n    validateArgCount('DataSnapshot.val', 0, 0, arguments.length);\n    return this.node_.val();\n  }\n\n  /**\n   * Returns the snapshot contents as JSON, including priorities of node.  Suitable for exporting\n   * the entire node contents.\n   * @return {*} JSON representation of the DataSnapshot contents, or null if empty.\n   */\n  exportVal(): any {\n    validateArgCount('DataSnapshot.exportVal', 0, 0, arguments.length);\n    return this.node_.val(true);\n  }\n\n  // Do not create public documentation. This is intended to make JSON serialization work but is otherwise unnecessary\n  // for end-users\n  toJSON(): any {\n    // Optional spacer argument is unnecessary because we're depending on recursion rather than stringifying the content\n    validateArgCount('DataSnapshot.toJSON', 0, 1, arguments.length);\n    return this.exportVal();\n  }\n\n  /**\n   * Returns whether the snapshot contains a non-null value.\n   *\n   * @return {boolean} Whether the snapshot contains a non-null value, or is empty.\n   */\n  exists(): boolean {\n    validateArgCount('DataSnapshot.exists', 0, 0, arguments.length);\n    return !this.node_.isEmpty();\n  }\n\n  /**\n   * Returns a DataSnapshot of the specified child node's contents.\n   *\n   * @param {!string} childPathString Path to a child.\n   * @return {!DataSnapshot} DataSnapshot for child node.\n   */\n  child(childPathString: string): DataSnapshot {\n    validateArgCount('DataSnapshot.child', 0, 1, arguments.length);\n    // Ensure the childPath is a string (can be a number)\n    childPathString = String(childPathString);\n    validatePathString('DataSnapshot.child', 1, childPathString, false);\n\n    const childPath = new Path(childPathString);\n    const childRef = this.ref_.child(childPath);\n    return new DataSnapshot(\n      this.node_.getChild(childPath),\n      childRef,\n      PRIORITY_INDEX\n    );\n  }\n\n  /**\n   * Returns whether the snapshot contains a child at the specified path.\n   *\n   * @param {!string} childPathString Path to a child.\n   * @return {boolean} Whether the child exists.\n   */\n  hasChild(childPathString: string): boolean {\n    validateArgCount('DataSnapshot.hasChild', 1, 1, arguments.length);\n    validatePathString('DataSnapshot.hasChild', 1, childPathString, false);\n\n    const childPath = new Path(childPathString);\n    return !this.node_.getChild(childPath).isEmpty();\n  }\n\n  /**\n   * Returns the priority of the object, or null if no priority was set.\n   *\n   * @return {string|number|null} The priority.\n   */\n  getPriority(): string | number | null {\n    validateArgCount('DataSnapshot.getPriority', 0, 0, arguments.length);\n\n    // typecast here because we never return deferred values or internal priorities (MAX_PRIORITY)\n    return this.node_.getPriority().val() as string | number | null;\n  }\n\n  /**\n   * Iterates through child nodes and calls the specified action for each one.\n   *\n   * @param {function(!DataSnapshot)} action Callback function to be called\n   * for each child.\n   * @return {boolean} True if forEach was canceled by action returning true for\n   * one of the child nodes.\n   */\n  forEach(action: (d: DataSnapshot) => void): boolean {\n    validateArgCount('DataSnapshot.forEach', 1, 1, arguments.length);\n    validateCallback('DataSnapshot.forEach', 1, action, false);\n\n    if (this.node_.isLeafNode()) return false;\n\n    const childrenNode = this.node_ as ChildrenNode;\n    // Sanitize the return value to a boolean. ChildrenNode.forEachChild has a weird return type...\n    return !!childrenNode.forEachChild(this.index_, (key, node) => {\n      return action(\n        new DataSnapshot(node, this.ref_.child(key), PRIORITY_INDEX)\n      );\n    });\n  }\n\n  /**\n   * Returns whether this DataSnapshot has children.\n   * @return {boolean} True if the DataSnapshot contains 1 or more child nodes.\n   */\n  hasChildren(): boolean {\n    validateArgCount('DataSnapshot.hasChildren', 0, 0, arguments.length);\n\n    if (this.node_.isLeafNode()) return false;\n    else return !this.node_.isEmpty();\n  }\n\n  get key() {\n    return this.ref_.getKey();\n  }\n\n  /**\n   * Returns the number of children for this DataSnapshot.\n   * @return {number} The number of children that this DataSnapshot contains.\n   */\n  numChildren(): number {\n    validateArgCount('DataSnapshot.numChildren', 0, 0, arguments.length);\n\n    return this.node_.numChildren();\n  }\n\n  /**\n   * @return {Reference} The Firebase reference for the location this snapshot's data came from.\n   */\n  getRef(): Reference {\n    validateArgCount('DataSnapshot.ref', 0, 0, arguments.length);\n\n    return this.ref_;\n  }\n\n  get ref() {\n    return this.getRef();\n  }\n}\n"]},"metadata":{},"sourceType":"script"}